<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>「数据结构」线段树 | CCA&#39;s Blog</title>
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="线段树是算法竞赛中最常见的数据结构，有很多分支，非常重要。">
  
  
  
    <link rel="shortcut icon" href="../../../../favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../../../../index.html">Home</a>
    
      <a class="main-nav-link" href="../../../../archives">Archives</a>
    
    <div class="main-nav-space-between"></div>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="../../../../index.html" id="logo">CCA&#39;s Blog</a>
  </h1>
  
    <h2 id="subtitle-wrap">
      <a href="../../../../index.html" id="subtitle">智慧. 优雅. 理性.</a>
    </h2>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-[数据结构]线段树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="" class="article-date">
  <time class="dt-published" datetime="2023-06-24T03:00:56.723Z" itemprop="datePublished">2023-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      「数据结构」线段树
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>线段树是算法竞赛中最常见的数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有很多分支<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>非常重要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<span id="more"></span>
<h2 id="经典例题">经典例题</h2>
<h3 id="[lg5490]-扫描线">[LG5490] 扫描线</h3>
<p>扫描线模板题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从小到大枚举横线的纵坐标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举到矩形下界就给这条边的左右端点构成的区间 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则 <span class="markdown-them-math-inline">$-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用线段树维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前线段树有值的结点个数就是这个纵坐标的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>怎么维护线段树中不为 <span class="markdown-them-math-inline">$0$</span> 的位置数量呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>我们发现在做扫描线的时候权值不会小于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们考虑维护区间最小值和最小值的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个在合并的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果左右儿子的最小值相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将其最小值数量加起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则继承最小值更小的那个的最小值数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>当然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>本题还需要动态开点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以需要维护区间内有效点的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[spoj]-gss-i">[SPOJ] GSS-I</h3>
<p>先求出前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现答案为区间最大值减最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但需要满足最小值在最大值右边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对线段树的每个节点维护最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最大值和答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现答案可以从两棵子树的答案更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以更新为右子树中的最大值减去左子树中的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>于是直接用线段树即可维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[spoj]-gss-iii">[SPOJ] GSS-III</h3>
<p>发现这题是带修版的 <span class="markdown-them-math-inline">$\rm GSS1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是由于前缀和无法动态修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑直接维护区间和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>显然要维护区间和以及最大子段和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现最大子段和需要通过左儿子的最大后缀和和右儿子的最大前缀和更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是再记最大前后缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而最大前后缀和是可以通过区间和和子节点的最大前后缀和计算的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是这题就可以用线段树做了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[spoj]-gss-iv">[SPOJ] GSS-IV</h3>
<p>我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个区间内如果全都是 <span class="markdown-them-math-inline">$1$</span> 或 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么对它开方是没有意义的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以记录最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果最大值为 <span class="markdown-them-math-inline">$0$</span> 或 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么直接跳过这个区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们发现这样做每个点最多被修改 <span class="markdown-them-math-inline">$7$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[spoj]-gss-v">[SPOJ] GSS-V</h3>
<p>我们发现这个问题和 <span class="markdown-them-math-inline">$\rm GSS-I$</span> 很像<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>唯一的区别是左右两边限定了区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现如果两个区间不重合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那就是右区间最大值减左区间最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>若两区间重合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令从左到右三个区域分别为 <span class="markdown-them-math-inline">$\rm I,II,III$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>首先用 <span class="markdown-them-math-inline">$\rm \max\{II\cup III\}-\min\{I\}$</span> 更新答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后用 <span class="markdown-them-math-inline">$\rm \max\{III\}-\min\{I\cup II\}$</span> 更新答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后只剩下两个端点都在 <span class="markdown-them-math-inline">$\rm II$</span> 内的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个就是 <span class="markdown-them-math-inline">$\rm GSS-I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[lg4198]-楼房重建">[LG4198] 楼房重建</h3>
<p>首先肯定将每个楼房的信息转化为斜率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然要维护区间最大值和从这个区间左端点开始能看到多少栋楼<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>现在考虑将左右区间合并<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然要先将左区间的答案加上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后考虑右区间能看到多少个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li>如果左区间的最大值小于右区间的左区间的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么肯定对右区间的右区间没有影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将右区间的右区间的答案加上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>左区间递归<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>如果左区间的最大值大于右区间的左区间的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么右区间的左区间肯定一个都看不到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接将右区间的右区间递归下去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>单次合并时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log ^2n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\quad\rm PS:$</span> 这题有个坑点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算右区间的右儿子的答案的时候不能写成 <code>ans[RS]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是要写成 <code>ans[p] - ans[LS]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为右儿子的答案可能会被左儿子挡掉一些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些还是不能算进去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[lg1502]-窗口的星星">[LG1502] 窗口的星星</h3>
<p>考虑将每颗行星变成一个带权矩形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现最大亮度和就是最大矩形交的权值之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>考虑用扫描线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护区间最大值即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>坑点 <span class="markdown-them-math-inline">$1:$</span> 由于边界上的点不用算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以矩形右上角为 <span class="markdown-them-math-inline">$(x+w-1,y+h-1).$</span></p>
<p>坑点 <span class="markdown-them-math-inline">$2:$</span> 我们在每次修改过后都统计了一遍答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以当线段纵坐标相同的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删除要排在前面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>防止统计了一个不合法的大的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[cf240f]-torcoder">[CF240F] TorCoder</h3>
<p>考虑一次操作干了什么事情<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若存在一个以上字母出现了奇数次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则无法重排<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则将出现奇数次的字母放在最中间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将所有字母按照从小到大再从大到小的顺序放在这个字母的两边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>于是可以对每个字母开一颗线段树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护区间赋值操作和区间求数量操作即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n|\Sigma|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[cf242e]-xor on segment">[CF242E] XOR on Segment</h3>
<p>考虑对每一位开一颗线段树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>问题就变成了维护一个 <span class="markdown-them-math-inline">$0/1$</span> 序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>支持区间取反和区间求和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log^2n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[cf414c]-mashmokh and reverse operation">[CF414C] Mashmokh and Reverse Operation</h3>
<p>我们发现这个题目中区间的结构很像一颗线段树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑它的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>发现交换一个翻转一个区间等价于将它的两个子区间交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后递归操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而一个区间的逆序对数量为两个子区间之间的逆序对数量加上两个子区间内部的逆序对数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>于是考虑维护每一层每一个结点的两个子区间之间的逆序对数量之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>修改操作就变成了将某一层下面的所有区间翻转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于层数只有 <span class="markdown-them-math-inline">$20$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以直接维护每一层是否被翻转即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求当前的答案只需要预处理每一层的所有节点的两个子区间之间的答案之和即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现一层区间一定是一起翻转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是每一层只有两种状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别预处理即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>时间复杂度 <span class="markdown-them-math-inline">$\Theta[(2^n+m)n]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[cf446c]-dzy loves fibonacci numbers">[CF446C] DZY Loves Fibonacci Numbers</h3>
<p>我们知道 <span class="markdown-them-math-inline">$F_{n}=\frac{\sqrt{5}}{5}\left[\left(\frac{1+\sqrt{5}}{2}\right)^{n}-\left(\frac{1-\sqrt{5}}{2}\right)^{n}\right].$</span></p>
<p>于是可以发现只需要分别维护两个序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在一个序列中公比相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>故我们只需要维护首项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后面的数可以直接算出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下传的时候给左子区间直接加上这个首项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>右子区间加首项乘上 <span class="markdown-them-math-inline">$q^{\frac{r-l+1}{2}}$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="[cf522d]-closest equals">[CF522D] Closest Equals</h3>
<p>我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果记 <span class="markdown-them-math-inline">$p_i$</span> 表示距离 <span class="markdown-them-math-inline">$i$</span> 最近的在 <span class="markdown-them-math-inline">$i$</span> 之前的与 <span class="markdown-them-math-inline">$i$</span> 颜色相同的点与 <span class="markdown-them-math-inline">$i$</span> 的距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么对于一个询问 <span class="markdown-them-math-inline">$[l,r]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其答案为所有满足 <span class="markdown-them-math-inline">$i-p_i\geqslant l$</span> 和 <span class="markdown-them-math-inline">$i\leqslant r$</span> 的点中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p_i$</span> 最小的那个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>于是考虑将坐标离散化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将询问离线下来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按右端点排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个个枚举 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$p_i\not =0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将 <span class="markdown-them-math-inline">$C_{i-p_i}$</span> 的值与 <span class="markdown-them-math-inline">$p_i$</span> 取 <span class="markdown-them-math-inline">$\min$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$C$</span> 中区间 <span class="markdown-them-math-inline">$[l,r]$</span> 内的最小值就是这个区间的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>单点修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>区间查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以使用线段树维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现 <span class="markdown-them-math-inline">$[l,r]$</span> 的答案和 <span class="markdown-them-math-inline">$[l,n]$</span> 的答案是相同的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是也可以使用树状数组维护后缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../za-xiang-fan-hui-tan-xin/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          「杂项」反悔贪心
        
      </div>
    </a>
  
  
    <a href="../shu-ju-jie-gou-shu-lie-fen-kuai/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          「数据结构」数列分块
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a><br /><a rel="license" href="https://101001011.github.io/">本网站</a>所有内容采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="../../../../js/clipboard.min.js"></script>
<script src="../../../../js/jquery-1.4.3.min.js"></script>

<script src="../../../../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../../../../js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="../../../../mathjax/tex-chtml.js">
</script>
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->

  </div>
</body>
</html>