<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>24 高考新 I 卷数学 19(3) CCA 个人解答</title>
      <link href="/2024/06/08/ti-jie-24-xin-gao-kao-i-juan-shu-xue-19-3/"/>
      <url>/2024/06/08/ti-jie-24-xin-gao-kao-i-juan-shu-xue-19-3/</url>
      
        <content type="html"><![CDATA[<p>对 <span class="markdown-them-math-inline">$m = 1, 2$</span>, 取几组合法 <span class="markdown-them-math-inline">$(i, j)$</span> 即证.</p><p>对 <span class="markdown-them-math-inline">$m \geqslant 3$</span>, 设 <span class="markdown-them-math-inline">$f_m$</span> 表示 <span class="markdown-them-math-inline">$a_{1 \sim 4m + 2}$</span> 中能取出的合法数对数量.</p><p>注意到 <span class="markdown-them-math-inline">$a_{1 \sim 4m + 2}$</span> 中任意长度为 <span class="markdown-them-math-inline">$4l + 2$</span> 的子区间对应的答案均为 <span class="markdown-them-math-inline">$f_l$</span>, 则取分界点 <span class="markdown-them-math-inline">$p_1 = 4, p_2 = 4m - 2$</span>​ 进行容斥.</p><div class="markdown-them-math-block">$$\begin{aligned}f_m &amp;= f_m[i \not\in [1, p_1]~\textrm{or}~j \not\in [p_2 + 1, 4m + 2]] + f_m[i \in [1, p_1]~\textrm{and}~j \in [p_2 + 1, 4m + 2]]\\&amp;= f_m[i, j \in [p_1 + 1, 4m + 2]] + f_m[i, j \in [1, p_2]] - f_m[i, j \in [p_1 + 1, p_2]] \\&amp;~~~~+ f_m[i \in [1, p_1]~\textrm{and}~j \in [p_2 + 1, 4m + 2]]\\&amp;= 2f_{m - 1} - f_{m - 2} + f_m[i \in [1, p_1]~\textrm{and}~j \in [p_2 + 1, 4m + 2]]\end{aligned}$$</div><p>考虑求 <span class="markdown-them-math-inline">$f_m[i \in [1, p_1]~\textrm{and}~j \in [p_2 + 1, 4m + 2]]$</span> 的下界.</p><ul><li>显然 <span class="markdown-them-math-inline">$(i, j) = (1, 4m + 2)$</span> 是合法的.</li><li>对于 <span class="markdown-them-math-inline">$(i, j) = (2, 4m + 1)$</span>,  当 <span class="markdown-them-math-inline">$m = 3$</span> 时其合法性在第 <span class="markdown-them-math-inline">$(2)$</span> 问中已证. 当 <span class="markdown-them-math-inline">$m &gt; 3$</span> 时, 从前后各取 <span class="markdown-them-math-inline">$2$</span> 个下标公差为 <span class="markdown-them-math-inline">$2$</span> 的子序列, 注意到只看子区间 <span class="markdown-them-math-inline">$[9, 4m - 6]$</span>, 其中 <span class="markdown-them-math-inline">$10$</span> 和 <span class="markdown-them-math-inline">$4m - 7$</span> 已经被取过了, 于是变成了等价的子问题. 故归纳可证 <span class="markdown-them-math-inline">$(i, j) = (2, 4m + 1)$</span> 是合法的.</li></ul><p>此时有 <span class="markdown-them-math-inline">$f_m[i \in [1, p_1]~\textrm{and}~j \in [p_2 + 1, 4m + 2]] \geqslant 2$</span>, 于是 <span class="markdown-them-math-inline">$f_m \geqslant 2f_{m - 1} - f_{m - 2} + 2$</span>.</p><p>取 <span class="markdown-them-math-inline">$f'_m = 2f'_{m - 1} - f'_{m - 2} + 2 \leqslant f_m, f'_1 = 3, f'_2 = 7$</span>.</p><p>变换得 <span class="markdown-them-math-inline">$(f'_m - f'_{m - 1}) = (f'_{m - 1} - f'_{m - 2}) + 2$</span>, 由熟知的方法解得 <span class="markdown-them-math-inline">$f_m \geqslant f'_m = m ^ 2 + m + 1$</span>.</p><p>于是 <span class="markdown-them-math-inline">$P_m = \frac{f_m}{\binom{4m + 2}{2}} \geqslant \frac{f'_m}{\binom{4m + 2}{2}} = \frac{m ^ 2 + m + 1}{8m^2 + 6m + 1} &gt; \frac{1}{8}$</span>, 原命题得证.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于「顺序遍历随机排列取尽可能大的值」问题的一些思考</title>
      <link href="/2024/04/11/guan-yu-shun-xu-bian-li-sui-ji-pai-lie-qu-jin-ke-neng-da-de-zhi-wen-ti-de-yi-xie-si-kao/"/>
      <url>/2024/04/11/guan-yu-shun-xu-bian-li-sui-ji-pai-lie-qu-jin-ke-neng-da-de-zhi-wen-ti-de-yi-xie-si-kao/</url>
      
        <content type="html"><![CDATA[<p>一个广为流传的结论是: 从前往后遍历 <span class="markdown-them-math-inline">$37\%$</span> 的元素(事实上是 <span class="markdown-them-math-inline">$\frac{1}{e}$</span>), 称其中最大的为 <span class="markdown-them-math-inline">$\max$</span>, 继续往后遍历, 一旦一个元素大于 <span class="markdown-them-math-inline">$\max$</span> 就立刻选择, 找不到则选最后一个元素 .</p><p>写了一个程序来验证这个结论:</p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> drawn, t = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()) <span class="hljs-comment"># n, t = 1000, 100000</span>p = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]aveval = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]maxval = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcave</span> (<span class="hljs-params">pos</span>):</span>    Max = -<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pos): Max = <span class="hljs-built_in">max</span>(Max, p[i])    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pos, n):        <span class="hljs-keyword">if</span> p[i] &gt; Max: <span class="hljs-keyword">return</span> p[i]    <span class="hljs-keyword">return</span> p[n - <span class="hljs-number">1</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcmax</span> (<span class="hljs-params">pos</span>):</span>    Max = -<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pos): Max = <span class="hljs-built_in">max</span>(Max, p[i])    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pos, n):        <span class="hljs-keyword">if</span> p[i] &gt; Max: <span class="hljs-keyword">return</span> (p[i] == n - <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> (p[n - <span class="hljs-number">1</span>] == n - <span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t):    random.shuffle(p)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): aveval[i] += calcave(i)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): maxval[i] += calcmax(i)aveval = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x / t / n, aveval))maxval = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x / t, maxval))draw.plot([<span class="hljs-number">100</span> / n * i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)], aveval)draw.plot([<span class="hljs-number">100</span> / n * i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)], maxval)idx, val = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):    <span class="hljs-keyword">if</span> aveval[i] &gt; val:        val, idx = aveval[i], <span class="hljs-number">100</span> / n * idraw.plot(idx, val, <span class="hljs-string">&#x27;or&#x27;</span>)draw.text(idx, val, <span class="hljs-string">&quot;(&#123;:.1f&#125;%, &#123;:.2f&#125;)&quot;</span>.<span class="hljs-built_in">format</span>(idx, val), color = <span class="hljs-string">&#x27;r&#x27;</span>)idx, val = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):    <span class="hljs-keyword">if</span> maxval[i] &gt; val:        val, idx = maxval[i], <span class="hljs-number">100</span> / n * idraw.plot(idx, val, <span class="hljs-string">&#x27;or&#x27;</span>)draw.text(idx, val, <span class="hljs-string">&quot;(&#123;:.1f&#125;%, &#123;:.2f&#125;)&quot;</span>.<span class="hljs-built_in">format</span>(idx, val), color = <span class="hljs-string">&#x27;r&#x27;</span>)draw.show()</code></pre></div><p>得到结果如下:</p><p><img src="https://s21.ax1x.com/2024/04/11/pFXdXyd.png" alt="pFXdXyd.png"></p><p>其中蓝线为这种策略取到的元素大小期望除以 <span class="markdown-them-math-inline">$n$</span> 的值, 也即取到的元素占最大值百分比的期望. 橙线表示取到最大值的概率. 横坐标为观察的元素数量占总元素数量的比例.</p><p>可以发现, 虽然观察 <span class="markdown-them-math-inline">$37.1\%$</span> 的元素有最大的概率取到最大值, 但只观察 <span class="markdown-them-math-inline">$3.1\%$</span> 的元素就出手获得的元素期望是最大的, 这启发我们, 直接取某一个位置之后的第一个前缀最大值是否有些呆板了呢? 我们是否可以做一些更加动态的决策呢?</p><p>接下来会尝试训练一个神经网络用以决策, 未完待续……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「新的思考」整除性校验的本质</title>
      <link href="/2024/04/09/xin-de-si-kao-zheng-chu-xing-jian-yan-de-ben-zhi/"/>
      <url>/2024/04/09/xin-de-si-kao-zheng-chu-xing-jian-yan-de-ben-zhi/</url>
      
        <content type="html"><![CDATA[<p>本文从常见的模 <span class="markdown-them-math-inline">$3$</span> 余 <span class="markdown-them-math-inline">$0$</span>, 模 <span class="markdown-them-math-inline">$7$</span> 余 <span class="markdown-them-math-inline">$0$</span> 的条件中抽象出了其数论本质.</p><span id="more"></span><p>从小学开始我们就知道, 一个数能被 <span class="markdown-them-math-inline">$3$</span> 整除当且仅当其各位数字之和能被 <span class="markdown-them-math-inline">$3$</span> 整除. 一个数能被 <span class="markdown-them-math-inline">$4$</span> 整除, 当且仅当其最后 <span class="markdown-them-math-inline">$2$</span> 位数能被 <span class="markdown-them-math-inline">$4$</span> 整除. 一个数能被 <span class="markdown-them-math-inline">$11$</span> 整除, 当且仅当其奇数位减去偶数位数字之和能被 <span class="markdown-them-math-inline">$11$</span> 整除(个位数记为第 <span class="markdown-them-math-inline">$1$</span> 位).</p><p>长大一点后, 我们可以用数学语言来刻画这个规律 :</p><div class="markdown-them-math-block">$$\begin{cases}\overline{a_ta_{t - 1}\cdots a_2a_1} \equiv a_1 + a_2 + \cdots + a_t \pmod 3 \\\overline{a_ta_{t - 1}\cdots a_2a_1} \equiv \overline{a_2a_2} \pmod 4 \\\overline{a_ta_{t - 1}\cdots a_2a_1} \equiv a_1 - a_2 + a_3 - \cdots + (-1)^{t - 1} a_t \pmod {11} \\\overline{a_ta_{t - 1}\cdots a_2a_1} \equiv \overline{a_3a_2a_1} - \overline{a_6a_5a_4} + \cdots + (-1)^{\frac{t}{3} - 1} \overline{a_ta_{t - 1}a_{t - 2}} \pmod 7\end{cases}$$</div><p>容易发现, 其分为 <span class="markdown-them-math-inline">$3$</span> 类 :</p><ul><li>第一类: <span class="markdown-them-math-inline">$x$</span> 与 <span class="markdown-them-math-inline">$x$</span> 的末 <span class="markdown-them-math-inline">$k$</span> 位在模 <span class="markdown-them-math-inline">$n$</span> 意义下同余.</li><li>第二类: <span class="markdown-them-math-inline">$x$</span> 与 <span class="markdown-them-math-inline">$x$</span> 每 <span class="markdown-them-math-inline">$k$</span> 位一段求和得到的数在模 <span class="markdown-them-math-inline">$n$</span> 意义下同余.</li><li>第三类: <span class="markdown-them-math-inline">$x$</span> 与 <span class="markdown-them-math-inline">$x$</span> 每 <span class="markdown-them-math-inline">$k$</span> 位一段正负交替求和得到的数在模 <span class="markdown-them-math-inline">$n$</span> 意义下同余.</li></ul><p>现在我们来探寻 <span class="markdown-them-math-inline">$b$</span> 进制数在模 <span class="markdown-them-math-inline">$n$</span> 意义下可以使用哪种同余化简方式(或不满足三类中任意一种).</p><ol><li>若存在 <span class="markdown-them-math-inline">$k$</span> 满足 <span class="markdown-them-math-inline">$b ^ k \equiv 0 \pmod n$</span>, 那么 <span class="markdown-them-math-inline">$\overline{a_ta_{t - 1}\cdots a_{k + 1}00 \cdots 0} \equiv 0 \pmod n$</span>, 则 <span class="markdown-them-math-inline">$\overline{a_ta_{t - 1}\cdots a_2a_1} \equiv \overline{a_ka_{k - 1}\cdots a_2a_1} \pmod n$</span>, 可以使用第一类化简方式.</li><li>若存在 <span class="markdown-them-math-inline">$k$</span> 满足 <span class="markdown-them-math-inline">$b ^ k \equiv 1 \pmod n$</span>, 那么 <span class="markdown-them-math-inline">$\overline{a_ta_{t - 1}\cdots a_{k + 1}00 \cdots 0} \equiv \overline{a_ta_{t - 1}\cdots a_{k + 1}} \pmod n$</span>, 则 <span class="markdown-them-math-inline">$\overline{a_ta_{t - 1}\cdots a_2a_1} \equiv \overline{a_ka_{k - 1}\cdots a_1} + \overline{a_{2k}a_{2k - 1}\cdots a_{k + 1}} + \cdots \pmod n$</span>, 可以使用第二类化简方式.</li><li>若存在 <span class="markdown-them-math-inline">$k$</span> 满足 <span class="markdown-them-math-inline">$b ^ k \equiv -1 \pmod n$</span>, 那么 <span class="markdown-them-math-inline">$\overline{a_{pk}a_{pk - 1}\cdots a_{(p - 1)k + 1} 00\cdots 0} \equiv (-1) ^ p\overline{a_{pk}a_{pk - 1}\cdots a_{(p - 1)k + 1}}$</span>, 则 <span class="markdown-them-math-inline">$\overline{a_ta_{t - 1}\cdots a_2a_1} \equiv \overline{a_ka_{k - 1}\cdots a_1} - \overline{a_{2k}a_{2k - 1}\cdots a_{k + 1}} + \cdots \pmod n$</span>, 可以使用第三类化简方式.</li></ol><p>于是想找到 <span class="markdown-them-math-inline">$b$</span> 进制数在模 <span class="markdown-them-math-inline">$n$</span> 意义下的化简方式, 只需要找到最小的 <span class="markdown-them-math-inline">$k$</span> 满足 <span class="markdown-them-math-inline">$b ^ k \equiv 0~\textrm{or}~1~\textrm{or}- 1$</span> 即对应第 <span class="markdown-them-math-inline">$1/2/3$</span> 类化简方式. 若直到 <span class="markdown-them-math-inline">$k$</span> 等于 <span class="markdown-them-math-inline">$b$</span> 的幂在模 <span class="markdown-them-math-inline">$n$</span> 意义下的循环节长度仍未找到满足条件的 <span class="markdown-them-math-inline">$k$</span>, 则 <span class="markdown-them-math-inline">$b$</span> 进制数在模 <span class="markdown-them-math-inline">$n$</span> 意义下不能使用这 <span class="markdown-them-math-inline">$3$</span> 种方式化简.</p><p>一种找最小 <span class="markdown-them-math-inline">$k$</span> 的代码实现如下 :</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> T, b, n;unordered_map &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>&gt; vis;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T); <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;b, &amp;n), b %= n;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, k = <span class="hljs-number">1</span>, tmp = b;        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span> &amp;&amp; b != <span class="hljs-number">1</span> &amp;&amp; b != n - <span class="hljs-number">1</span> &amp;&amp; !vis[b]) &#123;            vis[b] = <span class="hljs-literal">true</span>;            b = <span class="hljs-number">1ll</span> * b * tmp % n, k++;        &#125;        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) a = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>) a = <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (b == n - <span class="hljs-number">1</span>) a = <span class="hljs-number">3</span>;        a ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kind = %d, k = %d\n&quot;</span>, a, k) : <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);        vis.<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「新的思考」一类贝叶斯定理相关积分的变换技巧</title>
      <link href="/2024/04/09/xin-de-si-kao-yi-lei-bei-xie-si-ding-li-xiang-guan-ji-fen-de-bian-huan-ji-qiao/"/>
      <url>/2024/04/09/xin-de-si-kao-yi-lei-bei-xie-si-ding-li-xiang-guan-ji-fen-de-bian-huan-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>在一些情况下, 非负实数域上存在一些可用条件概率刻画的期望, 但概率密度函数是难以计算的.</p><p>本文介绍了一种变换, 可以避免直接计算概率密度函数, 而是改为计算某种反过来的条件概率.</p><span id="more"></span><p>考虑非负实数域上某可用条件概率刻画的期望<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$E(x) = \int_{0}^{+\infty} xP(t = x|q) \mathrm{d}x$$</div><p>其中 <span class="markdown-them-math-inline">$q$</span> 为已知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$P(q|t = x)$</span> 是可用初等函数刻画的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>考虑贝叶斯定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$E(x) = \int_{0}^{+\infty} x\frac{P(q|t = x)P(t = x)}{P(q)} \mathrm{d}x$$</div><p>观察发现对 <span class="markdown-them-math-inline">$x$</span> 微分本质上就是在枚举每个 <span class="markdown-them-math-inline">$t = x$</span> 的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$P(t = x)$</span> 已经被 <span class="markdown-them-math-inline">$\mathrm{d}x$</span> 包含<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以看作 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故</p><div class="markdown-them-math-block">$$E(x) = \int_{0}^{+\infty} x\frac{P(q|t = x)}{P(q)} \mathrm{d}x$$</div><p>大多数情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>哪怕 <span class="markdown-them-math-inline">$P(q)$</span> 可以用初等函数刻画<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整个式子也会难以化简<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑拆 <span class="markdown-them-math-inline">$P(q)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$E(x) = \int_{0}^{+\infty} x\frac{P(q|t = x)}{\int_{0}^{+\infty} P(q|t = y) \mathrm{d}y } \mathrm{d}x$$</div><p>整理可得</p><div class="markdown-them-math-block">$$E(x) = \frac{\int_{0}^{+\infty} xP(q|t = x) \mathrm{d}x}{\int_{0}^{+\infty} P(q|t = x) \mathrm{d}x }$$</div><p>设 <span class="markdown-them-math-inline">$P(q|t = x) = f(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$f(x)$</span> 是初等函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>又设 <span class="markdown-them-math-inline">$\delta$</span> 为积分算子<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$[\delta f(x)]' = f(x)$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即得</p><div class="markdown-them-math-block">$$E(x) = \frac{\int_{0}^{+\infty} xf(x) \mathrm{d}x}{\int_{0}^{+\infty} f(x) \mathrm{d}x } = \lim_{\varepsilon \to 0^+}^{m \to +\infty}\frac{\delta mf(m) - \delta \varepsilon f(\varepsilon)}{\delta f(m) - \delta f(\varepsilon)}$$</div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「题解」2024 年 2~3 月趣题记录</title>
      <link href="/2024/04/09/ti-jie-2024-nian-2-3-yue-qu-ti-ji-lu/"/>
      <url>/2024/04/09/ti-jie-2024-nian-2-3-yue-qu-ti-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>​</p><span id="more"></span><h1 id="[$\rm-cf1929d$](https://codeforcescom/contest/1929/problem/d) $\rm (^*1974)$"><a href="https://codeforces.com/contest/1929/problem/D"><span class="markdown-them-math-inline">$\rm CF1929D$</span></a> <span class="markdown-them-math-inline">$\rm (^*1974)$</span></h1><p>给定一颗 <span class="markdown-them-math-inline">$n$</span> 个点的树, 求黑白染色的方案数, 使任意一条路径上的黑点数量不超过 <span class="markdown-them-math-inline">$2$</span>.</p><p><span class="markdown-them-math-inline">$2 \leqslant n \leqslant 3 \times 10 ^ 5, \mathrm{mod} = 998244353$</span>.</p><hr><p>最自然的想法肯定是设 <span class="markdown-them-math-inline">$f_{u, 0/1/2}$</span> 表示考虑以 <span class="markdown-them-math-inline">$u$</span> 为根的子树, 所有从 <span class="markdown-them-math-inline">$u$</span> 到叶子的链中, 包含黑点数量最大的恰好为 <span class="markdown-them-math-inline">$0/1/2$</span> 的方案数. 转移考虑 <span class="markdown-them-math-inline">$u$</span> 是否为黑点进行分类讨论即可.</p><p>但出题人给出了一种另辟蹊径的做法, 设 <span class="markdown-them-math-inline">$f_u$</span> 表示考虑以 <span class="markdown-them-math-inline">$u$</span> 为根的子树, 所有从 <span class="markdown-them-math-inline">$u$</span> 到叶子的链中, 包含黑点数量最大的<strong>恰好</strong>为 <span class="markdown-them-math-inline">$1$</span> 的方案数. 设 <span class="markdown-them-math-inline">$v \in son_u$</span>, 则所有 <span class="markdown-them-math-inline">$v$</span> 的染色方案互不干扰, 故有 <span class="markdown-them-math-inline">$f_u = \prod (f_v + 1)$</span>.</p><p>考虑如何计算被漏掉的, 存在黑色点对 <span class="markdown-them-math-inline">$(u, v)$</span> 满足 <span class="markdown-them-math-inline">$u$</span> 是 <span class="markdown-them-math-inline">$v$</span> 的祖先的情况. 我们发现如果枚举 <span class="markdown-them-math-inline">$u$</span>, <span class="markdown-them-math-inline">$\sum_{v \in son_u} f_v$</span> 即为点对 <span class="markdown-them-math-inline">$(u, v)$</span> 的数量, 若枚举所有 <span class="markdown-them-math-inline">$u$</span>, 则 <span class="markdown-them-math-inline">$2 \sim n$</span> 号结点恰好均被计算一次. 再加上不存在黑色点对 <span class="markdown-them-math-inline">$(u, v)$</span> 满足 <span class="markdown-them-math-inline">$u$</span> 是 <span class="markdown-them-math-inline">$v$</span> 的祖先的情况 <span class="markdown-them-math-inline">$f_1 + 1$</span>, 答案即为 <span class="markdown-them-math-inline">$1 + \sum f_u$</span>.</p><p>该算法时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> T, n, f[N];vector &lt;<span class="hljs-keyword">int</span>&gt; E[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;    f[u] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : E[u]) <span class="hljs-keyword">if</span> (v != fa)        <span class="hljs-built_in">dfs</span>(v, u), f[u] = <span class="hljs-number">1ll</span> * f[u] * (f[v] + <span class="hljs-number">1</span>) % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cin &gt;&gt; T; <span class="hljs-keyword">while</span> (T--) &#123;        cin &gt;&gt; n;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u, v, i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            cin &gt;&gt; u &gt;&gt; v;            E[u].<span class="hljs-built_in">push_back</span>(v), E[v].<span class="hljs-built_in">push_back</span>(u);        &#125;        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ans = (ans + f[i]) % mod;        cout &lt;&lt; (ans + <span class="hljs-number">1</span>) % mod &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) E[i].<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-cf1929e$](https://codeforcescom/contest/1929/problem/d) $\rm (^*2414)$"><a href="https://codeforces.com/contest/1929/problem/D"><span class="markdown-them-math-inline">$\rm CF1929E$</span></a> <span class="markdown-them-math-inline">$\rm (^*2414)$</span></h1><p>有一棵 <span class="markdown-them-math-inline">$n$</span> 个顶点的树, 对于其上 <span class="markdown-them-math-inline">$k$</span> 对顶点 <span class="markdown-them-math-inline">$(a_1, b_1), \ldots, (a_k, b_k)$</span> 中的任意一对, 在顶点 <span class="markdown-them-math-inline">$a_i$</span> 与 <span class="markdown-them-math-inline">$b_i$</span> 之间的简单路径上至少有一条边为黑色. 为了满足该条件, 求树上最少有多少条黑色边.</p><p><span class="markdown-them-math-inline">$n \leqslant 10 ^ 5, k \leqslant 20$</span>.</p><hr><p><strong>注意到选择的边一定是至少一条路径上深度最浅的边</strong>.</p><p>证明: 选深度最浅的边更劣, 当且仅当可以构造出两条路径 <span class="markdown-them-math-inline">$L_1,L_2$</span> 在某条边 <span class="markdown-them-math-inline">$e$</span> 处相交, 且满足:</p><ul><li><span class="markdown-them-math-inline">$e$</span> 不是 <span class="markdown-them-math-inline">$L_1, L_2$</span> 最浅的边.</li><li><span class="markdown-them-math-inline">$e$</span> 的父边不同时属于 <span class="markdown-them-math-inline">$L_1, L_2$</span>​.</li></ul><p>否则 <span class="markdown-them-math-inline">$e$</span> 用其父边替换一定不劣.</p><p>但是, 若 <span class="markdown-them-math-inline">$e$</span> 不是 <span class="markdown-them-math-inline">$L$</span> 最浅的边, 则 <span class="markdown-them-math-inline">$e$</span> 的父边一定属于 <span class="markdown-them-math-inline">$L$</span>, 故 <span class="markdown-them-math-inline">$e$</span> 的父边同时属于 <span class="markdown-them-math-inline">$L_1, L_2$</span>, 产生矛盾, 故原命题得证.</p><p>因此我们发现, 该树中可能成为答案的边最多 <span class="markdown-them-math-inline">$2k$</span> 条, 且每条边 <span class="markdown-them-math-inline">$e$</span> 分别对应了一个集合 <span class="markdown-them-math-inline">$S$</span>, 满足 <span class="markdown-them-math-inline">$\forall L \in S, e \in L$</span>.</p><p>考虑记 <span class="markdown-them-math-inline">$T_i$</span> 表示第 <span class="markdown-them-math-inline">$i$</span> 条有可能成为答案的边属于哪些路径, <span class="markdown-them-math-inline">$f_S$</span> 表示将 <span class="markdown-them-math-inline">$S$</span> 表示的路径全部覆盖至少需要选择多少条边, 转移时枚举选择哪条边加入即可, 方程为 <span class="markdown-them-math-inline">$f_{S | T_i} = \min\{f_S + 1\}$</span>.</p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(nk + k2 ^ k)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, K = <span class="hljs-number">22</span>;<span class="hljs-keyword">int</span> T, n, k, a[K], b[K], dep[N], fa[N], f[<span class="hljs-number">1</span> &lt;&lt; K];vector &lt;<span class="hljs-keyword">int</span>&gt; E[N];map &lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">int</span>&gt; tag, M;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span> </span>&#123;    fa[u] = f, dep[u] = dep[f] + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : E[u]) <span class="hljs-keyword">if</span> (v != f) <span class="hljs-built_in">dfs</span>(v, u);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cin &gt;&gt; T; <span class="hljs-keyword">while</span> (T--) &#123;        cin &gt;&gt; n;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u, v, i = <span class="hljs-number">1</span>; i &lt; n; i++)            cin &gt;&gt; u &gt;&gt; v, E[u].<span class="hljs-built_in">push_back</span>(v), E[v].<span class="hljs-built_in">push_back</span>(u);        cin &gt;&gt; k;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;            <span class="hljs-keyword">int</span> u = a[i + <span class="hljs-number">1</span>], v = b[i + <span class="hljs-number">1</span>];            <span class="hljs-keyword">while</span> (dep[u] &gt; dep[v] &amp;&amp; fa[u] != v) u = fa[u];            <span class="hljs-keyword">while</span> (dep[v] &gt; dep[u] &amp;&amp; fa[v] != u) v = fa[v];            <span class="hljs-keyword">if</span> (fa[u] == v) &#123; tag[<span class="hljs-built_in">make_pair</span>(v, u)] |= <span class="hljs-number">1</span> &lt;&lt; i; <span class="hljs-keyword">continue</span>; &#125;            <span class="hljs-keyword">if</span> (fa[v] == u) &#123; tag[<span class="hljs-built_in">make_pair</span>(u, v)] |= <span class="hljs-number">1</span> &lt;&lt; i; <span class="hljs-keyword">continue</span>; &#125;            <span class="hljs-keyword">while</span> (fa[u] != fa[v]) u = fa[u], v = fa[v];            tag[<span class="hljs-built_in">make_pair</span>(fa[u], u)] |= <span class="hljs-number">1</span> &lt;&lt; i;            tag[<span class="hljs-built_in">make_pair</span>(fa[v], v)] |= <span class="hljs-number">1</span> &lt;&lt; i;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;            <span class="hljs-keyword">int</span> u = a[i + <span class="hljs-number">1</span>], v = b[i + <span class="hljs-number">1</span>];            <span class="hljs-keyword">while</span> (dep[u] &gt; dep[v] &amp;&amp; fa[u] != v) &#123;                <span class="hljs-keyword">if</span> (tag[<span class="hljs-built_in">make_pair</span>(fa[u], u)])                    M[<span class="hljs-built_in">make_pair</span>(fa[u], u)] |= <span class="hljs-number">1</span> &lt;&lt; i;                u = fa[u];            &#125;            <span class="hljs-keyword">while</span> (dep[v] &gt; dep[u] &amp;&amp; fa[v] != u) &#123;                <span class="hljs-keyword">if</span> (tag[<span class="hljs-built_in">make_pair</span>(fa[v], v)])                    M[<span class="hljs-built_in">make_pair</span>(fa[v], v)] |= <span class="hljs-number">1</span> &lt;&lt; i;                v = fa[v];            &#125;            <span class="hljs-keyword">if</span> (fa[u] == v) &#123; M[<span class="hljs-built_in">make_pair</span>(v, u)] |= <span class="hljs-number">1</span> &lt;&lt; i; <span class="hljs-keyword">continue</span>; &#125;            <span class="hljs-keyword">if</span> (fa[v] == u) &#123; M[<span class="hljs-built_in">make_pair</span>(u, v)] |= <span class="hljs-number">1</span> &lt;&lt; i; <span class="hljs-keyword">continue</span>; &#125;            <span class="hljs-keyword">while</span> (fa[u] != fa[v])&#123;                <span class="hljs-keyword">if</span> (tag[<span class="hljs-built_in">make_pair</span>(fa[u], u)])                    M[<span class="hljs-built_in">make_pair</span>(fa[u], u)] |= <span class="hljs-number">1</span> &lt;&lt; i;                <span class="hljs-keyword">if</span> (tag[<span class="hljs-built_in">make_pair</span>(fa[v], v)])                    M[<span class="hljs-built_in">make_pair</span>(fa[v], v)] |= <span class="hljs-number">1</span> &lt;&lt; i;                u = fa[u], v = fa[v];            &#125;            M[<span class="hljs-built_in">make_pair</span>(fa[u], u)] |= <span class="hljs-number">1</span> &lt;&lt; i;            M[<span class="hljs-built_in">make_pair</span>(fa[v], v)] |= <span class="hljs-number">1</span> &lt;&lt; i;        &#125;        <span class="hljs-keyword">int</span> lim = <span class="hljs-number">1</span> &lt;&lt; k;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> S = <span class="hljs-number">1</span>; S &lt; lim; S++) f[S] = <span class="hljs-number">1e9</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> S = <span class="hljs-number">0</span>; S &lt; lim; S++) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : M)            f[S | it.second] = <span class="hljs-built_in">min</span>(f[S | it.second], f[S] + <span class="hljs-number">1</span>);        cout &lt;&lt; f[lim - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) E[i].<span class="hljs-built_in">clear</span>();        M.<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-abc341g$](https://atcoderjp/contests/abc341/tasks/abc341_g) $\rm (^*2208)$"><a href="https://atcoder.jp/contests/abc341/tasks/abc341_g"><span class="markdown-them-math-inline">$\rm ABC341G$</span></a> <span class="markdown-them-math-inline">$\rm (^*2208)$</span></h1><p>给定长度为 <span class="markdown-them-math-inline">$n$</span> 的序列 <span class="markdown-them-math-inline">$\{a_n\}$</span>, 对每个整数 <span class="markdown-them-math-inline">$k \in [1, n]$</span>, 求 <span class="markdown-them-math-inline">$\max_{r \geqslant k} \left\{\frac{1}{r - k + 1}\sum _{i = k}^r a_i\right\}$</span>.</p><p><span class="markdown-them-math-inline">$n \leqslant 2 \times 10 ^ 5, \forall i, a_i \leqslant 10 ^ 6$</span>.</p><hr><p>考虑将平均数转化为直线的斜率, 构造平面上如下 <span class="markdown-them-math-inline">$n + 1$</span> 个点 :</p><ul><li>编号为 <span class="markdown-them-math-inline">$0$</span> 的点为 <span class="markdown-them-math-inline">$(0, 0)$</span>.</li><li>编号为 <span class="markdown-them-math-inline">$i (i \in [1, n] \cup \mathbb{Z})$</span> 的点为 <span class="markdown-them-math-inline">$(i, a_1 + a_2 + \cdots + a_i)$</span>.</li></ul><p>注意到 <span class="markdown-them-math-inline">$l \to r$</span> 的平均数即为点 <span class="markdown-them-math-inline">$l - 1$</span> 和 <span class="markdown-them-math-inline">$r$</span> 之间的斜率, 于是从右往左用单调栈维护一个上凸壳转移即可.</p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, sta[N], top;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> s[N];<span class="hljs-keyword">double</span> ans[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);        cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; s[i], s[i] += s[i - <span class="hljs-number">1</span>];    sta[++top] = n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span> &amp;&amp; (s[sta[top - <span class="hljs-number">1</span>]] - s[i]) * (sta[top] - i) &gt;= (s[sta[top]] - s[i]) * (sta[top - <span class="hljs-number">1</span>] - i)) top--;        ans[i + <span class="hljs-number">1</span>] = <span class="hljs-number">1.0</span> * (s[sta[top]] - s[i]) / (sta[top] - i);        sta[++top] = i;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">10</span>) &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-arc172e$](https://atcoderjp/contests/arc172/tasks/arc172_e) $\rm (^*2358)$"><a href="https://atcoder.jp/contests/arc172/tasks/arc172_e"><span class="markdown-them-math-inline">$\rm ARC172E$</span></a> <span class="markdown-them-math-inline">$\rm (^*2358)$</span></h1><p>有 <span class="markdown-them-math-inline">$q$</span> 次询问, 每次询问给定正整数 <span class="markdown-them-math-inline">$x$</span>, 求最小的 <span class="markdown-them-math-inline">$n$</span> 满足 <span class="markdown-them-math-inline">$n ^ n \equiv x \pmod p$</span>.</p><p><span class="markdown-them-math-inline">$q \leqslant 10 ^ 4, 1 \leqslant x &lt; p = 10 ^ 9, 2, 5 \nmid x$</span>.</p><hr><p><strong>引理</strong></p><p>设集合 <span class="markdown-them-math-inline">$U_k$</span> 为 <span class="markdown-them-math-inline">$10 ^ k (k \in \mathbb{Z^{+}})$</span> 的简化剩余系, 命题 <span class="markdown-them-math-inline">$P_k : \{n^n~|~n \in U_k\} = U_k$</span> 成立.</p><p><strong>证明</strong></p><p>对于 <span class="markdown-them-math-inline">$P_{1}$</span>, <span class="markdown-them-math-inline">$U_1 = \{1, 3, 7, 9\}$</span>. 注意到 <span class="markdown-them-math-inline">$1 ^ 1 \equiv 1, 3 ^ 3 \equiv 7, 7 ^ 7 \equiv 3, 9 ^ 9 \equiv 9 \pmod {10}$</span>, 于是 <span class="markdown-them-math-inline">$P_1$</span>​ 成立.</p><p>对于 <span class="markdown-them-math-inline">$P_2$</span>,  与 <span class="markdown-them-math-inline">$P_1$</span> 类似的, 同样注意到 <span class="markdown-them-math-inline">$n \in U_2$</span> 时, <span class="markdown-them-math-inline">$n$</span> 与 <span class="markdown-them-math-inline">$n ^ n$</span> 在模 <span class="markdown-them-math-inline">$10^2$</span> 意义下一一对应, 于是 <span class="markdown-them-math-inline">$P_2$</span> 成立.</p><p>假设 <span class="markdown-them-math-inline">$P_k (k \geqslant 2)$</span> 成立, 即 <span class="markdown-them-math-inline">$\{n^n~|~n \in U_k\} = U_k$</span>.</p><p>注意到二项式定理 : <span class="markdown-them-math-inline">$(a + b) ^ k = \sum _ {i = 0} ^ k \binom{k}{i} a ^ i b ^ {k - i}$</span>, 代入得</p><div class="markdown-them-math-block">$$(n+t \cdot10 ^ k)^{n+t \cdot10 ^ k} = \sum _ {i = 0} ^ {n+t \cdot10 ^ k} \dbinom{n+t \cdot10 ^ k}{i} (t \cdot10 ^ k) ^ i n ^ {n+t \cdot10 ^ k - i}$$</div><p>注意到 <span class="markdown-them-math-inline">$(t \cdot10 ^ k) ^ 2 \equiv 0 \pmod {10 ^ {k + 1}}$</span>, 于是</p><div class="markdown-them-math-block">$$\begin{aligned}&amp;\quad\sum _ {i = 0} ^ {n+t \cdot10 ^ k} \dbinom{n+t \cdot10 ^ k}{i} (t \cdot10 ^ k) ^ i n ^ {n+t \cdot10 ^ k - i}\\&amp;\equiv n ^ {n+t \cdot10 ^ k} + (n+t \cdot10 ^ k) \cdot n ^ {n+t \cdot10 ^ k - 1} \cdot t \cdot10 ^ k \pmod {10 ^ {k + 1}} \\&amp;\equiv n ^ {n+t \cdot10 ^ k} + n ^ {n+t \cdot10 ^ k} \cdot t \cdot10 ^ k \pmod {10 ^ {k + 1}} \\&amp;\equiv (n ^ n + n ^ n \cdot t \cdot10 ^ k) (n ^ {10 ^ k}) ^ t \pmod {10 ^ {k + 1}}\end{aligned}$$</div><p>注意到欧拉定理 : 若 <span class="markdown-them-math-inline">$a \perp m$</span>, 则 <span class="markdown-them-math-inline">$a ^ {\varphi(m)} \equiv 1 \pmod m$</span>, 其中 <span class="markdown-them-math-inline">$\varphi(x)$</span> 表示 <span class="markdown-them-math-inline">$[1, x]$</span> 中与 <span class="markdown-them-math-inline">$x$</span> 互质的整数数量.</p><p>因为 <span class="markdown-them-math-inline">$\varphi(2 ^ {k + 1}) = 2 ^ k$</span>, 且 <span class="markdown-them-math-inline">$n \perp 2 ^ {k + 1}$</span>, 故 <span class="markdown-them-math-inline">$n ^ {2 ^ k} \equiv 1 \pmod {2 ^ {k + 1}}$</span>, 进而 <span class="markdown-them-math-inline">$n ^ {10 ^ k}\equiv (n ^ {2 ^ k}) ^ {5 ^ k} \equiv 1 \pmod {2 ^ {k + 1}}$</span>. 因为 <span class="markdown-them-math-inline">$\varphi (5 ^ {k + 1}) = 4 \times 5 ^ k$</span>, 且 <span class="markdown-them-math-inline">$n \perp 5 ^ {k + 1}$</span>, 故 <span class="markdown-them-math-inline">$n ^ {4 \times 5 ^ k} \equiv 1 \pmod {5 ^ {k + 1}}$</span>, 进而 <span class="markdown-them-math-inline">$n ^ {10 ^ k} \equiv (n ^ {4 \times 5 ^ k}) ^ {2 ^ {k - 2}} \equiv 1 \pmod {5 ^ {k + 1}}$</span>. 又因为 <span class="markdown-them-math-inline">$2 ^ {k + 1} \perp 5 ^ {k + 1}$</span>, 因此 <span class="markdown-them-math-inline">$n ^ {10 ^ k} \equiv 1 \pmod {10 ^ {k + 1}}$</span>. 代入得</p><div class="markdown-them-math-block">$$(n ^ n + n ^ n \cdot t \cdot10 ^ k) (n ^ {10 ^ k}) ^ t \equiv n ^ n \cdot (t \cdot 10 ^ k + 1) \pmod {10 ^ {k + 1}}$$</div><p>于是 <span class="markdown-them-math-inline">$\{n^n~|~n \in U_{k + 1}\}$</span> 中的每个数 <span class="markdown-them-math-inline">$(n+t \cdot10 ^ k)^{n+t \cdot10 ^ k} \equiv n ^ n \cdot (t \cdot 10 ^ k + 1) \pmod {10 ^ {k + 1}}$</span>.</p><p>假设存在 <span class="markdown-them-math-inline">$t_i \not= t_j$</span>, 满足 <span class="markdown-them-math-inline">$n ^ n (t_i \cdot 10 ^ k + 1) \equiv n ^ n (t_j \cdot 10 ^ k + 1) \pmod {10 ^ {k + 1}}$</span>, 因为 <span class="markdown-them-math-inline">$n ^ n \perp 10 ^ {k + 1}$</span>, 所以 <span class="markdown-them-math-inline">$n ^ n$</span> 存在逆元(可除), 故解得 <span class="markdown-them-math-inline">$t_i = t_j$</span>, 矛盾. 于是 <span class="markdown-them-math-inline">$\forall i \not= j, n ^ n (i \cdot 10 ^ k + 1) \not\equiv n ^ n (j \cdot 10 ^ k + 1) \pmod {10 ^ {k + 1}}$</span>.</p><p>于是 <span class="markdown-them-math-inline">$\{n^n~|~n \in U_{k + 1}\}$</span> 是个不重集得证, 即 <span class="markdown-them-math-inline">$\textrm{card}\{n^n~|~n \in U_{k + 1}\} = U_{k + 1}$</span>.</p><p>因为我们构造 <span class="markdown-them-math-inline">$n ^ n$</span> 构成的集合的方式为, 令其尾数为 <span class="markdown-them-math-inline">$\{1, 3, 7, 9\}$</span> 其中之一, 不断向首位前添加 <span class="markdown-them-math-inline">$\{0, 1, \cdots, 9\}$</span>, 于是 <span class="markdown-them-math-inline">$n ^ n$</span> 的尾数一定是 <span class="markdown-them-math-inline">$\{1, 3, 7, 9\}$</span> 其中之一. 又因为 <span class="markdown-them-math-inline">$U_{k + 1}$</span> 包含了所有小于 <span class="markdown-them-math-inline">$10 ^ {k + 1}$</span> 且尾数为 <span class="markdown-them-math-inline">$\{1, 3, 7, 9\}$</span> 其中之一的正整数, 所以 <span class="markdown-them-math-inline">$\{n^n~|~n \in U_{k + 1}\} \subseteq U_{k + 1}$</span>.</p><p>综上, <span class="markdown-them-math-inline">$P_k : \{n^n~|~n \in U_{k + 1}\} = U_{k + 1}$</span> 也即 <span class="markdown-them-math-inline">$P_{k + 1}$</span> 得证.</p><p>归纳可证原命题.</p><p>回到原问题, 显然 <span class="markdown-them-math-inline">$n ^ n \to x$</span> 的映射是可以 <span class="markdown-them-math-inline">$\Theta(\log n)$</span> 确定的, 于是我们考虑一位位确定 <span class="markdown-them-math-inline">$x \to n$</span> 的映射.</p><p>对于最后两位, 可以直接枚举 <span class="markdown-them-math-inline">$n$</span> 检验 <span class="markdown-them-math-inline">$n ^ n \equiv x \pmod {100}$</span> 是否成立.</p><p>假设后 <span class="markdown-them-math-inline">$k$</span> 位已经确定, 我们有 <span class="markdown-them-math-inline">$n ^ n \equiv x \pmod {10 ^ {k}}$</span>, 且 <span class="markdown-them-math-inline">$(t \cdot 10 ^ k + n) ^ {t \cdot 10 ^ k + n} \equiv x \pmod {x ^ {k + 1}}$</span> 对且仅对一个 <span class="markdown-them-math-inline">$t \in \{0, 1, \cdots, 9\}$</span> 成立, 于是可以枚举 <span class="markdown-them-math-inline">$t$</span> 检验是否成立.</p><p>综上我们找到了一个 <span class="markdown-them-math-inline">$\Theta(k ^ 2)$</span> 单次查询 <span class="markdown-them-math-inline">$x \to n$</span> 的映射满足 <span class="markdown-them-math-inline">$n ^ n \equiv x \pmod {x ^ k}$</span> 的算法.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> q, x, n, fac[<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> mod)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (; k; k &gt;&gt;= <span class="hljs-number">1</span>, a = <span class="hljs-number">1ll</span> * a * a % mod)        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">10</span>;    cin &gt;&gt; q; <span class="hljs-keyword">while</span> (q--) &#123;        cin &gt;&gt; x;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">99</span>; i++)            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Pow</span>(i, i, <span class="hljs-number">100</span>) == x % <span class="hljs-number">100</span>) n = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>; k &lt;= <span class="hljs-number">8</span>; k++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>; t &lt;= <span class="hljs-number">9</span>; t++)                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Pow</span>(t * fac[k] + n, t * fac[k] + n, fac[k + <span class="hljs-number">1</span>]) == x % fac[k + <span class="hljs-number">1</span>]) &#123;                    n += t * fac[k]; <span class="hljs-keyword">break</span>;                &#125;        &#125;        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-cf1864f$](https://codeforcescom/contest/1864/problem/f) $\rm (^*2415)$"><a href="https://codeforces.com/contest/1864/problem/F"><span class="markdown-them-math-inline">$\rm CF1864F$</span></a> <span class="markdown-them-math-inline">$\rm (^*2415)$</span></h1><p>存在一个长度为 <span class="markdown-them-math-inline">$n$</span> 的整数序列 <span class="markdown-them-math-inline">$\{a_n\}$</span>, 有 <span class="markdown-them-math-inline">$q$</span> 个独立的查询, 每次给出 <span class="markdown-them-math-inline">$l, r$</span>.</p><p>求最小的操作次数 <span class="markdown-them-math-inline">$m$</span>, 将<strong>值</strong>在 <span class="markdown-them-math-inline">$[l, r]$</span> 内的所有数字变成 <span class="markdown-them-math-inline">$0$</span>. 单次操作被定义为 :</p><ul><li>选择一个区间 <span class="markdown-them-math-inline">$[x, y]$</span>, 满足这个区间与之前的所有区间不相交或包含或被包含于之前的某个区间.</li><li>选择一个非负整数 <span class="markdown-them-math-inline">$z$</span>, 将区间 <span class="markdown-them-math-inline">$[x, y]$</span> 中的所有数减去 <span class="markdown-them-math-inline">$z$</span>.</li></ul><p><span class="markdown-them-math-inline">$n, q \leqslant 10 ^ 6, \forall i, 1 \leqslant a_i \leqslant n$</span>.</p><hr><p>首先, 对于询问 <span class="markdown-them-math-inline">$l, r$</span>, 我们可以只考虑满足 <span class="markdown-them-math-inline">$a_i \in [l, r]$</span> 的数.</p><p>注意到我们每次必将至少一个数减成 <span class="markdown-them-math-inline">$0$</span>, 若这个数不是序列中的非 <span class="markdown-them-math-inline">$0$</span> 最小值 <span class="markdown-them-math-inline">$a_p$</span>, 那么<span class="markdown-them-math-inline">$a_p$</span>之后还是要单独再减一次, 于是取 <span class="markdown-them-math-inline">$z = a_p$</span> 是不劣的. 另外, 将 <span class="markdown-them-math-inline">$a_p$</span> 置为 <span class="markdown-them-math-inline">$0$</span> 的同时给以 <span class="markdown-them-math-inline">$0$</span> 划分的联通区间内所有的数减去 <span class="markdown-them-math-inline">$z$</span> 一定是不劣的. 减完后, 序列又以 <span class="markdown-them-math-inline">$p$</span> 为分界点被划分为两个区间分别考虑.</p><p>对于朴素的策略, 每次只删一个数, 我们发现所需操作次数即为值在 <span class="markdown-them-math-inline">$[l, r]$</span> 之间的元素数量 <span class="markdown-them-math-inline">$\ell$</span>. 而若采取上述策略, 两个数 <span class="markdown-them-math-inline">$a_i, a_j$</span> 可能同时被删, 当且仅当 <span class="markdown-them-math-inline">$\forall k \in [i + 1, j - 1], a_k \geqslant a_i = a_j~\textrm{or}~a_k &lt; l$</span>, 记满足该条件的二元组 <span class="markdown-them-math-inline">$(i, j)$</span> 数量为 <span class="markdown-them-math-inline">$\tau$</span>, 最终所需操作次数即为 <span class="markdown-them-math-inline">$\ell - \tau$</span>.</p><p>考虑将询问按 <span class="markdown-them-math-inline">$r$</span> 排序, 从小到大加入数, 那 <span class="markdown-them-math-inline">$\exists k \in [i + 1, j - 1], a_k \geqslant a_i = a_j$</span> 就不可能成立了, 于是仅需考虑 <span class="markdown-them-math-inline">$a_k &lt; l$</span>, 也即 <span class="markdown-them-math-inline">$\max_{k \in [i + 1, j - 1]} &lt; l$</span>. 这个是好维护的, 只需要一棵支持单点修改, 区间查询最大值的线段树.</p><p>而对于 <span class="markdown-them-math-inline">$l$</span> 的查询, 可以将线段树上查出的最大值插入值域树状数组, 查询小于 <span class="markdown-them-math-inline">$l$</span> 的数有多少个即为 <span class="markdown-them-math-inline">$\tau$</span>. 注意, 由于我们只想求值域在 <span class="markdown-them-math-inline">$[l, r]$</span> 中数对应的最大值小于 <span class="markdown-them-math-inline">$l$</span> 的数量, 所以要减去 <span class="markdown-them-math-inline">$[1, l - 1]$</span> 中数对应的最大值小于 <span class="markdown-them-math-inline">$l$</span> 的数量, 可以发现就是 <span class="markdown-them-math-inline">$[1, l - 1]$</span> 中数的数量减去不同的小于 <span class="markdown-them-math-inline">$l$</span> 的数的数量. 于是最终每个询问的答案就是已经插入线段树中数的数量减去当前树状数组中 <span class="markdown-them-math-inline">$1 \sim l - 1$</span> 的值, 再减去本质不同的小于 <span class="markdown-them-math-inline">$l$</span> 的数的数量.</p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, q, dif[N], ans[N];vector &lt;<span class="hljs-keyword">int</span>&gt; p[N];pair &lt;<span class="hljs-keyword">int</span>, pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; s[N];<span class="hljs-keyword">namespace</span> ST &#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls (p &lt;&lt; 1)</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>    <span class="hljs-keyword">int</span> Max[N &lt;&lt; <span class="hljs-number">2</span>], l[N &lt;&lt; <span class="hljs-number">2</span>], r[N &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Build</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;        Max[p] = <span class="hljs-number">0</span>, l[p] = L, r[p] = R;        <span class="hljs-keyword">if</span> (L == R) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> mid = (L + R) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">Build</span>(ls, L, mid), <span class="hljs-built_in">Build</span>(rs, mid + <span class="hljs-number">1</span>, R);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Modify</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l[p] == pos &amp;&amp; r[p] == pos) &#123;            Max[p] = k; <span class="hljs-keyword">return</span>;        &#125;        r[ls] &gt;= pos ? <span class="hljs-built_in">Modify</span>(ls, pos, k) : <span class="hljs-built_in">Modify</span>(rs, pos, k);        Max[p] = <span class="hljs-built_in">max</span>(Max[ls], Max[rs]);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Query</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;        <span class="hljs-keyword">if</span> (L &gt; R) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (l[p] &gt;= L &amp;&amp; r[p] &lt;= R) <span class="hljs-keyword">return</span> Max[p];        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (r[ls] &gt;= L) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">Query</span>(ls, L, R));        <span class="hljs-keyword">if</span> (l[rs] &lt;= R) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">Query</span>(rs, L, R));        <span class="hljs-keyword">return</span> res;    &#125;&#125;<span class="hljs-keyword">namespace</span> BIT &#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lowbit(x) (x &amp; (-x))</span>    <span class="hljs-keyword">int</span> t[N];    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span> </span>&#123;        <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span>) &#123; t[<span class="hljs-number">0</span>]++; <span class="hljs-keyword">return</span>; &#125;        <span class="hljs-keyword">for</span> (; pos &lt;= n; pos += <span class="hljs-built_in">lowbit</span>(pos)) t[pos]++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Query</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; pos &gt;= <span class="hljs-number">1</span>; pos -= <span class="hljs-built_in">lowbit</span>(pos)) res += t[pos];        <span class="hljs-keyword">return</span> res + t[<span class="hljs-number">0</span>];    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a, i = <span class="hljs-number">1</span>; i &lt;= n; i++)        cin &gt;&gt; a, p[a].<span class="hljs-built_in">push_back</span>(i), dif[a] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) dif[i] += dif[i - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++)        cin &gt;&gt; s[i].second.first &gt;&gt; s[i].first,        s[i].second.second = i;    <span class="hljs-built_in">sort</span>(s + <span class="hljs-number">1</span>, s + q + <span class="hljs-number">1</span>);    ST::<span class="hljs-built_in">Build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, pos = <span class="hljs-number">0</span>, k = <span class="hljs-number">1</span>; k &lt;= q; k++) &#123;        <span class="hljs-keyword">int</span> l = s[k].second.first, r = s[k].first;        <span class="hljs-keyword">while</span> (pos &lt; r) &#123;            pos++, cnt += p[pos].<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">if</span> (p[pos].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">int</span> num = p[pos].<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; num; i++)                BIT::<span class="hljs-built_in">add</span>(ST::<span class="hljs-built_in">Query</span>(<span class="hljs-number">1</span>, p[pos][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, p[pos][i] - <span class="hljs-number">1</span>));            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : p[pos]) ST::<span class="hljs-built_in">Modify</span>(<span class="hljs-number">1</span>, i, pos);        &#125;        ans[s[k].second.second] = cnt - BIT::<span class="hljs-built_in">Query</span>(l - <span class="hljs-number">1</span>) - dif[l - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-arc172d$](https://atcoderjp/contests/arc172/tasks/arc172_d) $\rm (^* 2936)$"><a href="https://atcoder.jp/contests/arc172/tasks/arc172_d"><span class="markdown-them-math-inline">$\rm ARC172D$</span></a> <span class="markdown-them-math-inline">$\rm (^* 2936)$</span></h1><p>给定 <span class="markdown-them-math-inline">$n$</span> 和 <span class="markdown-them-math-inline">$\frac{n(n - 1)}{2}$</span> 组条件 <span class="markdown-them-math-inline">$(a_i, b_i)$</span>, 要求在 <span class="markdown-them-math-inline">$n$</span> 维空间中放置 <span class="markdown-them-math-inline">$n$</span> 个坐标在 <span class="markdown-them-math-inline">$[0, 10 ^ 8]$</span> 内的整点, 满足 <span class="markdown-them-math-inline">$\textrm{dis}(p_{a_i}, p_{b_i})$</span> 按照给出条件的顺序从小到大排序.</p><p><span class="markdown-them-math-inline">$3 \leqslant n \leqslant 20$</span>.</p><hr><p>考虑先构造任意两点之间距离相等, 再细微调整使其满足条件.</p><p>不妨令</p><div class="markdown-them-math-block">$$\begin{pmatrix}p_1 = [1, 0, 0, \cdots, 0] \\p_2 = [0, 1, 0, \cdots, 0] \\\cdots \\p_n = [0, 0, 0, \cdots, 1] \\\end{pmatrix}$$</div><p>这样就能使任意两点之间距离为 <span class="markdown-them-math-inline">$\sqrt2$</span>, 然后给每个点的每个维度加上一个极小量</p><div class="markdown-them-math-block">$$\begin{pmatrix}p_1 = [1 + \varepsilon_{1, 1},\varepsilon_{1, 2} , \varepsilon_{1, 3}, \cdots, \varepsilon_{1, n}] \\p_2 = [\varepsilon_{2, 1}, 1 + \varepsilon_{2, 2},\varepsilon_{2, 3} , \cdots, \varepsilon_{3, 3}] \\\cdots \\p_n = [\varepsilon_{n, 1}, \varepsilon_{n, 2},\varepsilon_{n, 3} , \cdots, 1 + \varepsilon_{n, n}] \\\end{pmatrix}$$</div><p>此时两点距离为</p><div class="markdown-them-math-block">$$\textrm{dis} ^ 2(p_i, p_j) = \sum_{k \not= i, j} (\varepsilon_{i, k} - \varepsilon_{j, k}) ^ 2 + (1 + \varepsilon_{i, i} - \varepsilon_{j, i}) ^ 2 + (\varepsilon_{i, j} - 1 - \varepsilon_{j, j}) ^ 2$$</div><p>注意到二阶小量对构造结果的影响很小, 于是消去, 得</p><div class="markdown-them-math-block">$$\textrm{dis}(p_i, p_j) = \sqrt{1 + \varepsilon_{i, i} + \varepsilon_{j, j} - \varepsilon_{i, j} - \varepsilon_{j, i}} \cdot \sqrt2$$</div><p>我们不妨设 <span class="markdown-them-math-inline">$i &lt; j$</span> 且 <span class="markdown-them-math-inline">$\varepsilon_{i, i}, \varepsilon_{j, j}, \varepsilon_{j, i} = 0$</span>, 则原命题转化为</p><div class="markdown-them-math-block">$$\sqrt{1 - \varepsilon_{a_1, b_1}} &lt; \sqrt{1 - \varepsilon_{a_2, b_2}} &lt; \cdots &lt; \sqrt{1 - \varepsilon_{a_n, b_n}}$$</div><p>将坐标等比例放大 <span class="markdown-them-math-inline">$L$</span> 倍, 可设 <span class="markdown-them-math-inline">$\varepsilon_{a_i, b_i}$</span> 为 <span class="markdown-them-math-inline">$-i$</span>, 考虑到坐标不能为负数, 于是再将所有点的坐标加上 <span class="markdown-them-math-inline">$l$</span>.</p><p>此题可取 <span class="markdown-them-math-inline">$L = 9 \times 10 ^ 7, l = \frac{n(n - 1)}{2}$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">22</span>, L = <span class="hljs-number">9e7</span>;<span class="hljs-keyword">int</span> n, p[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)            p[i][j] = n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + L * (i == j);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a, b, i = <span class="hljs-number">1</span>; i &lt;= n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i++)        cin &gt;&gt; a &gt;&gt; b, p[a][b] -= i;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>, p[i][j], <span class="hljs-string">&quot; \n&quot;</span>[j == n]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-cf1905e$](https://codeforcescom/contest/1905/problem/e) $\rm (^* 2484)$"><a href="https://codeforces.com/contest/1905/problem/E"><span class="markdown-them-math-inline">$\rm CF1905E$</span></a> <span class="markdown-them-math-inline">$\rm (^* 2484)$</span></h1><p>递归定义长度为 <span class="markdown-them-math-inline">$n$</span> 的线段树. 根节点为 <span class="markdown-them-math-inline">$1$</span>, 代表区间 <span class="markdown-them-math-inline">$[1, n]$</span>. 若一个结点 <span class="markdown-them-math-inline">$p$</span> 代表的区间为 <span class="markdown-them-math-inline">$[l, r]$</span>, 那么当且仅当 <span class="markdown-them-math-inline">$l \not= r$</span> 时它存在两个子节点 <span class="markdown-them-math-inline">$2p$</span> 和 <span class="markdown-them-math-inline">$2p + 1$</span>, 分别代表区间 <span class="markdown-them-math-inline">$[l, \lceil\frac{l + r}{2}\rceil]$</span> 和 <span class="markdown-them-math-inline">$[\lceil\frac{l + r}{2}\rceil + 1, r]$</span>.</p><p>共 <span class="markdown-them-math-inline">$T$</span> 组询问, 每次给定 <span class="markdown-them-math-inline">$n$</span>, 求长度为 <span class="markdown-them-math-inline">$n$</span> 的线段树对应的 <span class="markdown-them-math-inline">$\sum \textrm{LCA}(S)$</span>, 其中 <span class="markdown-them-math-inline">$S$</span> 表示任意一个叶子节点的非空集合, <span class="markdown-them-math-inline">$\textrm{LCA}(S)$</span> 表示 <span class="markdown-them-math-inline">$S$</span> 中所有结点的最近公共祖先的编号. 答案对 <span class="markdown-them-math-inline">$998244353$</span> 取模.</p><p><span class="markdown-them-math-inline">$T \leqslant 10 ^ 3, 2 \leqslant n \leqslant 10 ^ {18}$</span>.</p><hr><p>首先考察结点 <span class="markdown-them-math-inline">$(p, l, r)$</span> 的贡献, 其作为最近公共祖先当且仅当 <span class="markdown-them-math-inline">$2p$</span> 和 <span class="markdown-them-math-inline">$2p + 1$</span> 内均至少存在一个结点被选择, 且 <span class="markdown-them-math-inline">$[l, r]$</span> 之外没有结点被选择. 故其贡献为 :</p><div class="markdown-them-math-block">$$p(2 ^ {\lceil\frac{l + r}{2}\rceil - l + 1} - 1)(2 ^ {r - \lceil\frac{l + r}{2}\rceil} - 1)$$</div><p>注意到线段树每层最多存在两种长度的区间, 且相同长度的区间被算进贡献的次数是相同的, 于是考虑合并计算. 递归时维护当前长度 <span class="markdown-them-math-inline">$l$</span> 对应的结点编号和 <span class="markdown-them-math-inline">$s$</span>, 数量 <span class="markdown-them-math-inline">$c$</span> 即可, 用  <code>map</code> 存储.</p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(T\log ^ 2 n)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> T, ans;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;set &lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; S;map &lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>&gt; s, c;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Build</span> <span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> l)</span> </span>&#123;    S.<span class="hljs-built_in">insert</span>(l);    <span class="hljs-keyword">if</span> (l == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (S.<span class="hljs-built_in">find</span>((l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) == S.<span class="hljs-built_in">end</span>()) <span class="hljs-built_in">Build</span>((l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (S.<span class="hljs-built_in">find</span>(l / <span class="hljs-number">2</span>) == S.<span class="hljs-built_in">end</span>()) <span class="hljs-built_in">Build</span>(l / <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (; k; k &gt;&gt;= <span class="hljs-number">1</span>, a = <span class="hljs-number">1ll</span> * a * a % mod)        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; T; <span class="hljs-keyword">while</span> (T--) &#123;        cin &gt;&gt; n;        S.<span class="hljs-built_in">clear</span>(), <span class="hljs-built_in">Build</span>(n);        s.<span class="hljs-built_in">clear</span>(), c.<span class="hljs-built_in">clear</span>(), ans = <span class="hljs-number">0</span>, s[n] = c[n] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = S.<span class="hljs-built_in">rbegin</span>(); it != S.<span class="hljs-built_in">rend</span>(); it++) &#123;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> l = *it, lx = (l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, ly = l / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (l == <span class="hljs-number">1</span>) ans = (ans + s[l]) % mod;            <span class="hljs-keyword">else</span> &#123;                ans = (ans + <span class="hljs-number">1ll</span> * s[l] * (<span class="hljs-built_in">Pow</span>(<span class="hljs-number">2</span>, lx) - <span class="hljs-number">1</span>) % mod * (<span class="hljs-built_in">Pow</span>(<span class="hljs-number">2</span>, ly) - <span class="hljs-number">1</span>)) % mod;                s[lx] = (s[lx] + <span class="hljs-number">2ll</span> * s[l]) % mod, c[lx] = (c[lx] + c[l]) % mod;                s[ly] = (s[ly] + <span class="hljs-number">2ll</span> * s[l] + c[l]) % mod, c[ly] = (c[ly] + c[l]) % mod;            &#125;        &#125;        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-cf1923e$](https://codeforcescom/contest/1923/problem/e) $\rm (^* 2044)$"><a href="https://codeforces.com/contest/1923/problem/E"><span class="markdown-them-math-inline">$\rm CF1923E$</span></a> <span class="markdown-them-math-inline">$\rm (^* 2044)$</span></h1><p>给定一棵 <span class="markdown-them-math-inline">$n$</span> 个结点的树, 每个结点有一个 <span class="markdown-them-math-inline">$[1, n]$</span> 中的颜色, 求满足以下条件的路径的数量 :</p><ul><li>至少由 <span class="markdown-them-math-inline">$2$</span> 个结点组成.</li><li>路径的起点与终点颜色相同.</li><li>路径上起点和终点以外的点颜色与起点不同.</li></ul><p><span class="markdown-them-math-inline">$n \leqslant 2 \times 10 ^ 5$</span>.</p><hr><p>此处给出一个优于官方 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span> 做法的线性做法.</p><p>考虑按 <span class="markdown-them-math-inline">$\rm dfs$</span> 序枚举树上的每个结点, 统计当前结点 <span class="markdown-them-math-inline">$u$</span> 能和前面结点构成的合法路径 <span class="markdown-them-math-inline">$(u, v)$</span> 的数量. 可以发现若设 <span class="markdown-them-math-inline">$f$</span> 为 <span class="markdown-them-math-inline">$u$</span> 的祖先中最近的与 <span class="markdown-them-math-inline">$u$</span> 颜色相同的结点, 则合法的 <span class="markdown-them-math-inline">$v$</span> 可以用以下方式刻画 :</p><ul><li>若 <span class="markdown-them-math-inline">$f$</span> 存在则将其计入答案, 否则设 <span class="markdown-them-math-inline">$f = fa(1) = 0$</span>, 不计入答案.</li><li>遍历 <span class="markdown-them-math-inline">$u$</span> 至 <span class="markdown-them-math-inline">$f$</span> 路径上的每个结点 <span class="markdown-them-math-inline">$r$</span> (不含 <span class="markdown-them-math-inline">$u, f$</span>), 从 <span class="markdown-them-math-inline">$r$</span> 开始向其子树(不含包括 <span class="markdown-them-math-inline">$u$</span> 的这棵)中遍历, 遇到与 <span class="markdown-them-math-inline">$u$</span>​ 颜色相同的结点则停下, 并将其计入答案.</li></ul><p>设 <span class="markdown-them-math-inline">$c_i$</span> 表示若 <span class="markdown-them-math-inline">$u$</span> 的颜色为 <span class="markdown-them-math-inline">$i$</span>, 能被计入答案的结点数量.</p><ul><li>因为以 <span class="markdown-them-math-inline">$u$</span> 为根的子树中所有想走出来的合法路径都会被 <span class="markdown-them-math-inline">$u$</span> 拦住, 所以进入子树时要将 <span class="markdown-them-math-inline">$c_i$</span> 设为 <span class="markdown-them-math-inline">$1$</span>.</li><li>因为出以 <span class="markdown-them-math-inline">$u$</span> 为根的子树时原本的答案会还原, 且 <span class="markdown-them-math-inline">$u$</span> 也是合法路径的端点, 所以出子树时要将 <span class="markdown-them-math-inline">$c_i$</span> 加 <span class="markdown-them-math-inline">$1$</span>.</li></ul><p>使用这种策略遍历一遍整棵树即可算出答案.</p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> T, n, col[N], cf[N], c[N];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans;vector &lt;<span class="hljs-keyword">int</span>&gt; E[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;    ans += c[col[u]];    <span class="hljs-keyword">int</span> mark = c[col[u]];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : E[u]) <span class="hljs-keyword">if</span> (v != fa) c[col[u]] = <span class="hljs-number">1</span>, <span class="hljs-built_in">dfs</span>(v, u);    c[col[u]] = mark + <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cin &gt;&gt; T; <span class="hljs-keyword">while</span> (T--) &#123;        cin &gt;&gt; n;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; col[i];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u, v, i = <span class="hljs-number">1</span>; i &lt; n; i++)            cin &gt;&gt; u &gt;&gt; v,            E[u].<span class="hljs-built_in">push_back</span>(v), E[v].<span class="hljs-built_in">push_back</span>(u);        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)            E[i].<span class="hljs-built_in">clear</span>(), cf[i] = c[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-cf1918f$](https://codeforcescom/contest/1918/problem/f) $\rm (^* 2696)$"><a href="https://codeforces.com/contest/1918/problem/F"><span class="markdown-them-math-inline">$\rm CF1918F$</span></a> <span class="markdown-them-math-inline">$\rm (^* 2696)$</span></h1><p>给定一颗 <span class="markdown-them-math-inline">$n$</span> 个结点的树, 从 <span class="markdown-them-math-inline">$1$</span> 开始在树上行走, 求走到过所有结点的最小步数.</p><ul><li>操作 <span class="markdown-them-math-inline">$1$</span> : 移动到相邻的结点, 花费 <span class="markdown-them-math-inline">$1$</span> 步.</li><li>操作 <span class="markdown-them-math-inline">$2$</span> : 移动到 <span class="markdown-them-math-inline">$1$</span> 号结点, 无花费, 但操作 <span class="markdown-them-math-inline">$2$</span> 最多进行 <span class="markdown-them-math-inline">$k$</span> 次.</li></ul><p><span class="markdown-them-math-inline">$2 \leqslant n \leqslant 2 \times 10 ^ 5, 0 \leqslant k \leqslant 10 ^ 9$</span>.</p><hr><p>可以发现如下性质 :</p><ul><li>操作 <span class="markdown-them-math-inline">$2$</span> 只会在叶子结点进行.</li><li>题目等效于要求最后需要回到 <span class="markdown-them-math-inline">$1$</span> 号结点, 但操作 <span class="markdown-them-math-inline">$2$</span> 可以进行 <span class="markdown-them-math-inline">$k + 1$</span> 次.</li><li>如果只使用操作 <span class="markdown-them-math-inline">$1$</span>, 则每条边会经过恰好 <span class="markdown-them-math-inline">$2$</span> 次, 总共需要 <span class="markdown-them-math-inline">$2(n - 1)$</span> 步.</li></ul><p>考虑求操作 <span class="markdown-them-math-inline">$2$</span> 最多能节省多少步数. 假设遍历顺序已经确定下来了, 那对于其中一对访问时间相邻的叶子结点 <span class="markdown-them-math-inline">$(u, v)$</span> (相邻被定义为 <span class="markdown-them-math-inline">$u \to v$</span> 的路径上不存在其它叶子结点), 如果在 <span class="markdown-them-math-inline">$u$</span> 处使用操作 <span class="markdown-them-math-inline">$2$</span>, 设 <span class="markdown-them-math-inline">$f = \textrm{LCA}(u, v)$</span>, 能够节省的步数为 <span class="markdown-them-math-inline">$\textrm{dis}(u, v) - \textrm{dis}(1, v)$</span>, 可转化为 <span class="markdown-them-math-inline">$\textrm{dis}(u, f) - \textrm{dep}(f)$</span>.</p><p>考察每个非叶子结点 <span class="markdown-them-math-inline">$f$</span>, 在以 <span class="markdown-them-math-inline">$f$</span> 为根的子树中如果存在某个叶节点使用了操作 <span class="markdown-them-math-inline">$2$</span>, 考虑到要最大化 <span class="markdown-them-math-inline">$\textrm{dis}(u, f) - \textrm{dep}(f)$</span>, 那么一定是深度最大的结点, 且它是最后一个被遍历到的. 于是对 <span class="markdown-them-math-inline">$f$</span> 的所有子节点 <span class="markdown-them-math-inline">$u$</span> 按以 <span class="markdown-them-math-inline">$u$</span> 为根的子树深度从小到大排序, 这样得出的叶节点访问顺序也即能最小化总步数的访问顺序.</p><p>注意到每个叶节点的贡献是独立的, 于是计算最大的 <span class="markdown-them-math-inline">$\sum \textrm{dis}(u, f) - \textrm{dep}(f)$</span> 只需要求出前 <span class="markdown-them-math-inline">$k$</span> 大即可.</p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, k, fa[N], dep[N], siz[N], son[N], len[N], top[N], ans;vector &lt;<span class="hljs-keyword">int</span>&gt; E[N], leaf, val;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span> </span>&#123;    dep[u] = dep[f] + <span class="hljs-number">1</span>, siz[u] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : E[u]) <span class="hljs-built_in">dfs1</span>(v, u),        siz[u] += siz[v], len[u] = <span class="hljs-built_in">max</span>(len[u], len[v] + <span class="hljs-number">1</span>),        son[u] = siz[v] &gt; siz[son[u]] ? v : son[u];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> t)</span> </span>&#123;    top[u] = t;    <span class="hljs-keyword">if</span> (son[u]) <span class="hljs-built_in">dfs2</span>(son[u], t);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : E[u]) <span class="hljs-keyword">if</span> (v != son[u]) <span class="hljs-built_in">dfs2</span>(v, v);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;    <span class="hljs-keyword">while</span> (top[u] != top[v]) &#123;        <span class="hljs-keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) <span class="hljs-built_in">swap</span>(u, v);        u = fa[top[u]];    &#125;    <span class="hljs-keyword">return</span> dep[u] &lt; dep[v] ? u : v;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dis</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;    <span class="hljs-keyword">return</span> dep[u] + dep[v] - <span class="hljs-number">2</span> * dep[<span class="hljs-built_in">LCA</span>(u, v)];&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> len[a]  &lt; len[b];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs3</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;    <span class="hljs-built_in">sort</span>(E[u].<span class="hljs-built_in">begin</span>(), E[u].<span class="hljs-built_in">end</span>(), cmp);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : E[u]) <span class="hljs-built_in">dfs3</span>(v);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs4</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;    <span class="hljs-keyword">if</span> (E[u].<span class="hljs-built_in">empty</span>()) leaf.<span class="hljs-built_in">push_back</span>(u);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : E[u]) <span class="hljs-built_in">dfs4</span>(v);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;fa[i]), E[fa[i]].<span class="hljs-built_in">push_back</span>(i);    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">dfs3</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">dfs4</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> num = leaf.<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)        <span class="hljs-keyword">if</span> (i &lt; num - <span class="hljs-number">1</span>) val.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">dis</span>(leaf[i], leaf[i + <span class="hljs-number">1</span>]) - <span class="hljs-built_in">dis</span>(<span class="hljs-number">1</span>, leaf[i + <span class="hljs-number">1</span>]));        <span class="hljs-keyword">else</span> val.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">dis</span>(<span class="hljs-number">1</span>, leaf[i]));        <span class="hljs-built_in">sort</span>(val.<span class="hljs-built_in">begin</span>(), val.<span class="hljs-built_in">end</span>(), greater &lt;<span class="hljs-keyword">int</span>&gt; ());    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= k &amp;&amp; i &lt; num; i++)        <span class="hljs-keyword">if</span> (val[i] &gt; <span class="hljs-number">0</span>) ans += val[i];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-number">2</span> * (n - <span class="hljs-number">1</span>) - ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-arc173b$](https://atcoderjp/contests/arc173/tasks/arc173_b) $\rm (^* 1594^+)$"><a href="https://atcoder.jp/contests/arc173/tasks/arc173_b"><span class="markdown-them-math-inline">$\rm ARC173B$</span></a> <span class="markdown-them-math-inline">$\rm (^* 1594^+)$</span></h1><p>给定平面上的 <span class="markdown-them-math-inline">$n$</span> 个整点, 第 <span class="markdown-them-math-inline">$i$</span> 个点坐标为 <span class="markdown-them-math-inline">$(x_i, y_i)$</span>.</p><p>问最多能用这些顶点构建多少个非退化三角形(每个点只能用一次).</p><p><span class="markdown-them-math-inline">$3 \leqslant n \leqslant 300, |x_i|, |y_i| \leqslant 10 ^ 9.$</span></p><hr><p>设 <span class="markdown-them-math-inline">$l$</span> 为平面上穿过点数最多的直线, 其上点数为 <span class="markdown-them-math-inline">$m$</span>.</p><ul><li>若 <span class="markdown-them-math-inline">$m \geqslant n - \lfloor\frac{n}{3}\rfloor + 1$</span>, 那么答案为 <span class="markdown-them-math-inline">$n - m$</span>, 即每从 <span class="markdown-them-math-inline">$l$</span> 外取一个点, 从 <span class="markdown-them-math-inline">$l$</span> 内取两个点构成一个三角形.</li><li>若 <span class="markdown-them-math-inline">$m \leqslant n - \lfloor\frac{n}{3}\rfloor$</span>, 那么可以取到答案上界 <span class="markdown-them-math-inline">$\lfloor\frac{n}{3}\rfloor$</span>.</li></ul><p>下归纳证明第二种情况的正确性, 假设对小于 <span class="markdown-them-math-inline">$n$</span> 个点的情况该结论均正确 :</p><p>尝试从 <span class="markdown-them-math-inline">$n$</span> 个点中选取 <span class="markdown-them-math-inline">$3$</span> 个先构成一个三角形, 钦点其中两个点从 <span class="markdown-them-math-inline">$l$</span> 上选, 则 <span class="markdown-them-math-inline">$l$</span> 上现在的点数 <span class="markdown-them-math-inline">$m' = m - 2$</span>, 由 <span class="markdown-them-math-inline">$m \leqslant n - \lfloor\frac{n}{3}\rfloor$</span> 得 <span class="markdown-them-math-inline">$m' = m - 2 \leqslant n - \lfloor\frac{n}{3}\rfloor - 2 = n - 3 - \lfloor\frac{n - 3}{3}\rfloor$</span>, 可以取到 <span class="markdown-them-math-inline">$n - 3$</span> 个点的答案上界 <span class="markdown-them-math-inline">$\lfloor\frac{n - 3}{3}\rfloor$</span>, 进而 <span class="markdown-them-math-inline">$n$</span> 个点的第二种情况可以取到 <span class="markdown-them-math-inline">$n$</span> 个点的答案上界 <span class="markdown-them-math-inline">$\lfloor\frac{n}{3}\rfloor$</span> 得证. 归纳得原命题得证.</p><p>有这个结论, 则可以直接枚举两个点, 设过它们的直线为 <span class="markdown-them-math-inline">$l$</span> 并计算 <span class="markdown-them-math-inline">$m$</span>, 时间复杂度 <span class="markdown-them-math-inline">$\Theta(n ^ 3)$</span>, 可以通过原问题.</p><p>注意到若答案不为 <span class="markdown-them-math-inline">$\lfloor\frac{n}{3}\rfloor$</span> 则 <span class="markdown-them-math-inline">$l$</span> 上的点数占总点数的 <span class="markdown-them-math-inline">$\frac{2}{3}$</span> 以上, 用类摩尔投票法的方式来统计显然是一个更聪明的做法. 在一个栈中保存我们认为在 <span class="markdown-them-math-inline">$l$</span> 上的点, 若栈大小小于 <span class="markdown-them-math-inline">$2$</span> 则将当前点加入栈, 否则判断其跟栈内元素是否在同一条直线上. 若是, 则将其入栈, 否则踢出栈内一个元素. 注意到 <span class="markdown-them-math-inline">$l$</span> 上的元素为绝对众数, 所以最终栈内留下来的元素一定是 <span class="markdown-them-math-inline">$l$</span> 上的元素(若没留下来超过 <span class="markdown-them-math-inline">$1$</span> 个元素, 则说明栈中元素代表的 <span class="markdown-them-math-inline">$l$</span> 上的点数并非绝对众数, 答案为 <span class="markdown-them-math-inline">$\lfloor\frac{n}{3}\rfloor$</span>). 特别的, 若当前栈中只剩两个元素, 则需要全部踢出, 否则一个不在 <span class="markdown-them-math-inline">$l$</span> 上的点可能永远留在栈中. 注意到所求 <span class="markdown-them-math-inline">$l$</span> 上的点数大于总点数的 <span class="markdown-them-math-inline">$\frac{2}{3}$</span>​, 所以哪怕每次都踢出两个元素也不会影响投票法的正确性.</p><p>最后, 栈中剩下元素代表的 <span class="markdown-them-math-inline">$l$</span> 即为所求, 枚举判断一下有多少个点在 <span class="markdown-them-math-inline">$l$</span> 上即可.</p><p>时间复杂度被优化到 <span class="markdown-them-math-inline">$\Theta(n)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, x[N], y[N], sta[N], top;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">return</span> (<span class="hljs-number">1ll</span> * x[j] * y[k] - <span class="hljs-number">1ll</span> * y[j] * x[k])         - (<span class="hljs-number">1ll</span> * x[i] * y[k] - <span class="hljs-number">1ll</span> * y[i] * x[k])         + (<span class="hljs-number">1ll</span> * x[i] * y[j] - <span class="hljs-number">1ll</span> * y[i] * x[j]) == <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; x[i] &gt;&gt; y[i];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">if</span> (top &lt;= <span class="hljs-number">1</span>) sta[++top] = i;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(sta[<span class="hljs-number">1</span>], sta[<span class="hljs-number">2</span>], i)) sta[++top] = i;        <span class="hljs-keyword">else</span> top -= <span class="hljs-number">1</span> + (top == <span class="hljs-number">2</span>);    &#125;    <span class="hljs-keyword">if</span> (top &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n / <span class="hljs-number">3</span>), <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> m = <span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        <span class="hljs-keyword">if</span> (i != sta[<span class="hljs-number">1</span>] &amp;&amp; i != sta[<span class="hljs-number">2</span>]) m += <span class="hljs-built_in">check</span>(sta[<span class="hljs-number">1</span>], sta[<span class="hljs-number">2</span>], i);    (m &lt;= n - n / <span class="hljs-number">3</span>) ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n / <span class="hljs-number">3</span>) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n - m);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-cf1946d$](https://codeforcescom/contest/1946/problem/d) $\rm (^* 2006)$"><a href="https://codeforces.com/contest/1946/problem/D"><span class="markdown-them-math-inline">$\rm CF1946D$</span></a> <span class="markdown-them-math-inline">$\rm (^* 2006)$</span></h1><p>有一个长度为 <span class="markdown-them-math-inline">$n$</span> 的数列 <span class="markdown-them-math-inline">$\{a_n\}$</span> 和一个数 <span class="markdown-them-math-inline">$x$</span>, 请找到最大的数<span class="markdown-them-math-inline">$k$</span>, 使得可以选择一些数字对 <span class="markdown-them-math-inline">$[l_1, r_1]$</span>, <span class="markdown-them-math-inline">$[l_2, r_2]$</span>, <span class="markdown-them-math-inline">$\cdots$</span>,  <span class="markdown-them-math-inline">$[l_k, r_k]$</span> 满足以下条件 :</p><ul><li><span class="markdown-them-math-inline">$l_1 = 1$</span>, <span class="markdown-them-math-inline">$r_k = n$</span>.</li><li>对于所有 <span class="markdown-them-math-inline">$i$</span> 从 <span class="markdown-them-math-inline">$1$</span> 到 <span class="markdown-them-math-inline">$k$</span> , <span class="markdown-them-math-inline">$l_i \leqslant r_i$</span>.</li><li>对于所有 <span class="markdown-them-math-inline">$i$</span> 从 <span class="markdown-them-math-inline">$1$</span> 到 <span class="markdown-them-math-inline">$k - 1$</span>, <span class="markdown-them-math-inline">$r_i + 1 = l_{i + 1}$</span>.</li><li><span class="markdown-them-math-inline">$(a_{l_1} \oplus a_{l_1 + 1} \oplus \ldots \oplus a_{r_1}) | (a_{l_2} \oplus a_{l_2 + 1} \oplus \ldots \oplus a_{r_2}) | \ldots | (a_{l_k} \oplus a_{l_k + 1} \oplus \ldots \oplus a_{r_k}) \leqslant x$</span>.</li></ul><p>如果不存在这样的 <span class="markdown-them-math-inline">$k$</span>, 则输出 <span class="markdown-them-math-inline">$-1$</span>.</p><hr><p>设 <span class="markdown-them-math-inline">$s_i = \oplus_{j = 1}^i a_j$</span>, 则原问题被转化为 <span class="markdown-them-math-inline">$s_{r_1}|(s_{r_2}\oplus s_{r_1})|\cdots|(s_{r_k} \oplus s_{r_{k - 1}}) \leqslant x$</span>.</p><p>注意到 <span class="markdown-them-math-inline">$x | x \oplus y = x | y$</span>, 于是问题被转化为从 <span class="markdown-them-math-inline">$\{s_n\}$</span> 中选尽可能多的数, 使其或和不超过 <span class="markdown-them-math-inline">$x$</span>.</p><p>这就变成了经典问题, 枚举 <span class="markdown-them-math-inline">$x$</span> 最高的为 <span class="markdown-them-math-inline">$1$</span> 且或和中该位为 <span class="markdown-them-math-inline">$0$</span> 的是哪一位, 然后进行贪心即可.</p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> T, n, x, a[N], ans; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> ((a[n] | y) != y) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)        <span class="hljs-keyword">if</span> ((a[i] | y) == y) res++;    <span class="hljs-keyword">return</span> res;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T); <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;x);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]), a[i] ^= a[i - <span class="hljs-number">1</span>];         ans = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">30</span>; k &gt;= <span class="hljs-number">0</span>; k--)            <span class="hljs-keyword">if</span> ((x &gt;&gt; k) &amp; <span class="hljs-number">1</span>) ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">calc</span>(((x &gt;&gt; (k + <span class="hljs-number">1</span>)) &lt;&lt; (k + <span class="hljs-number">1</span>)) + (<span class="hljs-number">1</span> &lt;&lt; k) - <span class="hljs-number">1</span>));        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">calc</span>(x));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-cf1944f2$](https://codeforcescom/contest/1944/problem/f2) $\rm (^* 2828)$"><a href="https://codeforces.com/contest/1944/problem/F2"><span class="markdown-them-math-inline">$\rm CF1944F2$</span></a> <span class="markdown-them-math-inline">$\rm (^* 2828)$</span></h1><p>如果一个长度为 <span class="markdown-them-math-inline">$m$</span> 的数列 <span class="markdown-them-math-inline">$\{b_{m}\}$</span> 能通过若干次操作变成全 <span class="markdown-them-math-inline">$0$</span> 序列, 则该序列为合法的. 操作被定义为, 选择 <span class="markdown-them-math-inline">$1 \leqslant l &lt; r \leqslant m$</span>, 将所有满足 <span class="markdown-them-math-inline">$i \in [l, r]$</span> 的 <span class="markdown-them-math-inline">$b_i$</span> 减 <span class="markdown-them-math-inline">$1$</span>.</p><p>给定 <span class="markdown-them-math-inline">$n, k, p$</span>, 求有多少个长度为 <span class="markdown-them-math-inline">$n$</span> 的数列 <span class="markdown-them-math-inline">$\{a_n\}$</span> 是合法的, 且满足 <span class="markdown-them-math-inline">$\forall i, 0 \leqslant a_i \leqslant k$</span>, 答案对 <span class="markdown-them-math-inline">$p$</span> 取模.</p><p><span class="markdown-them-math-inline">$3 \leqslant n \leqslant 3000, 1 \leqslant k \leqslant n, 10^8 &lt; p &lt; 10^9, p \in  \mathbb{P}$</span>.</p><hr><p>首先我们考虑<span class="markdown-them-math-inline">$\{a_n\}$</span> 合法的充要条件是什么, 容易想到为 <span class="markdown-them-math-inline">$\forall i, a_i \leqslant a_{i - 1} + a_{i + 1}$</span>.</p><p>注意到 <span class="markdown-them-math-inline">$a_i &gt; a_{i - 1} + a_{i + 1}$</span> 和 <span class="markdown-them-math-inline">$a_{i + 1} &gt; a_i + a_{i + 2}$</span> 不可能同时成立, 于是同时计算合法和不合法的方案数只需要记录前 <span class="markdown-them-math-inline">$1$</span> 个元素. 具体来说, 设 <span class="markdown-them-math-inline">$f_{i, j}$</span> 为考虑到 <span class="markdown-them-math-inline">$a_i$</span>, 且 <span class="markdown-them-math-inline">$a_i = j$</span> 的合法方案数, 设 <span class="markdown-them-math-inline">$g_i,j$</span> 为考虑到 <span class="markdown-them-math-inline">$a_i$</span>, 有且仅有 <span class="markdown-them-math-inline">$a_i = j$</span> 这一位不合法的方案数. 那么有转移式 :</p><div class="markdown-them-math-block">$$g_{i, j} = \sum_{t = 0}^k f_{i - 2}, t \times \max\{k - j - t, 0\}, f_{i, j} = \sum_{t = 0}^k f_{i - 1, t} - g_{i, j}$$</div><p>前缀和优化后时间复杂度 <span class="markdown-them-math-inline">$\Theta(n^2)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e3</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> T, n, k, p, f[N][N], g[N][N], sum[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    cin &gt;&gt; T; <span class="hljs-keyword">while</span> (T--) &#123;        cin &gt;&gt; n &gt;&gt; k &gt;&gt; p;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sigma, i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;            sum[<span class="hljs-number">0</span>] = f[i - <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], sigma = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++)                sum[j] = (sum[j - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">2</span>][j]) % p,                sigma = (sigma + f[i - <span class="hljs-number">1</span>][j]) % p;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k; j &gt;= <span class="hljs-number">0</span>; j--) &#123;                g[i][j] = (g[i][j + <span class="hljs-number">1</span>] + sum[k - <span class="hljs-number">1</span> - j]) % p,                f[i][j] = (sigma - g[i][j] + p) % p;            &#125;        &#125;        cout &lt;&lt; f[n + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= k; j++)                f[i][j] = g[i][j] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="[$\rm-cf1944d$](https://codeforcescom/contest/1944/problem/d) $\rm (^* 2072)$"><a href="https://codeforces.com/contest/1944/problem/D"><span class="markdown-them-math-inline">$\rm CF1944D$</span></a> <span class="markdown-them-math-inline">$\rm (^* 2072)$</span></h1><p>定义一个字符串为 <span class="markdown-them-math-inline">$\textrm {k-good}$</span> 的, 当且仅当其存在至少一个长度为 <span class="markdown-them-math-inline">$k$</span> 的子串不是回文的.</p><p>给定长度为 <span class="markdown-them-math-inline">$n$</span> 的字符串 <span class="markdown-them-math-inline">$s$</span>, 共 <span class="markdown-them-math-inline">$q$</span> 次询问, 每次给定 <span class="markdown-them-math-inline">$l, r$</span>, 求 <span class="markdown-them-math-inline">$\sum_k k[s_{l \sim r}~\textrm{is~k-good}]$</span>.</p><p><span class="markdown-them-math-inline">$n, q \leqslant 2 \times 10 ^ 5, 1 \leqslant l &lt; r \leqslant n.$</span></p><hr><p>考虑计算一个特定的子串 <span class="markdown-them-math-inline">$t$</span> 对应的 <span class="markdown-them-math-inline">$\sum_k k[t~\textrm{is~k-good}]$</span>. 对 <span class="markdown-them-math-inline">$k$</span> 分类讨论:</p><ul><li><span class="markdown-them-math-inline">$k = 1$</span>: 任意字符串均不是 <span class="markdown-them-math-inline">$\textrm {1-good}$</span> 的.</li><li><span class="markdown-them-math-inline">$k = |t|$</span>: <span class="markdown-them-math-inline">$t$</span> 为 <span class="markdown-them-math-inline">$\textrm {|t|-good}$</span> 的当且仅当 <span class="markdown-them-math-inline">$t$</span> 本身为回文串.</li><li><span class="markdown-them-math-inline">$k$</span> 为偶数: 若 <span class="markdown-them-math-inline">$t$</span> 不为 <span class="markdown-them-math-inline">$\textrm {k-good}$</span> 的, 则任意长度为 <span class="markdown-them-math-inline">$k$</span> 的子串均为回文的, 则 <span class="markdown-them-math-inline">$t$</span> 中所有字符均相等.</li><li><span class="markdown-them-math-inline">$k$</span> 为奇数: 若 <span class="markdown-them-math-inline">$t$</span> 不为 <span class="markdown-them-math-inline">$\textrm {k-good}$</span> 的, 则任意长度为 <span class="markdown-them-math-inline">$k$</span> 的子串均为回文的, 则 <span class="markdown-them-math-inline">$t$</span> 中所有距离为 <span class="markdown-them-math-inline">$2$</span> 的字符均相等.</li></ul><p>考虑如何判断 <span class="markdown-them-math-inline">$s$</span> 的子串是否满足以下几个条件:</p><ul><li><span class="markdown-them-math-inline">$s_{l \sim r}$</span> 是回文的: 使用 <span class="markdown-them-math-inline">$\textrm{Manacher}$</span> 算法或哈希即可.</li><li><span class="markdown-them-math-inline">$s_{l \sim r}$</span> 是全部相等的: 对 <span class="markdown-them-math-inline">$[s_i = s_{i - 1}]$</span> 做前缀和即可.</li><li><span class="markdown-them-math-inline">$s_{l \sim r}$</span> 是间隔相等的: 对 <span class="markdown-them-math-inline">$[s_i = s_{i - 2}]$</span> 分奇偶做前缀和即可.</li></ul><p>满足的条件判断出来后等差数列求和即可算出答案.</p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n + q)$</span>.</p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">manacher</span> (<span class="hljs-params">n, s</span>):</span>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> []    res = [<span class="hljs-number">0</span>] * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)    l, r = -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>):        i = (z + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>        j = z // <span class="hljs-number">2</span>        p = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> i &gt;= r <span class="hljs-keyword">else</span> <span class="hljs-built_in">min</span>(r - i, res[<span class="hljs-number">2</span> * (l + r) - z])        <span class="hljs-keyword">while</span> j + p + <span class="hljs-number">1</span> &lt; n <span class="hljs-keyword">and</span> i - p - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>:            <span class="hljs-keyword">if</span> s[j + p + <span class="hljs-number">1</span>] != s[i - p - <span class="hljs-number">1</span>]: <span class="hljs-keyword">break</span>            p += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> j + p &gt; r: l, r = i - p, j + p        res[z] = p    <span class="hljs-keyword">return</span> resT = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):    n, q = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())    s = <span class="hljs-built_in">input</span>().strip()    p1 = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">2</span>)    p2 = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):        <span class="hljs-keyword">if</span> i &gt;= n: p1[i] = p2[i] = i        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> i + <span class="hljs-number">1</span> &lt; n <span class="hljs-keyword">and</span> s[i] != s[i + <span class="hljs-number">1</span>]: p1[i] = i            <span class="hljs-keyword">else</span>: p1[i] = p1[i + <span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> i + <span class="hljs-number">2</span> &lt; n <span class="hljs-keyword">and</span> s[i] != s[i + <span class="hljs-number">2</span>]: p2[i] = i            <span class="hljs-keyword">else</span>: p2[i] = p2[i + <span class="hljs-number">1</span>]    pal = manacher(n, s)    <span class="hljs-keyword">for</span> __ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(q):        l, r = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())        l -= <span class="hljs-number">1</span>; r -= <span class="hljs-number">1</span>        length = r - l + <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> p1[l] &gt;= r:            <span class="hljs-built_in">print</span>(<span class="hljs-number">0</span>)            <span class="hljs-keyword">continue</span>        <span class="hljs-keyword">if</span> p2[l] &gt;= r - <span class="hljs-number">1</span>:            k = length // <span class="hljs-number">2</span>            <span class="hljs-built_in">print</span>(k * (k + <span class="hljs-number">1</span>))            <span class="hljs-keyword">continue</span>        ans = length * (length + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> pal[l + r] &gt;= length // <span class="hljs-number">2</span>: ans -= length        <span class="hljs-built_in">print</span>(ans)</code></pre></div><h1 id="[$\rm-abc347f$](https://atcoderjp/contests/abc347/tasks/abc347_f) $\rm (^* 2120)$"><a href="https://atcoder.jp/contests/abc347/tasks/abc347_f"><span class="markdown-them-math-inline">$\rm ABC347F$</span></a> <span class="markdown-them-math-inline">$\rm (^* 2120)$</span></h1><p>给定 <span class="markdown-them-math-inline">$n \times n$</span> 的由非负整数构成的矩阵, 要从中选出 <span class="markdown-them-math-inline">$3$</span> 个 <span class="markdown-them-math-inline">$m \times m$</span> 的不相交的子矩阵, 最大化所有子矩阵的元素和.</p><p><span class="markdown-them-math-inline">$2 \leqslant n \leqslant 1000, 1 \leqslant m \leqslant \frac{n}{2}, a_{i, j} \leqslant 10^9$</span>.</p><hr><div  align="center">    <img src="https://img.atcoder.jp/abc347/c8c4557905764a04a59ff89c7b249746.png" width = "500" alt="" align=center /></div><p>尝试枚举三个子矩阵的相对位置关系, 可以发现, 一定存在以上 <span class="markdown-them-math-inline">$6$</span> 中划分方式的其中一种, 使 <span class="markdown-them-math-inline">$3$</span> 个子矩阵分属 <span class="markdown-them-math-inline">$3$</span> 个不同的区域, 且不会有任何部分被其它区域包含.</p><p>容易发现这 <span class="markdown-them-math-inline">$6$</span> 种划分方式本质上是两种.</p><ul><li>对于 <span class="markdown-them-math-inline">$|~|$</span> 型: 求出每一列上的点作为子矩阵左上角的点对应的最大元素和, 预处理列区间的最大值, 枚举划分方案即可.</li><li>对于 <span class="markdown-them-math-inline">$|-$</span> 型: 求出列前缀最大值和右上, 右下部分的前缀最大值, 枚举划分方案即可.</li></ul><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n^2)$</span>.</p><div class="highlight"><pre class="code"><code>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())a = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc</span> (<span class="hljs-params">a</span>):</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):            a[i][j + <span class="hljs-number">1</span>] += a[i][j]        a[i].append(<span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):            a[i + <span class="hljs-number">1</span>][j] += a[i][j]    a.append([<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>))    b = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>, n):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>, n):            b[i][j] = a[i][j] - a[i][j - m] - a[i - m][j] + a[i - m][j - m]        c = [<span class="hljs-built_in">max</span>(b[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]    d = c[:]    e = [<span class="hljs-number">0</span>] * n    res = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):        d[i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(d[i + <span class="hljs-number">1</span>], d[i])    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - m - <span class="hljs-number">1</span>, m - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>):        f = <span class="hljs-number">0</span>        g = [<span class="hljs-number">0</span>] * (i + m) + c[i + m : ]        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            e[j] = <span class="hljs-built_in">max</span>(e[j], b[i + m][j])        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span> * m - <span class="hljs-number">1</span>, n):            f = <span class="hljs-built_in">max</span>(f, e[j - m])            res = <span class="hljs-built_in">max</span>(res, d[i] + e[j] + f)        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + m, n - <span class="hljs-number">1</span>):            g[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(g[j + <span class="hljs-number">1</span>], g[j])        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">2</span> * m, n):            res = <span class="hljs-built_in">max</span>(res, d[i] + g[j - m] + c[j])    <span class="hljs-keyword">return</span> resans = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):    ans = <span class="hljs-built_in">max</span>(ans, calc([<span class="hljs-built_in">list</span>(l) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*a)]))    a = [<span class="hljs-built_in">list</span>(l)[ : : -<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*a)]<span class="hljs-built_in">print</span>(ans)</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一封面向社会，关于对近日来 CCF 不当行为之抗议的公开信</title>
      <link href="/2023/06/24/zhi-ccf-de-yi-feng-gong-kai-xin/"/>
      <url>/2023/06/24/zhi-ccf-de-yi-feng-gong-kai-xin/</url>
      
        <content type="html"><![CDATA[<p>​</p><span id="more"></span><p><span class="markdown-them-math-inline">$\quad$</span>前天<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我看到 <span class="markdown-them-math-inline">$\rm CCF$</span> 发布了这样一则公告 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><a href="https://www.noi.cn/xw/2021-12-03/750909.shtml"><img src="https://s4.ax1x.com/2021/12/05/oDH7ND.png" alt="https://www.noi.cn/xw/2021-12-03/750909.shtml"></a></p><p><span class="markdown-them-math-inline">$\quad$</span>得知此事<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我很愤怒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但愤怒过后是深深的失落<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>大概是因为看着我所热爱的信息学竞赛正因为一个组织的糊涂行为走向毁灭吧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>是的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>毁灭<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span> <span class="markdown-them-math-inline">$\rm OI$</span> 要做干净的竞赛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> 这句话的提出者正抬起脚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>狠狠地将这块令所有信息竞赛生引以为傲的招牌踩在地上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>变得四分五裂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>当一个竞赛已经失去了信用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那它的存在倒比毁灭更令人难过了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p><p><span class="markdown-them-math-inline">$\quad$</span>在过去的很多年里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\rm CCF$</span> 一直有一个规定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若某省存在选手作弊<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<strong>扣除该省省队名额一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将作弊选手禁赛三年</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于这个政策的存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有很多本该进入省队的选手因为某个与自己<strong>毫不相关</strong>的人作弊而与自己本该获得的奖牌失之交臂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><a href="https://www.noi.cn/xw/2021-11-05/749732.shtml"><img src="https://s4.ax1x.com/2021/12/05/oDqEJe.png" alt="https://www.noi.cn/xw/2021-11-05/749732.shtml"></a></p><p><span class="markdown-them-math-inline">$\quad$</span>但这项规则对所有人都是如此吗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>去年南门口中学某谢姓选手在省选考场上作弊<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并进入省队<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>作弊事实败露后他<strong>仅仅是被 <span class="markdown-them-math-inline">$\rm CCF$</span> 以非公开的方式取消了抄袭题目的分数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>甚至还参加了在省选之后举办的清华集训<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p><p><span class="markdown-them-math-inline">$\quad$</span>而今年情况越发严峻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>十多个省由于存在作弊选手而被扣除省队名额<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中大多数为入门组的小朋友<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而代价却要能够进入省队的高水平选手来承担<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>幸好后来事情发生了变化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有一名被判定为作弊的选手来自某<strong>超级强校</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而那所学校的教练对 <span class="markdown-them-math-inline">$\rm CCF$</span> 的行为进行了强烈的抗议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接促使 <span class="markdown-them-math-inline">$\rm CCF$</span> 被迫取消此规定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><a href="https://www.noi.cn/xw/2021-11-30/750857.shtml"><img src="https://s4.ax1x.com/2021/12/05/oDqlo8.png" alt="https://www.noi.cn/xw/2021-11-30/750857.shtml"></a></p><p><span class="markdown-them-math-inline">$\quad$</span>在结果大快人心的同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们不妨想想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>之前难道没有学校对这个规定进行过抗议吗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span><strong>为什么 <span class="markdown-them-math-inline">$\rm CCF$</span> 可以置若罔闻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而超级强校对其抗议却立刻奏效了呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p><p><span class="markdown-them-math-inline">$\quad$</span>在 <span class="markdown-them-math-inline">$\rm CCF$</span> 取消上述规定后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我本来以为风波已平<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>却不想是另一场风暴的开端<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这次更是带来了席卷 <span class="markdown-them-math-inline">$\rm OI$</span> 界的滔天巨浪 —— <strong>某些选手因为在代码注释中写下 <code>F**k_CCF</code> 等内容而被取消本次考试成绩并被禁赛一年<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p><p><a href="https://www.noi.cn/xw/2021-12-03/750909.shtml"><img src="https://s4.ax1x.com/2021/12/05/oDqrYF.png" alt="https://www.noi.cn/xw/2021-12-03/750909.shtml"></a></p><p><span class="markdown-them-math-inline">$\quad$</span>先对一些关键点进行解释 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>代码注释是形如下文中 &quot; <span class="markdown-them-math-inline">$//$</span> &quot; 后面的内容 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></li></ul><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span> </span>&#123;    x = <span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)        x = x * <span class="hljs-number">10</span> + c - <span class="hljs-number">48</span>, c = <span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-comment">// 这段代码被用来快速读入一个数&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;注意&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;只能用来读取不大于 2^31 - 1 的正整数&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;。&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;</span></code></pre></div><p><span class="markdown-them-math-inline">$\quad$</span>注释一般被写在代码中用来提醒程序员这段代码起什么作用或者需要注意什么事情<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在评测时机器不会读取这些字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li>在 <span class="markdown-them-math-inline">$\rm OI$</span> 考试中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><strong>时间紧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任务重<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大多数选手在考试结束时是拿不到自己的极限分数的</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而在考试中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>题目质量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考场状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考试策略等都能极大地影响一个选手的分数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但一场考试又最多只有 <span class="markdown-them-math-inline">$4$</span> 道题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以选手在在看到自己不擅长的题目类型时是非常难受的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如说这次 <span class="markdown-them-math-inline">$\rm NOIp$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我本人在发现有一半题目是 <span class="markdown-them-math-inline">$\rm DP$</span> 题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且 <span class="markdown-them-math-inline">$\rm DP$</span> 又是我最不擅长的知识点时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>花 <span class="markdown-them-math-inline">$5$</span> 分钟去厕所洗了个脸才基本冷静下来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>而某些选手在注释中写下一些对 <span class="markdown-them-math-inline">$\rm CCF$</span> 的怒斥又何尝不是他们宣泄情绪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>让自己保持冷静的方式呢 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></li></ul><p><span class="markdown-them-math-inline">$\quad$</span><strong>至于某些人将这种行为类比成在高考作文中骂教育部是完全不恰当的</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为在了解了 <span class="markdown-them-math-inline">$\rm OI$</span> 的规则后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们知道这种行为顶多算是在草稿纸上写 <code>F**k jyb</code>. 改卷老师<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>评测机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是不会看到这些语句的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>虽然草稿纸最后会被公示<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>此处不得不承认 <span class="markdown-them-math-inline">$\rm CCF$</span> 在赛后公示选手代码<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>答卷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是考试史上的一大进步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但公示后会看到的人数至多以千记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>造成的影响不算很大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li>禁赛一年是指在接下来的一年中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>被禁赛的选手将不能参加<strong>所有</strong> <span class="markdown-them-math-inline">$\rm NOI$</span> 系列的比赛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这意味着一个选手不能参加次年的 <span class="markdown-them-math-inline">$\rm NOIp$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而又有谁能在不参加 <span class="markdown-them-math-inline">$\rm NOIp$</span> 的情况下进入省队呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>所以一个选手两年内的所有比赛将会被禁止<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这意味着如果这个选手是高中生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<strong>他的 <span class="markdown-them-math-inline">$\rm OI$</span> 之路必将就此断绝</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p><span class="markdown-them-math-inline">$\quad$</span>回归正题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>看到这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大家对 <span class="markdown-them-math-inline">$\rm CCF$</span> 的行为应该已经有了自己的评判<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大多数 <span class="markdown-them-math-inline">$\rm OIer$</span> 对 <span class="markdown-them-math-inline">$\rm CCF$</span> 所作行为的愤怒之处并不在于他对涉事选手的处罚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而在于 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>选手不过是在 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>草稿纸<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> 上骂了 <span class="markdown-them-math-inline">$\rm CCF$</span> 几句<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 <span class="markdown-them-math-inline">$\rm CCF$</span> 却要对他们赶尽杀绝<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><strong>这未免已经超出了批评教育<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>甚至惩罚的范畴<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p></li><li><p>前 <span class="markdown-them-math-inline">$\rm IOI$</span> 中国代表队成员钟子谦已经对全国选手的代码进行了查找<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现在代码中辱骂 <span class="markdown-them-math-inline">$\rm CCF$</span> 者高达 <span class="markdown-them-math-inline">$122$</span> 人之多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 <span class="markdown-them-math-inline">$\rm CCF$</span> 却只处罚了 <span class="markdown-them-math-inline">$5$</span> 名高水平选手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅占总数的 <span class="markdown-them-math-inline">$4\%$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中甚至包含一名联赛 <span class="markdown-them-math-inline">$344$</span> 分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>排名浙江第 <span class="markdown-them-math-inline">$4$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不出意外必然进入国家集训队的选手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>这不禁让人联想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中是不是有其它的利益关系呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p></li></ul><p><a href="https://www.zhihu.com/question/503464471/answer/2256076365"><img src="https://s4.ax1x.com/2021/12/05/oDxsfK.png" alt="https://www.zhihu.com/question/503464471/answer/2256076365"></a></p><ul><li><strong><span class="markdown-them-math-inline">$\rm CCF$</span> 这样做并没有任何法律依据</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而仅仅是搬出了 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span> 国务院办公厅近日印发的<span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char></span>关于全面加强新时代语言文字工作的意见<span class="bd-box"><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char></span>指出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>加强语言文明教育<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>强化对互联网等各类新媒体语言文字使用的规范和管理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>坚决遏阻庸俗暴戾网络语言传播<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建设健康文明的网络语言环境<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> 这样一段并不具有法律效力的文本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就对 <span class="markdown-them-math-inline">$5$</span> 名选手做出了如此严厉的处罚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>这种行为本就违反了中国科学技术协会发布的<span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char></span>中国科协全国五项学科竞赛条例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char></span>中 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span> 不可擅自更改参赛学生的竞赛结果或成绩 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> 这一条款<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></li></ul><p><a href="https://www.noi.cn/gynoi/tlgd/2008-12-26/710428.shtml"><img src="https://s4.ax1x.com/2021/12/05/oDzfvF.png" alt="https://www.noi.cn/gynoi/tlgd/2008-12-26/710428.shtml"></a></p><ul><li><span class="markdown-them-math-inline">$\rm CCF$</span> 做出这样的事非但没有法律依据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且还是在<strong>没有任何提前通知的情况下猝然做出</strong>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这不禁让人忧心<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果今后某位选手在考完试后得罪了某位 <span class="markdown-them-math-inline">$\rm CCF$</span> 的领导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那他是不是可以<strong>生造一条莫须有的规定</strong>来取消这位选手的成绩并将他禁赛呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>这未免太可怕了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></li></ul><p><span class="markdown-them-math-inline">$\quad$</span>因此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我作为一名现役的高二信息竞赛生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在此对 <span class="markdown-them-math-inline">$\rm CCF$</span> 提出我们 <span class="markdown-them-math-inline">$\rm OIer$</span> 的共同诉求 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><strong>撤销对 <span class="markdown-them-math-inline">$5$</span> 名选手取消成绩和禁赛一年的处罚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将对它们的惩罚限定在批评教育的范畴内</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果贵学会坚持认为他们的行为对自己造成了严重的声誉影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以<strong>依法向他们提出合理的经济赔偿</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>我奉劝中国计算机学会<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>既然要承办信息学奥林匹克竞赛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那就要秉承<strong>奥林匹克精神</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>守住竞赛公平的底线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不是成为用心险恶之人作恶的工具<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>作为一名中学生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我当然对改变此事无能为力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但 <span class="markdown-them-math-inline">$\rm OIer$</span> 不是一名中学生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是千千万万心怀公义的少年<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若是 <span class="markdown-them-math-inline">$\rm CCF$</span> 继续执迷不悟<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>非要一意孤行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将 <span class="markdown-them-math-inline">$\rm OI$</span> 变成自己滥权和敛财的工具<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么必将被另一个更有能力的组织取代<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>事实上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我期待这一天的到来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span><strong>最后我想说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>国家交给任何组织的公权力都不是让其肆意滥用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>竞赛这种为国举才的大事不能用于满足某些人的私利<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>希望 <span class="markdown-them-math-inline">$\rm CCF$</span> 悬崖勒马<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不要陷自己于不仁不义不法之地</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>此致<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><hr><p><span class="markdown-them-math-inline">$\quad$</span>下附信息学竞赛赛程和基本规则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以助不了解信息学竞赛者快速理解上文中某些内容 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>信息学竞赛的赛程是 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>初赛 <span class="markdown-them-math-inline">$+~\rm CSP$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>决定选手是否有资格参加 联赛 <span class="markdown-them-math-inline">$\rm (NOIp)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>允许社会人员参与<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>并且 <span class="markdown-them-math-inline">$\rm CCF$</span> 曾宣布过 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span> <span class="markdown-them-math-inline">$\rm CSP$</span> 与 <span class="markdown-them-math-inline">$\rm NOI$</span> 系列比赛没有任何关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但最后还是成为了 <span class="markdown-them-math-inline">$\rm NOIp$</span> 的预选赛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其真实目的也不过是为了对抗教育部 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span> 竞赛不可收费 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> 的规定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>违规收取选手的参赛费罢了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><a href="https://www.noi.cn/xw/2019-09-09/715376.shtml"><img src="https://s4.ax1x.com/2021/12/05/orS5z8.png" alt="https://www.noi.cn/xw/2019-09-09/715376.shtml"></a></p><p><span class="markdown-them-math-inline">$\quad \rm NOIp$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>全国中学生信息联赛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于一般选手来说这是一个赛季中最重要的比赛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将评出省一二三等奖<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$\rm -OH$</span> 计划出台后已无实际作用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或许更大程度上是一个选手认真参加过 <span class="markdown-them-math-inline">$\rm OI$</span> 的证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>省选 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>全国高中生信息竞赛省队选拔赛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于选拔各省省队去参加 国赛 <span class="markdown-them-math-inline">$\rm (NOI)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个省的名额在 <span class="markdown-them-math-inline">$10$</span> 人左右<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据各省成绩好坏会有所增减<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>选拔方式为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将联赛和省选分数计算其占该省最高分比例后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别以 <span class="markdown-them-math-inline">$0.4,0.6$</span> 的权重加权而得的值降序排列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从前往后取至省队名额<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同时每所学校的进队人数不可占省队名额的 <span class="markdown-them-math-inline">$1 / 3$</span> 以上<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>四舍五入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因该限制而空出的名额向后顺延<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad \rm NOI$</span> : 全国高中生信息竞赛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>绝大多数顶尖选手的最终挑战<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前 <span class="markdown-them-math-inline">$50$</span> 名进入国家集训队保送清北<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$51\sim 200$</span> 名获得银牌破格入围 <span class="markdown-them-math-inline">$\rm -OH$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>除了这 <span class="markdown-them-math-inline">$200$</span> 人之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论获得其它什么奖项都仅作为纪念和荣誉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他们将带着对 <span class="markdown-them-math-inline">$\rm OI$</span> 的回忆回归文化课<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>信息学竞赛的评分机制是 :</p><p><span class="markdown-them-math-inline">$\quad$</span>初赛 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>笔试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>题型为选择题和填空题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>全部随机选择的期望分数可以晋级 <span class="markdown-them-math-inline">$\rm CSP.$</span></p><p><span class="markdown-them-math-inline">$\quad \rm CSP,NOIp~:~CSP~4$</span> 小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\rm NOIp~4.5$</span> 小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>均为 <span class="markdown-them-math-inline">$4$</span> 道题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>省选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\rm NOI$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>均为两场<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每场 <span class="markdown-them-math-inline">$5$</span> 小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$3$</span> 道题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>除了初赛之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考试中的每道题形如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给定一个问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span> 给出两个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求它们的和 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>你需要在规定时间内编写一个程序用来解决它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考完之后选手编写的程序会被上交<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>统一进行评测<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>评测时评测机会给出一些输入文本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>待测程序读取后会按照选手所编写的程式对其进行一定处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后给出输出文本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果待测程序在规定时间内给出了输出文本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>评测机会将它与标准答案进行对比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果完全相同<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>也有一些非传统评测规则并非如此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此处略过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>则选手获得该测试点的分数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如说在之前那个问题中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>评测机若给出输入文本 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span> <span class="markdown-them-math-inline">$2~3$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么一个正确的程序应该输出 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span> <span class="markdown-them-math-inline">$5$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且可以获得这个测试点的分数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad$</span>在 <span class="markdown-them-math-inline">$\rm OI$</span> 赛制中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每道题目的分数均为 <span class="markdown-them-math-inline">$100$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后每道题的得分之和就是一场考试的总分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每道题的分数并不是非零即 <span class="markdown-them-math-inline">$100$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大多数题目会给出若干子任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果选手无法解决完整的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以选择一些弱化问题来解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并获得相应的部分分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」生成函数强化训练</title>
      <link href="/2023/06/24/shu-xue-sheng-cheng-han-shu-qiang-hua-xun-lian/"/>
      <url>/2023/06/24/shu-xue-sheng-cheng-han-shu-qiang-hua-xun-lian/</url>
      
        <content type="html"><![CDATA[<p>本文记录了刚学完生成函数以后做的一些练习题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h1 id="[$\rm-[集训队作业2013]城市规划$](https://wwwluogu.com.cn/problem/p4841)"><a href="https://www.luogu.com.cn/problem/P4841"><span class="markdown-them-math-inline">$\rm [集训队作业2013]城市规划$</span></a></h1><p>考虑 <span class="markdown-them-math-inline">$\rm EGF$</span> 的组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现若设任意图方案数的 <span class="markdown-them-math-inline">$\rm EGF$</span> 为 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>连通图的 <span class="markdown-them-math-inline">$\rm EGF$</span> 为 <span class="markdown-them-math-inline">$G(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然任意图计数可以被看做先将 <span class="markdown-them-math-inline">$n$</span> 个点分进若干个非空子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后做连通图计数的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么根据之前的结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \exp G(x) \iff G(x) = \ln F(x)$$</div><p>显然有 <span class="markdown-them-math-inline">$F(x) = \sum _ n 2 ^ {\binom{n}{2}} x ^ n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是只需直接对其求 <span class="markdown-them-math-inline">$\ln$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n).$</span></p><h2 id="[$\rm-code~link$](https://pasteubuntu.com/p/xmqf5fsg9w/)"><a href="https://paste.ubuntu.com/p/xmQf5fsg9w/"><span class="markdown-them-math-inline">$\rm Code~Link$</span></a></h2><h1 id="[$\rm-[cf438e]the~child~and~binary~tree$](http://codeforcescom/problemset/problem/438/e)"><a href="http://codeforces.com/problemset/problem/438/E"><span class="markdown-them-math-inline">$\rm [CF438E]The~Child~and~Binary~Tree$</span></a></h1><p>首先可以考虑一个 <span class="markdown-them-math-inline">$\rm DP$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$f_S$</span> 表示点权之和为 <span class="markdown-them-math-inline">$S$</span> 的二叉树数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>迭代时可以考虑枚举左子树的权值和 <span class="markdown-them-math-inline">$S_l$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>右子树的权值和 <span class="markdown-them-math-inline">$S_r$</span> 和根节点的权值 <span class="markdown-them-math-inline">$w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么有 <span class="markdown-them-math-inline">$f_{S_l + S_r + w} = \sum _{S_l} \sum _{S_r} \sum _{w \in C} f_{S_l} f_{S_r}.$</span></p><p>容易发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个式子可以用三个多项式的卷积来拟合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$F(x) = \sum _ n f_n x ^ n, G(x) = \sum _ n [n \in C] x ^ n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F = F ^ 2 G + 1$$</div><p>最后的 <span class="markdown-them-math-inline">$+1$</span> 是为了补齐常数项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 <span class="markdown-them-math-inline">$f_0$</span> 为 <span class="markdown-them-math-inline">$1.$</span></p><p>解方程可以得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F = \frac{1 \pm \sqrt{1 - 4G}}{2G}$$</div><p>由于有两个解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然不可能都成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑 <span class="markdown-them-math-inline">$x \to 0$</span> 时的特殊情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当 <span class="markdown-them-math-inline">$x \to 0$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F(x) \to 1,G(x) \to 0.$</span></p><div class="markdown-them-math-block">$$\lim _ {x \to 0} \frac{1 + \sqrt{1 - 4G}}{2G} = +\infty \not= \lim _ {x \to 0} F$$</div><div class="markdown-them-math-block">$$\lim _ {x \to 0} \frac{1 - \sqrt{1 - 4G}}{2G} = 1 = \lim _ {x \to 0} F$$</div><p>于是选取 <span class="markdown-them-math-inline">$F= \frac{1 - \sqrt{1 - 4G}}{2G}$</span> 作为方程的解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>到这一步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现一个问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 <span class="markdown-them-math-inline">$G(x)$</span> 的常数项为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$G(x)$</span> 不可以求逆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑对解做变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里选取分子有理化 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F = \frac{\left(1 - \sqrt{1 - 4G}\right)\left(1 + \sqrt{1 - 4G}\right)}{2G\left(1 + \sqrt{1 - 4G}\right)} = \frac{2}{1 + \sqrt{1 - 4G}}$$</div><p>可以发现分母的常数项必定不为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是做多项式开方和多项式求逆即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n).$</span></p><h2 id="[$\rm-code~link$](https://pasteubuntu.com/p/yxyyhwmfh9/)"><a href="https://paste.ubuntu.com/p/YxyyhWmFh9/"><span class="markdown-them-math-inline">$\rm Code~Link$</span></a></h2><h1 id="[$\rm-[国家集训队]整数的~lqp~拆分$](https://wwwluogu.com.cn/problem/p4451)"><a href="https://www.luogu.com.cn/problem/P4451"><span class="markdown-them-math-inline">$\rm [国家集训队]整数的~lqp~拆分$</span></a></h1><p>设 <span class="markdown-them-math-inline">$\{f_n\},\{g_n\}$</span> 分别为斐波那契数列和答案序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F(x)$</span> 和 <span class="markdown-them-math-inline">$G(x)$</span> 分别为它们的生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>显然有斐波那契数列的生成函数 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \frac{x}{1 - x - x ^ 2}$$</div><p>而对于 <span class="markdown-them-math-inline">$G(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现如果 <span class="markdown-them-math-inline">$g_i$</span> 已经被求出来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么给所有的拆分加上一个数 <span class="markdown-them-math-inline">$n - i$</span> 即可得到 <span class="markdown-them-math-inline">$g_n$</span> 的所有拆分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g_i$</span> 对 <span class="markdown-them-math-inline">$g_n$</span> 的贡献为 <span class="markdown-them-math-inline">$g_i \times f_{n - i}.$</span> 于是有 <span class="markdown-them-math-inline">$g_n$</span> 的递推式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$g_n = \sum _ {i = 0} ^ {n- 1} g_i \times f_{n - i}$$</div><p>将 <span class="markdown-them-math-inline">$\{g_n\}$</span> 带入 <span class="markdown-them-math-inline">$G(x)$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G(x) = \sum _ n x ^ n \sum _ {i = 0} ^ {n - 1} g_i f_{n - i}$$</div><p>可以发现等式右边实际上是卷积的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G = GF$$</div><p>但是我们发现这样的话 <span class="markdown-them-math-inline">$G(x) = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>原因是 <span class="markdown-them-math-inline">$g_0 = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们强制 <span class="markdown-them-math-inline">$g_0 = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G = GF + 1$$</div><div class="markdown-them-math-block">$$G(x) = \frac{1}{1 - F(x)} = 1 + \frac{x}{1 - 2x - x ^ 2}$$</div><p>可以发现现在求出的 <span class="markdown-them-math-inline">$G(x)$</span> 比实际值多了 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为我们将 <span class="markdown-them-math-inline">$g_0 = 0$</span> 强制变成了 <span class="markdown-them-math-inline">$g_0 = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>修正后有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G(x) = \frac{x}{1 - 2x - x ^ 2} = \frac{\frac{\sqrt{2}}{4}}{1 - (1 + \sqrt{2})x} + \frac{-\frac{\sqrt{2}}{4}}{1 - (1 - \sqrt{2})x}$$</div><div class="markdown-them-math-block">$$[x ^ n]G(x) = \frac{\sqrt{2}}{4}(1 + \sqrt{2}) ^ n - \frac{\sqrt{2}}{4}(1 - \sqrt{2}) ^ n$$</div><p>最后求出 <span class="markdown-them-math-inline">$\sqrt{2}$</span> 在模 <span class="markdown-them-math-inline">$10 ^ 9 + 7$</span> 意义下的二次剩余<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且用拓展欧拉定理即可计算出答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(\log n).$</span></p><h2 id="[$\rm-code~link$](https://pasteubuntu.com/p/4dcfymf5th/)"><a href="https://paste.ubuntu.com/p/4DCfYMF5tH/"><span class="markdown-them-math-inline">$\rm Code~Link$</span></a></h2><h1 id="[$\rm-[haoi2018]染色$](https://wwwluogu.com.cn/problem/p4491)"><a href="https://www.luogu.com.cn/problem/P4491"><span class="markdown-them-math-inline">$\rm [HAOI2018]染色$</span></a></h1><p>首先考虑二项式反演 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$f_i$</span> 表示恰好有 <span class="markdown-them-math-inline">$i$</span> 个数的数量为 <span class="markdown-them-math-inline">$S$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g_i$</span> 表示钦点 <span class="markdown-them-math-inline">$i$</span> 个数的数量为 <span class="markdown-them-math-inline">$S$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$g_k = \dbinom{m}{k} \times \frac{n ^ {\underline{kS}}}{(S!) ^ k} \times (m - k) ^ {n - kS}$$</div><div class="markdown-them-math-block">$$g_k = \sum_{i = k} ^ m \dbinom{i}{k} f_i \iff f_k = \sum _ {i = k} ^ m (-1) ^ {i - k} \dbinom{i}{k} g_i$$</div><div class="markdown-them-math-block">$$Ans = \sum _ {i = 0} ^ m w_if_i$$</div><p>于是我们考虑如何对于每个 <span class="markdown-them-math-inline">$i \in [0, m]$</span> 求出 <span class="markdown-them-math-inline">$f_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里有个技巧 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    f_k &amp;= \sum _ {i = k} ^ m (-1) ^ {i - k} \frac{i!}{k!(i - k)!} g_i\\    &amp;= k! \sum _ {i = k} ^ m i! g_i \times \frac{(-1) ^ {i - k}}{(i - k)!}\end{aligned}$$</div><p>容易发现上式可以用差值卷积计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n).$</span></p><h1 id="[$\rm-付公主的背包$](https://wwwluogu.com.cn/problem/p4389)"><a href="https://www.luogu.com.cn/problem/P4389"><span class="markdown-them-math-inline">$\rm 付公主的背包$</span></a></h1><p>容易发现若设每种大小的物品的数量为 <span class="markdown-them-math-inline">$f_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么答案的生成函数为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\prod _ i \left (\sum _ j x ^ {ji}\right) ^ {f _ i} = \prod _ i \left(\frac{1}{1 - x ^ i}\right) ^ {f _ i}$$</div><p>可以直接使用欧拉变换的求解方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n).$</span></p><h1 id="[$无标号无根树计数$](https://wwwluogu.com.cn/problem/p5900)"><a href="https://www.luogu.com.cn/problem/P5900"><span class="markdown-them-math-inline">$无标号无根树计数$</span></a></h1><p>考虑设 <span class="markdown-them-math-inline">$f_n$</span> 表示大小为 <span class="markdown-them-math-inline">$n$</span> 的无标号有根树的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F(x)$</span> 为数列 <span class="markdown-them-math-inline">$f$</span> 的生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果将一颗大小为 <span class="markdown-them-math-inline">$n$</span> 的无标号有根树的根去除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么剩下的子树是一个个相同的子问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要子树大小的和为 <span class="markdown-them-math-inline">$n - 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再加上根结点就可以唯一确定地拼出一颗无标号有根树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是有生成函数方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = x \cdot \varepsilon \circ F(x)$$</div><p>求解这个生成函数方程有两种方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第一种是直接化简<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分治多项式乘法求解 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = x \prod _ i (1 - x ^ i) ^ {-f_i}$$</div><p>考虑对两边取 <span class="markdown-them-math-inline">$\ln$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将连乘转连加 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\ln F(x) = \ln x - \sum _ i f_i \ln (1 - x ^ i)$$</div><p>对数不好处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑求导 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\frac{F'(x)}{F(x)} = \frac{1}{x} + \sum _ i if_i \times \frac{x ^ {i - 1}}{1 - x ^ i}$$</div><p>将两边同时乘以 <span class="markdown-them-math-inline">$xF(x)$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$xF'(x) = F(x) + F(x) \sum _ i if_i \frac{x ^ i}{1 - x ^ i}$$</div><p>考虑将右半部分还原成 <span class="markdown-them-math-inline">$F(x)$</span> 表示 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$xF'(x) = F(x) + F(x)\left(\sum _ {i \geqslant 1} x ^ i F'(x ^ i)\right)$$</div><p>设 <span class="markdown-them-math-inline">$G(x) = \sum _ k x ^ k F'(x ^ k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>简单推一推 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G(x) = \sum _ k x ^ k \sum _ {i\geqslant 1} if _ i \left(x ^ {k}\right) ^ {i - 1} = \sum _ k \sum _ i i f _ i x ^ {ik} = \sum _ n x ^ n \sum _ {d | n} d f _ d$$</div><p>故 <span class="markdown-them-math-inline">$g_n = \sum _ {d | n} df_d,g_1 = f_1 = 1.$</span></p><p>因此 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_n = \frac{1}{n - 1} \sum _ {k = 1} ^ {n - 1} f _ k g _ {n - k}$$</div><p><span class="markdown-them-math-inline">$f$</span> 使用分治多项式乘法求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g$</span> 暴力求解即可做到 <span class="markdown-them-math-inline">$\Theta(n \log ^ 2 n).$</span></p><p>另一种方法是使用牛顿迭代 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>显然我们要求解方程 <span class="markdown-them-math-inline">$G \circ F(x) = F(x) - x \cdot \varepsilon \circ F(x) = 0$</span>.</p><p>假设当前已经求出了方程在模 <span class="markdown-them-math-inline">$x ^ n$</span> 意义下的解 <span class="markdown-them-math-inline">$F_0(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设方程在模 <span class="markdown-them-math-inline">$x ^ {2n}$</span> 意义下的解为 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>众所周知有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = F_0(x) - \frac{G \circ F_0(x)}{G' \circ F_0(x)}$$</div><p>我们知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\varepsilon \circ F(x)$</span> 可以在 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span> 的时间复杂度内求出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F'(x)$</span> 可以 <span class="markdown-them-math-inline">$\Theta(n)$</span> 求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以在 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span> 的时间复杂度内求下式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = F_0(x) - \frac{F_0(x)  - x \cdot \varepsilon \circ F_0(x)}{[F_0(x)  - x \cdot \varepsilon \circ F_0(x)]'}$$</div><p>用上式迭代即可算出 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n).$</span></p><p>现在我们已经求出了无标号有根树的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑将无标号无根树的方案数容斥出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑钦点无标号无根树的根是它的重心<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是只需要去掉根不是重心的无标号有根树的方案数可以了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分类讨论 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>如果重心唯一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么一定存在一颗子树的大小大于 <span class="markdown-them-math-inline">$\left\lfloor\frac{n}{2}\right\rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑枚举它的大小 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现这颗子树的方案数和将它切除后树的方案数都是无标号有根树计数问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其答案我们已经算出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是总方案数需要减去 <span class="markdown-them-math-inline">$\sum _ {i = \left\lfloor\frac{n}{2}\right\rfloor + 1} ^{n - 1} f_i \times f_{n - i}.$</span></p><p>如果重心不唯一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么一棵树还会在两个重心上分别被计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种方案只会在 <span class="markdown-them-math-inline">$n$</span> 为偶数的情况下出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑到这两个重心一定相连<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是将它们之间的连边断开后形成的两个子树的方案数是独立的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当两颗子树完全相同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别以它的两个重心为根时形成的有根树是同构的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以我们还是只会将它计算一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故算重的方案中不包括两颗子树相同的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是总方案数还需要减去 <span class="markdown-them-math-inline">$\binom{f_{\frac{n}{2}}}{2}.$</span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>问题得到解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n \log ^ 2 n)$</span> 或 <span class="markdown-them-math-inline">$\Theta(n \log n).$</span></p><h1 id="[$\rm-[ceoi2004]sweets$](https://wwwluogu.com.cn/problem/p6078)"><a href="https://www.luogu.com.cn/problem/P6078"><span class="markdown-them-math-inline">$\rm [CEOI2004]Sweets$</span></a></h1><p>考虑构造 <span class="markdown-them-math-inline">$F_i(x) = \sum _ {j = 0} ^ {m _ i} x ^ j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现题目要求的就是 <span class="markdown-them-math-inline">$\prod _ {i = 1} ^ n F_i(x)$</span> 的系数前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是再构造 <span class="markdown-them-math-inline">$F_0(x) = \sum _ i x ^ i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将它和原本的 <span class="markdown-them-math-inline">$n$</span> 个幂级数卷在一起<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在考虑求 <span class="markdown-them-math-inline">$F(x) = \prod _ {i = 0} ^ n F_i(x)$</span> 的第 <span class="markdown-them-math-inline">$L$</span> 项系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>容易发现有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \frac{(1 - x ^ {m_1 + 1})(1 - x ^ {m_2 + 1})\cdots(1 - x ^ {m_n + 1})}{(1 - x) ^ {n + 1}}$$</div><p>观察到 <span class="markdown-them-math-inline">$n$</span> 很小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑暴力将分子拆开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是分式变成了 <span class="markdown-them-math-inline">$2 ^ n$</span> 个形如 <span class="markdown-them-math-inline">$\frac{x ^ k}{(1 - x) ^ {n + 1}}$</span> 的部分之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>容易发现 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$[x ^ L]\frac{x ^ k}{(1 - x) ^ {n + 1}} = \dbinom{n + L - k}{n}$$</div><p>于是只需要求 <span class="markdown-them-math-inline">$2 ^ {n + 1}$</span> 次形如 <span class="markdown-them-math-inline">$\binom{t}{n}$</span> 的组合数即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>到这里我们又发现模数 <span class="markdown-them-math-inline">$p$</span> 不是质数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑将式子变形 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\dbinom{t}{n}~\bmod~p = \frac{t^{\underline{n}}}{n!}~\bmod~p = \frac{t ^ {\underline{n}}~\bmod~n!\cdot p}{n!}~\bmod~p$$</div><p>于是这样就可以 <span class="markdown-them-math-inline">$\Theta(n)$</span> 求解组合数了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(2^n n).$</span></p><h1 id="[$\rm-[51nod1728]不动点$](https://www51nod.com/challenge/problem.html#problemid=1728)"><a href="https://www.51nod.com/Challenge/Problem.html#problemId=1728"><span class="markdown-them-math-inline">$\rm [51nod1728]不动点$</span></a></h1><p>简化题意 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>求有多少个从 <span class="markdown-them-math-inline">$\{1,2,\cdots,n\}$</span> 到 <span class="markdown-them-math-inline">$\{1,2,\cdots,n\}$</span> 的映射 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\underbrace{f \circ f \circ \cdots \circ f}_{k}=\underbrace{f \circ f \circ \cdots \circ f}_{k-1}$$</div><p>保证 <span class="markdown-them-math-inline">$nk \leqslant 2 \times 10 ^ 6,1\leqslant k \leqslant 3.$</span></p><p>可以发现这题本质上就是在求深度不超过 <span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>环大小为 <span class="markdown-them-math-inline">$1$</span> 的基环内向树森林的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进一步发现其等价于树高不超过 <span class="markdown-them-math-inline">$k$</span> 的有标号有根树森林的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑设树高不超过 <span class="markdown-them-math-inline">$k$</span> 的有标号有根树数量的 <span class="markdown-them-math-inline">$\rm EGF$</span> 为 <span class="markdown-them-math-inline">$\hat{F}_k(x).$</span> 计算考虑递推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>深度不超过 <span class="markdown-them-math-inline">$k$</span> 的树可以看作若干棵深度不超过 <span class="markdown-them-math-inline">$k - 1$</span> 的树全部接在一个点上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\hat{F}_k(x) = x\cdot \exp \hat{F}_{k - 1}(x)$$</div><p>考虑到需要求的是森林的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是答案的指数型生成函数为 <span class="markdown-them-math-inline">$\exp \hat{F}_k(x).$</span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(kn\log n).$</span></p><h1 id="[$\rm-[cf891e]lust$](https://codeforcescom/contest/891/problem/e)"><a href="https://codeforces.com/contest/891/problem/E"><span class="markdown-them-math-inline">$\rm [CF891E]Lust$</span></a></h1><p>考虑一次对 <span class="markdown-them-math-inline">$x$</span> 的操作造成的影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他会使 <span class="markdown-them-math-inline">$a_x$</span> 减少 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案增加 <span class="markdown-them-math-inline">$\prod _ {i \not= x} a_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\prod _ i a_i$</span> 减少 <span class="markdown-them-math-inline">$\prod _ {i \not= x} a_i.$</span></p><p>于是我们可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一次操作对答案的贡献等于 <span class="markdown-them-math-inline">$\prod _ i a_i$</span> 的变化量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>进一步的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终答案等于 <span class="markdown-them-math-inline">$k$</span> 次操作进行完后 <span class="markdown-them-math-inline">$\prod _ i a_i$</span> 的变化量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设第 <span class="markdown-them-math-inline">$a_i$</span> 被操作了 <span class="markdown-them-math-inline">$b_i$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么答案为 <span class="markdown-them-math-inline">$\prod _ i a_i - \prod _ i (a_i - b_i).$</span></p><p>考虑计算所有情况下 <span class="markdown-them-math-inline">$\prod _ i (a_i - b_i)$</span> 的和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后再将答案除以 <span class="markdown-them-math-inline">$n ^ k.$</span></p><p>假设有两个集合 <span class="markdown-them-math-inline">$S,T,S \cap T = \varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f_i$</span> 表示 <span class="markdown-them-math-inline">$\sum b_k = i,k\in S$</span> 对答案的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g_i$</span> 表示 <span class="markdown-them-math-inline">$\sum b_k = i,k\in T$</span> 对答案的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$h_i$</span> 表示 <span class="markdown-them-math-inline">$\sum b_k = i,k\in S \cup T$</span> 对答案的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么显然有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$g_n = \sum _ {i = 0} ^ n \dbinom{n}{i} f_i \times g_{n - i}$$</div><p>因为 <span class="markdown-them-math-inline">$f_i$</span> 和 <span class="markdown-them-math-inline">$g_{n - i}$</span> 联合起来的贡献是它们的乘积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且由于操作有序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以将 <span class="markdown-them-math-inline">$n$</span> 次操作分配到它们还导致要乘上 <span class="markdown-them-math-inline">$\binom{n}{i}$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>很明显<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个式子可以用 <span class="markdown-them-math-inline">$\rm EGF$</span> 来拟合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$\hat{F}_i(x) = \sum _ j (a_i - j) \frac{x ^ j}{j!}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么答案的生成函数为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    \hat{F}(x) &amp;= \prod _ i F_i(x)\\    &amp;= \prod _ i \left( \sum _ j (a_i - j) \frac{x ^ j}{j!} \right)\\    &amp;= \prod _ i \left( a_i \sum _ j \frac{x ^ j}{j!} - \sum _ {j} \frac{x ^ {j + 1}}{j!} \right)\\    &amp;= \prod _ i (a_i - x)e ^ x\\    &amp;= e ^ {nx} \prod _ i (a_i - x)\end{aligned}$$</div><p><span class="markdown-them-math-inline">$\prod _ i (a_i - x)$</span> 直接分治乘可以做到 <span class="markdown-them-math-inline">$\Theta(n \log ^ 2 n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$e ^ {nx}$</span> 的系数可以直接求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于 <span class="markdown-them-math-inline">$\prod _ i (a_i - x)$</span> 的最高次数为 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以直接枚举计算即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log ^2 n).$</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「省选联考 2021」矩阵游戏</title>
      <link href="/2023/06/24/sheng-xuan-lian-kao-2021-ju-zhen-you-xi/"/>
      <url>/2023/06/24/sheng-xuan-lian-kao-2021-ju-zhen-you-xi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p/3500">[省选联考 2021] 矩阵游戏</a> 解题报告及代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="$\rm-sol$"><span class="markdown-them-math-inline">$\rm Sol.$</span></h2><p>首先可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若不考虑 <span class="markdown-them-math-inline">$a_i \leqslant 10 ^ 6$</span> 的限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么构造一组合法解是容易的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>同时可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果对一行或一列进行 <span class="markdown-them-math-inline">$+1, -1, +1, -1, \cdots $</span> 操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么得到的 <span class="markdown-them-math-inline">$a_i$</span> 还是合法的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$c_i$</span> 和 <span class="markdown-them-math-inline">$d_i$</span> 分别表示每行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每列进行了多少次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下面两个矩阵即为 <span class="markdown-them-math-inline">$a_{i, j}$</span> 得到真实值需要加上修改值的系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{bmatrix}+1 &amp; -1 &amp; +1 &amp; -1 \\+1 &amp; -1 &amp; +1 &amp; -1 \\+1 &amp; -1 &amp; +1 &amp; -1 \\+1 &amp; -1 &amp; +1 &amp; -1 \\\end{bmatrix}\rm and\begin{bmatrix}+1 &amp; +1 &amp; +1 &amp; +1 \\-1 &amp; -1 &amp; -1 &amp; -1 \\+1 &amp; +1 &amp; +1 &amp; +1 \\-1 &amp; -1 &amp; -1 &amp; -1 \\\end{bmatrix}$$</div><p>列出需要满足的方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$ 0 \leqslant a_{i, j} \pm c_i \pm d_j \leqslant 10 ^ 6$$</div><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若将 <span class="markdown-them-math-inline">$c_i$</span> 和 <span class="markdown-them-math-inline">$d_i$</span> 作为未知数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能会出现 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>求和约束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是难以解决的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>观察到发生这个问题的本质是因为在两个矩阵的相同位置出现了相同的符号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑重构矩阵<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{bmatrix}+1 &amp; -1 &amp; +1 &amp; -1 \\-1 &amp; +1 &amp; -1 &amp; +1 \\+1 &amp; -1 &amp; +1 &amp; -1 \\-1 &amp; +1 &amp; -1 &amp; +1 \\\end{bmatrix}\rm and\begin{bmatrix}-1 &amp; +1 &amp; -1 &amp; +1 \\+1 &amp; -1 &amp; +1 &amp; -1 \\-1 &amp; +1 &amp; -1 &amp; +1 \\+1 &amp; -1 &amp; +1 &amp; -1 \\\end{bmatrix}$$</div><p>于是此时就可以使用差分约束的常规求解方式了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>使用 <span class="markdown-them-math-inline">$\rm SPFA$</span> 的时间复杂度为 <span class="markdown-them-math-inline">$\Theta[n ^ 2 (n + m)]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>常数很小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以通过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="$\rm-code$"><span class="markdown-them-math-inline">$\rm Code$</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">300</span> + <span class="hljs-number">10</span>, M = N * N &lt;&lt; <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> T, n, m, a[N][N], b[N][N];<span class="hljs-keyword">int</span> last[N &lt;&lt; <span class="hljs-number">1</span>], to[M], Next[M], W[M], tot;<span class="hljs-keyword">int</span> vis[N &lt;&lt; <span class="hljs-number">1</span>], dis[N &lt;&lt; <span class="hljs-number">1</span>], num[N &lt;&lt; <span class="hljs-number">1</span>];queue &lt;<span class="hljs-keyword">int</span>&gt; Q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Link</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;    to[++tot] = v, W[tot] = w, Next[tot] = last[u], last[u] = tot;&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;T); <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);        tot = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + m; i++)            last[i] = num[i] = <span class="hljs-number">0</span>, vis[i] = <span class="hljs-literal">false</span>, dis[i] = <span class="hljs-number">1e9</span>;        <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) Q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt;= m; j++)                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;b[i][j]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) a[<span class="hljs-number">1</span>][i] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt;= m; j++)                a[i][j] = b[i][j] - a[i - <span class="hljs-number">1</span>][j] - a[i][j - <span class="hljs-number">1</span>] - a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)                <span class="hljs-keyword">if</span> ((i + j) &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">Link</span>(n + j, i, a[i][j]), <span class="hljs-built_in">Link</span>(i, n + j, <span class="hljs-number">1e6</span> - a[i][j]);                <span class="hljs-keyword">else</span> <span class="hljs-built_in">Link</span>(i, n + j, a[i][j]), <span class="hljs-built_in">Link</span>(n + j, i, <span class="hljs-number">1e6</span> - a[i][j]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + m; i++) <span class="hljs-built_in">Link</span>(<span class="hljs-number">0</span>, i, <span class="hljs-number">0</span>);        dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, Q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>), vis[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;            <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();            <span class="hljs-keyword">if</span> (++num[u] &gt; <span class="hljs-number">10</span>) &#123; flag = <span class="hljs-literal">true</span>; <span class="hljs-keyword">break</span>; &#125;            Q.<span class="hljs-built_in">pop</span>(), vis[u] = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = last[u]; i; i = Next[i])                <span class="hljs-keyword">if</span> (dis[to[i]] &gt; dis[u] + W[i]) &#123;                    dis[to[i]] = dis[u] + W[i];                    <span class="hljs-keyword">if</span> (!vis[to[i]]) Q.<span class="hljs-built_in">push</span>(to[i]), vis[to[i]] = <span class="hljs-literal">true</span>;                &#125;        &#125;        <span class="hljs-keyword">if</span> (flag) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">continue</span>; &#125;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;                <span class="hljs-keyword">if</span> ((i + j) &amp; <span class="hljs-number">1</span>) a[i][j] += dis[n + j] - dis[i];                <span class="hljs-keyword">else</span> a[i][j] += dis[i] - dis[n + j];                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, a[i][j]);            &#125;            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「省选联考 2021」图函数</title>
      <link href="/2023/06/24/sheng-xuan-lian-kao-2021-tu-han-shu/"/>
      <url>/2023/06/24/sheng-xuan-lian-kao-2021-tu-han-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p/3501">[省选联考 2021] 图函数</a> 解题报告及代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="$\rm-sol$"><span class="markdown-them-math-inline">$\rm Sol.$</span></h2><p>首先考虑分析 <span class="markdown-them-math-inline">$f(u, G)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以观察出一些性质 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>会产生贡献的 <span class="markdown-them-math-inline">$v$</span> 必须满足 <span class="markdown-them-math-inline">$v &lt; u.$</span></p></li><li><p><span class="markdown-them-math-inline">$v$</span> 与 <span class="markdown-them-math-inline">$u$</span> 会产生贡献当且仅当 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$v$</span> 可以仅通过大于 <span class="markdown-them-math-inline">$v$</span> 的点互达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><blockquote><p><span class="markdown-them-math-inline">$\rm Proof: $</span></p><ul><li>当 <span class="markdown-them-math-inline">$v &gt; u$</span> 时 <span class="markdown-them-math-inline">$u$</span> 自己都已经删掉了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>肯定不能产生贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li><img src="https://s1.ax1x.com/2022/03/06/bDTc79.png" alt=""></li></ul><p>如上图所示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们不妨设 <span class="markdown-them-math-inline">$u \to v$</span> 的路径上必须经过 <span class="markdown-them-math-inline">$x(x &lt; u)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$x$</span> 和 <span class="markdown-them-math-inline">$u$</span> 一定相互可达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$x$</span> 会在统计 <span class="markdown-them-math-inline">$v$</span> 的答案之前被删掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>于是我们可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若定义两点 <span class="markdown-them-math-inline">$(u, v)$</span> 有贡献当且仅当 <span class="markdown-them-math-inline">$u &gt; v$</span> 且 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$v$</span> 之间可以通过大于 <span class="markdown-them-math-inline">$v$</span> 的点相互到达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$h(G)$</span> 就是在求解 <span class="markdown-them-math-inline">$G$</span> 中所有点对的贡献之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们考虑 <span class="markdown-them-math-inline">$\rm Floyd$</span> 算法的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实际上就是在不断求解如果只经过当前已经枚举的这些中转点 <span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有哪些 <span class="markdown-them-math-inline">$u$</span> 可以走到 <span class="markdown-them-math-inline">$v.$</span> 于是求解 <span class="markdown-them-math-inline">$h(G)$</span> 只需要从大到小枚举中转点 <span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并在 <span class="markdown-them-math-inline">$\rm Floyd$</span> 的过程中记录下当前 <span class="markdown-them-math-inline">$v = k - 1$</span> 的答案即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>进一步观察发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们按照编号从大到小将边加入图 <span class="markdown-them-math-inline">$G$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么必然可以找到一个分界点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$v$</span> 恰好变为有贡献的点对<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个分界点就是 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$v$</span> 可以相互到达的路径上编号最小的边的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求解这个最大值是简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要将初始矩阵修改成边的编号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方程改写为 <span class="markdown-them-math-inline">$f_{u, v} = \max\{f_{u, v}, \min\{f_{u, k}, f_{k, v}\}\}$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最后用差分维护一下就可以得到最终答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n ^ 3 + m)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>常数很小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写得好的话可以通过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><hr><p>为了进一步优化复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们摈弃之前使用 <span class="markdown-them-math-inline">$\rm Floyd$</span> 的想法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑按编号从大到小枚举所有的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现每对点 <span class="markdown-them-math-inline">$(u, v)(u &gt; v)$</span> 都会有一个成为有贡献的点对的分界点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先计算 <span class="markdown-them-math-inline">$v$</span> 可以到达 <span class="markdown-them-math-inline">$u$</span> 的分界点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> <span class="markdown-them-math-inline">$u$</span> 到 <span class="markdown-them-math-inline">$v$</span> 的分界点可以通过在反图上进行同样的操作来计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有两个显然的性质 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>有贡献的点对数量最多 <span class="markdown-them-math-inline">$n ^ 2$</span> 量级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>在加边的过程中有贡献的点对数量不减<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>于是考虑计算每条边加入后有贡献的点对的增量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><img src="https://s1.ax1x.com/2022/03/06/brP9Ds.png" alt=""></p><p>如上图所示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设当前加入的边为 <span class="markdown-them-math-inline">$x \to y$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$u_1, u_2, u_3, \cdots $</span> 和 <span class="markdown-them-math-inline">$v_1, v_2, v_3, \cdots$</span> 分别为能到达 <span class="markdown-them-math-inline">$x$</span> 的点和 <span class="markdown-them-math-inline">$y$</span> 能到的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑用 <span class="markdown-them-math-inline">$\rm bitset$</span> 记录某个点能直接到达的所有点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>能到达的所有点和能到达这个点的所有点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不妨分别设它们为 <span class="markdown-them-math-inline">$E_u, S_u$</span> 和 <span class="markdown-them-math-inline">$T_u.$</span></p><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若点对 <span class="markdown-them-math-inline">$(u, v)$</span> 因 <span class="markdown-them-math-inline">$x \to y$</span> 而增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要满足 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><span class="markdown-them-math-inline">$u$</span> 在加入 <span class="markdown-them-math-inline">$x \to y$</span> 之前不能到达 <span class="markdown-them-math-inline">$y.$</span></li><li><span class="markdown-them-math-inline">$u$</span> 在加入 <span class="markdown-them-math-inline">$x \to y$</span> 之前要能到达 <span class="markdown-them-math-inline">$x.$</span></li><li>路径上所有点的编号都不小于 <span class="markdown-them-math-inline">$u.$</span></li></ul><p>首先前两个条件可以通过 <span class="markdown-them-math-inline">$T_x \cap (U - T_y)$</span> 简单地得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑枚举集合中的所有点作为 <span class="markdown-them-math-inline">$u$</span> 从 <span class="markdown-them-math-inline">$y$</span> 开始遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>遍历的过程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每一步要将 <span class="markdown-them-math-inline">$E_v \cap (U - S_u)$</span> 中所有编号大于 <span class="markdown-them-math-inline">$u$</span> 的点作为下一个遍历的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还要记得随时更新 <span class="markdown-them-math-inline">$S_u.$</span></p><p>考虑这样做的复杂度为什么是对的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为每一步都会走到一个合法的 <span class="markdown-them-math-inline">$v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以答案每一步会增加 <span class="markdown-them-math-inline">$1.$</span> 并且每走一步都需要计算 <span class="markdown-them-math-inline">$E_v \cap (U - S_u)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其时间复杂度为 <span class="markdown-them-math-inline">$\Theta(\frac{n}{\omega}).$</span> 另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每加入一条边都需要计算 <span class="markdown-them-math-inline">$T_x \cap (U - T_y)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其时间复杂度也为 <span class="markdown-them-math-inline">$\Theta(\frac{n}{\omega}).$</span> 于是总时间复杂度为 <span class="markdown-them-math-inline">$\Theta(\frac{n ^ 3 + nm}{\omega})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="$\rm-code$"><span class="markdown-them-math-inline">$\rm Code$</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, m, E[N][N], ans[M], Eik, tmp;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u, v, i = <span class="hljs-number">1</span>; i &lt;= m; i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v), E[u][v] = i;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = n; k &gt;= <span class="hljs-number">1</span>; k--) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span> (E[i][k]) &#123;            <span class="hljs-keyword">int</span> j;             <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j + <span class="hljs-number">7</span> &lt;= n; j += <span class="hljs-number">8</span>) &#123;                Eik = E[i][k];                tmp = Eik &lt; E[k][j] ? Eik : E[k][j];                E[i][j] = E[i][j] &gt; tmp ? E[i][j] : tmp;                tmp = Eik &lt; E[k][j + <span class="hljs-number">1</span>] ? Eik : E[k][j + <span class="hljs-number">1</span>];                E[i][j + <span class="hljs-number">1</span>] = E[i][j + <span class="hljs-number">1</span>] &gt; tmp ? E[i][j + <span class="hljs-number">1</span>] : tmp;                tmp = Eik &lt; E[k][j + <span class="hljs-number">2</span>] ? Eik : E[k][j + <span class="hljs-number">2</span>];                E[i][j + <span class="hljs-number">2</span>] = E[i][j + <span class="hljs-number">2</span>] &gt; tmp ? E[i][j + <span class="hljs-number">2</span>] : tmp;                tmp = Eik &lt; E[k][j + <span class="hljs-number">3</span>] ? Eik : E[k][j + <span class="hljs-number">3</span>];                E[i][j + <span class="hljs-number">3</span>] = E[i][j + <span class="hljs-number">3</span>] &gt; tmp ? E[i][j + <span class="hljs-number">3</span>] : tmp;                tmp = Eik &lt; E[k][j + <span class="hljs-number">4</span>] ? Eik : E[k][j + <span class="hljs-number">4</span>];                E[i][j + <span class="hljs-number">4</span>] = E[i][j + <span class="hljs-number">4</span>] &gt; tmp ? E[i][j + <span class="hljs-number">4</span>] : tmp;                tmp = Eik &lt; E[k][j + <span class="hljs-number">5</span>] ? Eik : E[k][j + <span class="hljs-number">5</span>];                E[i][j + <span class="hljs-number">5</span>] = E[i][j + <span class="hljs-number">5</span>] &gt; tmp ? E[i][j + <span class="hljs-number">5</span>] : tmp;                tmp = Eik &lt; E[k][j + <span class="hljs-number">6</span>] ? Eik : E[k][j + <span class="hljs-number">6</span>];                E[i][j + <span class="hljs-number">6</span>] = E[i][j + <span class="hljs-number">6</span>] &gt; tmp ? E[i][j + <span class="hljs-number">6</span>] : tmp;                tmp = Eik &lt; E[k][j + <span class="hljs-number">7</span>] ? Eik : E[k][j + <span class="hljs-number">7</span>];                E[i][j + <span class="hljs-number">7</span>] = E[i][j + <span class="hljs-number">7</span>] &gt; tmp ? E[i][j + <span class="hljs-number">7</span>] : tmp;            &#125;             <span class="hljs-keyword">for</span> ( ; j &lt;= n; ++j) E[i][j] = <span class="hljs-built_in">max</span>(E[i][j], <span class="hljs-built_in">min</span>(E[i][k], E[k][j]));        &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = k + <span class="hljs-number">1</span>; u &lt;= n; u++)            ans[<span class="hljs-built_in">min</span>(E[u][k], E[k][u]) - <span class="hljs-number">1</span>]++;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &gt;= <span class="hljs-number">0</span>; i--) ans[i] += ans[i + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, ans[i] + n);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「省选联考 2021」卡牌游戏</title>
      <link href="/2023/06/24/sheng-xuan-lian-kao-2021-qia-pai-you-xi/"/>
      <url>/2023/06/24/sheng-xuan-lian-kao-2021-qia-pai-you-xi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/p/3499">[省选联考 2021] 卡牌游戏</a> 解题报告及代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="$\rm-sol$"><span class="markdown-them-math-inline">$\rm Sol$</span></h2><h3 id="法一">法一</h3><p>可以证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若进行了操作 <span class="markdown-them-math-inline">$a_i \to b_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$\forall j &lt; i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>操作 <span class="markdown-them-math-inline">$a_j \to b_j$</span> 都进行了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为如果存在 <span class="markdown-them-math-inline">$j &lt; i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$a_i \to b_i$</span> 执行了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但 <span class="markdown-them-math-inline">$a_j \to b_j$</span> 没执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$a_i \to b_i$</span> 执行就没有意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 <span class="markdown-them-math-inline">$a_j$</span> 还是会作为最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>同理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以证明操作序列也是后缀连续的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是我们可以枚举操作了的前缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后预处理出 <span class="markdown-them-math-inline">$b$</span> 序列后缀最大值等信息即可计算答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n).$</span></p><h3 id="法二">法二</h3><p>容易发现答案满足可二分性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是二分答案 <span class="markdown-them-math-inline">$\rm mid.$</span></p><p>如果选定了答案区间的左端点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么右端点可以容易地确定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是问题转化成了一个前后缀 <span class="markdown-them-math-inline">$\rm RMQ.$</span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n).$</span></p><h3 id="法三">法三</h3><p>考虑将 <span class="markdown-them-math-inline">$a_i$</span> 和 <span class="markdown-them-math-inline">$b_i$</span> 全部取出来排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现答案是删去一些数后的最大值减最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是双指针维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记录当前删去了多少个 <span class="markdown-them-math-inline">$a_i$</span> 和一张牌的 <span class="markdown-them-math-inline">$a_i$</span> 和 <span class="markdown-them-math-inline">$b_i$</span> 是否同时被删掉即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为要排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="$\rm-code$"><span class="markdown-them-math-inline">$\rm Code$</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, m, num, ans = INT_MAX;pair &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; a[N];<span class="hljs-keyword">bool</span> tag[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">idx</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span> </span>&#123;    <span class="hljs-keyword">return</span> a[pos].second - (a[pos].second &lt;= n ? <span class="hljs-number">0</span> : n);&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span> </span>&#123;    <span class="hljs-keyword">if</span> (a[pos].second &lt;= n &amp;&amp; num &gt;= m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (tag[<span class="hljs-built_in">idx</span>(pos)]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span> </span>&#123;    <span class="hljs-keyword">if</span> (a[pos].second &lt;= n) num++;    tag[<span class="hljs-built_in">idx</span>(pos)] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rev</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span> </span>&#123;    <span class="hljs-keyword">if</span> (a[pos].second &lt;= n) num--;    tag[<span class="hljs-built_in">idx</span>(pos)] = <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n &lt;&lt; <span class="hljs-number">1</span>; i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i].first), a[i].second = i;    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2</span> * n;    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>(r)) <span class="hljs-built_in">del</span>(r), r--;    <span class="hljs-keyword">while</span> (r &lt;= n &lt;&lt; <span class="hljs-number">1</span>) &#123;        ans = <span class="hljs-built_in">min</span>(ans, a[r].first - a[l].first);        <span class="hljs-keyword">if</span> (a[l].second &lt;= n) <span class="hljs-keyword">while</span> (num &gt;= m &amp;&amp; r &lt;= <span class="hljs-number">2</span> * n) <span class="hljs-built_in">rev</span>(r + <span class="hljs-number">1</span>), r++;        <span class="hljs-keyword">while</span> (tag[<span class="hljs-built_in">idx</span>(l)] &amp;&amp; r &lt;= <span class="hljs-number">2</span> * n) <span class="hljs-built_in">rev</span>(r + <span class="hljs-number">1</span>), r++;        <span class="hljs-built_in">del</span>(l), l++;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「杂项」复杂度分析</title>
      <link href="/2023/06/24/za-xiang-fu-za-du-fen-xi/"/>
      <url>/2023/06/24/za-xiang-fu-za-du-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>本文讲一些算法竞赛中的复杂度分析技巧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>暂时只有主定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还有规约和势能分析等内容待更<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="主定理">主定理</h2><p>主定理 <span class="markdown-them-math-inline">$\rm (Master~Theorem)$</span> 被用来求解一类递归算法的时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设有递推式形如:</p><div class="markdown-them-math-block">$$T(n) = aT\left(\frac{n}{b}\right) + f(n)$$</div><p>上式的含义是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存在一个规模为 <span class="markdown-them-math-inline">$n$</span> 的问题可以被划分成 <span class="markdown-them-math-inline">$a$</span> 个规模为 <span class="markdown-them-math-inline">$\frac{n}{b}$</span> 的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且将它们合并的运算复杂度为 <span class="markdown-them-math-inline">$f(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>那么根据主定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$T(n)= \begin{cases}\Theta\left(n^{\log _{b} a}\right) &amp; f(n)=O\left(n^{\log _{b} a-\epsilon}\right) \\ \Theta(f(n)) &amp; f(n)=\Omega\left(n^{\log _{b} a+\epsilon}\right) \\ \Theta\left(n^{\log _{b} a} \log ^{k+1} n\right) &amp; f(n)=\Theta\left(n^{\log _{b} a} \log ^{k} n\right), k \geq 0\end{cases}$$</div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「杂项」反悔贪心</title>
      <link href="/2023/06/24/za-xiang-fan-hui-tan-xin/"/>
      <url>/2023/06/24/za-xiang-fan-hui-tan-xin/</url>
      
        <content type="html"><![CDATA[<p>反悔贪心学习笔记及一些经典例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="算法简介">算法简介</h2><p>反悔贪心是对贪心策略的一种优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有些时候贪心策略是错的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但如果可以撤销之前的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就会变为正确的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>反悔贪心主要有两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一种是反悔堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即将之前没有选择的操作加入一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>堆中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>保证每次取出的堆顶都是当前没有选择的策略中最优的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若由于当前操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将其替换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>还有一种是反悔自动机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以设计一个自动机来决策当前的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有一种观点认为反悔贪心的本质是贪心模拟费用流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我认为是有一定道理的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种观点也有利于解释反悔贪心的正确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="经典例题">经典例题</h2><h3 id="[usaco09open]-work scheduling g">[USACO09OPEN] Work Scheduling G</h3><p>反悔贪心板子题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>按任务按截止时间排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若当前这个工作做得了<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即已经做的件数小于这个工作的截止日期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么直接做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并把它的价值放进优先队列中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若当前这个工作没时间做了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现如果把前面一个工作去除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个工作就做得了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是对比小根堆顶的价值与他的价值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>谁大就保留谁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[jsoi2007]-建筑抢修">[JSOI2007] 建筑抢修</h3><p>反悔贪心板子题 <span class="markdown-them-math-inline">$\times 2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现每个建筑的贡献都是一样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>按建筑的 <span class="markdown-them-math-inline">$T2$</span> 排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个个枚举<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若当前建筑可以修<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即之前已经选的建筑的 <span class="markdown-them-math-inline">$T1$</span> 之和加上当前这个建筑的 <span class="markdown-them-math-inline">$T1$</span> 不大于当前建筑的 <span class="markdown-them-math-inline">$T2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就直接将这个建筑的 <span class="markdown-them-math-inline">$T1$</span> 加上并放进优先队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并把答案 <span class="markdown-them-math-inline">$+1.$</span> 若不能修<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑到价值一样的情况下最小化总修理时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么将大根堆的堆顶取出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若其大于当前点的 <span class="markdown-them-math-inline">$T1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新花费总时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[p2107]-小 z 的 ak 计划">[P2107] 小 Z 的 AK 计划</h3><p>反悔贪心板子题 <span class="markdown-them-math-inline">$\times 3$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先按机房位置升序考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设你有一种到了机房就必须 <span class="markdown-them-math-inline">$\rm AK$</span> 的欲望<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>实际上是因为如果不 <span class="markdown-them-math-inline">$\rm AK$</span> 这个机房<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就没必要走到这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是在之前停下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么如果当前的总用时加上 <span class="markdown-them-math-inline">$\rm AK$</span> 这个机房的用时不到 <span class="markdown-them-math-inline">$m$</span> 的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>你就可以直接 <span class="markdown-them-math-inline">$\rm AK$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将这个机房的 <span class="markdown-them-math-inline">$\rm AK$</span> 用时加入大根堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若当前时间不够<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就不断弹出堆顶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到剩下的时间足够 <span class="markdown-them-math-inline">$\rm AK.$</span> 一边枚举一边记录当前最优答案即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[cf865d]-buy low sell high">[CF865D] Buy Low Sell High</h3><p>首先考虑一个贪心<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每个数选择它后面第一个比他大并且还没被选择的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现这样是错的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\rm Hack$</span> 数据如下 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre></div><p>于是我们考虑给上面那个贪心加上反悔操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次将当前值放入小根堆中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若当前枚举的这个数大于小根堆堆顶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就将其卖掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>获得 <code>a[i] - Q.top()</code> 的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了之后能够反悔<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们还要将它也加入堆中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果后面还有一个数将其卖出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么其等价于直接将此时的堆顶卖出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样一来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们认为某个点要卖出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么它就要入堆两次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[国家集训队]-种树">[国家集训队] 种树</h3><p>考虑选了一个数以后会发生什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它两边的数都不能选了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是考虑在选了一个点之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把它两边的数标为不能选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后在原处加入一个权值为 <span class="markdown-them-math-inline">$a_{i-1}+a_{i+1}-a_i$</span> 的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每次取最大的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若已标为不能选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就跳过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则选他<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将两边的点删去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新链表顺序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>容易证明这样做是对的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且可以用优先队列维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构」线段树</title>
      <link href="/2023/06/24/shu-ju-jie-gou-xian-duan-shu/"/>
      <url>/2023/06/24/shu-ju-jie-gou-xian-duan-shu/</url>
      
        <content type="html"><![CDATA[<p>线段树是算法竞赛中最常见的数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有很多分支<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>非常重要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="经典例题">经典例题</h2><h3 id="[lg5490]-扫描线">[LG5490] 扫描线</h3><p>扫描线模板题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从小到大枚举横线的纵坐标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举到矩形下界就给这条边的左右端点构成的区间 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则 <span class="markdown-them-math-inline">$-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用线段树维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前线段树有值的结点个数就是这个纵坐标的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>怎么维护线段树中不为 <span class="markdown-them-math-inline">$0$</span> 的位置数量呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>我们发现在做扫描线的时候权值不会小于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们考虑维护区间最小值和最小值的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个在合并的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果左右儿子的最小值相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将其最小值数量加起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则继承最小值更小的那个的最小值数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>本题还需要动态开点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以需要维护区间内有效点的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[spoj]-gss-i">[SPOJ] GSS-I</h3><p>先求出前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现答案为区间最大值减最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但需要满足最小值在最大值右边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对线段树的每个节点维护最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最大值和答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现答案可以从两棵子树的答案更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以更新为右子树中的最大值减去左子树中的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是直接用线段树即可维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[spoj]-gss-iii">[SPOJ] GSS-III</h3><p>发现这题是带修版的 <span class="markdown-them-math-inline">$\rm GSS1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是由于前缀和无法动态修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑直接维护区间和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>显然要维护区间和以及最大子段和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现最大子段和需要通过左儿子的最大后缀和和右儿子的最大前缀和更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是再记最大前后缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而最大前后缀和是可以通过区间和和子节点的最大前后缀和计算的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是这题就可以用线段树做了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[spoj]-gss-iv">[SPOJ] GSS-IV</h3><p>我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个区间内如果全都是 <span class="markdown-them-math-inline">$1$</span> 或 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么对它开方是没有意义的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以记录最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果最大值为 <span class="markdown-them-math-inline">$0$</span> 或 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么直接跳过这个区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现这样做每个点最多被修改 <span class="markdown-them-math-inline">$7$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[spoj]-gss-v">[SPOJ] GSS-V</h3><p>我们发现这个问题和 <span class="markdown-them-math-inline">$\rm GSS-I$</span> 很像<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>唯一的区别是左右两边限定了区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现如果两个区间不重合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那就是右区间最大值减左区间最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>若两区间重合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令从左到右三个区域分别为 <span class="markdown-them-math-inline">$\rm I,II,III$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>首先用 <span class="markdown-them-math-inline">$\rm \max\{II\cup III\}-\min\{I\}$</span> 更新答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后用 <span class="markdown-them-math-inline">$\rm \max\{III\}-\min\{I\cup II\}$</span> 更新答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后只剩下两个端点都在 <span class="markdown-them-math-inline">$\rm II$</span> 内的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个就是 <span class="markdown-them-math-inline">$\rm GSS-I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[lg4198]-楼房重建">[LG4198] 楼房重建</h3><p>首先肯定将每个楼房的信息转化为斜率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然要维护区间最大值和从这个区间左端点开始能看到多少栋楼<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>现在考虑将左右区间合并<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然要先将左区间的答案加上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后考虑右区间能看到多少个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li>如果左区间的最大值小于右区间的左区间的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么肯定对右区间的右区间没有影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将右区间的右区间的答案加上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>左区间递归<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>如果左区间的最大值大于右区间的左区间的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么右区间的左区间肯定一个都看不到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接将右区间的右区间递归下去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>单次合并时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log ^2n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\quad\rm PS:$</span> 这题有个坑点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算右区间的右儿子的答案的时候不能写成 <code>ans[RS]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是要写成 <code>ans[p] - ans[LS]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为右儿子的答案可能会被左儿子挡掉一些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些还是不能算进去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[lg1502]-窗口的星星">[LG1502] 窗口的星星</h3><p>考虑将每颗行星变成一个带权矩形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现最大亮度和就是最大矩形交的权值之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑用扫描线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护区间最大值即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>坑点 <span class="markdown-them-math-inline">$1:$</span> 由于边界上的点不用算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以矩形右上角为 <span class="markdown-them-math-inline">$(x+w-1,y+h-1).$</span></p><p>坑点 <span class="markdown-them-math-inline">$2:$</span> 我们在每次修改过后都统计了一遍答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以当线段纵坐标相同的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删除要排在前面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>防止统计了一个不合法的大的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[cf240f]-torcoder">[CF240F] TorCoder</h3><p>考虑一次操作干了什么事情<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若存在一个以上字母出现了奇数次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则无法重排<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则将出现奇数次的字母放在最中间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将所有字母按照从小到大再从大到小的顺序放在这个字母的两边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是可以对每个字母开一颗线段树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护区间赋值操作和区间求数量操作即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n|\Sigma|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[cf242e]-xor on segment">[CF242E] XOR on Segment</h3><p>考虑对每一位开一颗线段树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>问题就变成了维护一个 <span class="markdown-them-math-inline">$0/1$</span> 序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>支持区间取反和区间求和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log^2n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[cf414c]-mashmokh and reverse operation">[CF414C] Mashmokh and Reverse Operation</h3><p>我们发现这个题目中区间的结构很像一颗线段树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑它的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>发现交换一个翻转一个区间等价于将它的两个子区间交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后递归操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而一个区间的逆序对数量为两个子区间之间的逆序对数量加上两个子区间内部的逆序对数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是考虑维护每一层每一个结点的两个子区间之间的逆序对数量之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>修改操作就变成了将某一层下面的所有区间翻转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于层数只有 <span class="markdown-them-math-inline">$20$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以直接维护每一层是否被翻转即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求当前的答案只需要预处理每一层的所有节点的两个子区间之间的答案之和即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现一层区间一定是一起翻转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是每一层只有两种状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别预处理即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta[(2^n+m)n]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[cf446c]-dzy loves fibonacci numbers">[CF446C] DZY Loves Fibonacci Numbers</h3><p>我们知道 <span class="markdown-them-math-inline">$F_{n}=\frac{\sqrt{5}}{5}\left[\left(\frac{1+\sqrt{5}}{2}\right)^{n}-\left(\frac{1-\sqrt{5}}{2}\right)^{n}\right].$</span></p><p>于是可以发现只需要分别维护两个序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在一个序列中公比相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>故我们只需要维护首项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后面的数可以直接算出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下传的时候给左子区间直接加上这个首项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>右子区间加首项乘上 <span class="markdown-them-math-inline">$q^{\frac{r-l+1}{2}}$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[cf522d]-closest equals">[CF522D] Closest Equals</h3><p>我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果记 <span class="markdown-them-math-inline">$p_i$</span> 表示距离 <span class="markdown-them-math-inline">$i$</span> 最近的在 <span class="markdown-them-math-inline">$i$</span> 之前的与 <span class="markdown-them-math-inline">$i$</span> 颜色相同的点与 <span class="markdown-them-math-inline">$i$</span> 的距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么对于一个询问 <span class="markdown-them-math-inline">$[l,r]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其答案为所有满足 <span class="markdown-them-math-inline">$i-p_i\geqslant l$</span> 和 <span class="markdown-them-math-inline">$i\leqslant r$</span> 的点中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p_i$</span> 最小的那个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是考虑将坐标离散化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将询问离线下来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按右端点排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个个枚举 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$p_i\not =0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将 <span class="markdown-them-math-inline">$C_{i-p_i}$</span> 的值与 <span class="markdown-them-math-inline">$p_i$</span> 取 <span class="markdown-them-math-inline">$\min$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$C$</span> 中区间 <span class="markdown-them-math-inline">$[l,r]$</span> 内的最小值就是这个区间的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>单点修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>区间查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以使用线段树维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现 <span class="markdown-them-math-inline">$[l,r]$</span> 的答案和 <span class="markdown-them-math-inline">$[l,n]$</span> 的答案是相同的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是也可以使用树状数组维护后缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构」数列分块</title>
      <link href="/2023/06/24/shu-ju-jie-gou-shu-lie-fen-kuai/"/>
      <url>/2023/06/24/shu-ju-jie-gou-shu-lie-fen-kuai/</url>
      
        <content type="html"><![CDATA[<p>分块学习笔记及一些经典例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="基本思想">基本思想</h2><p>考虑一些在序列上的区间操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如区间加和区间求和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>直接暴力做单次操作复杂度是 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(qn)$</span>.</p><p>如果将序列分成 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每块长度为 <span class="markdown-them-math-inline">$\sqrt{n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且对每个块维护里面所有元素的和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即可在 <span class="markdown-them-math-inline">$\Theta(\sqrt{n})$</span> 的复杂度内进行单次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>具体实现如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>令块的数量为 <span class="markdown-them-math-inline">$num=\sqrt{n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单个块的长度为 <span class="markdown-them-math-inline">$siz=\lceil\frac{n}{num}\rceil$</span>.</p></li><li><p>记 <span class="markdown-them-math-inline">$bel_i$</span> 表示 <span class="markdown-them-math-inline">$i$</span> 号节点属于第几个块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>可以记录一些题目需要用到的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如 <span class="markdown-them-math-inline">$sum_i$</span> 表示第 <span class="markdown-them-math-inline">$i$</span> 个块内所有元素的和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><h2 id="数列分块入门-9 题">数列分块入门 9 题</h2><h3 id="t1-区间修改, 单点查询">T1 区间修改, 单点查询</h3><p>对每个块维护整块加的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>查询的时候加上即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="t2-区间修改, 查区间内小于某个数的个数">T2 区间修改, 查区间内小于某个数的个数</h3><p>对每个块内的元素排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>区间修改时整块大小顺序不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>散块暴力排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>查询时二分即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n}\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>排序使用归并可以将复杂度优化到 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n\log n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="t3-区间修改, 区间查前驱">T3 区间修改, 区间查前驱</h3><p>同样是排序后在块内二分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只不过是把求比他小的数的数量改成求比它小的数中最大的那个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n}\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>排序使用归并可以将复杂度优化到 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n\log n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="t4-区间修改, 区间求和">T4 区间修改, 区间求和</h3><p>维护每个块的和以及加的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用类似 <span class="markdown-them-math-inline">$\rm T1$</span> 的方法维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="t5-区间开方, 区间求和">T5 区间开方, 区间求和</h3><p>我们发现开方操作是没办法全局维护的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑寻找开方操作的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>观察到每个数被开方很少的次数以后就会变成 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>或者它本身就是 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这部分显然没有贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以直接删去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是对每个块记录一下里面 <span class="markdown-them-math-inline">$1$</span> 的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果全都是 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就不对它进行开方<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否暴力开方即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>求区间和还是维护一下每个块的和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="t6-单点插入, 单点查询">T6 单点插入, 单点查询</h3><p>我们发现暴力做的时候需要将所有数向后移一位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单次时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是考虑分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给每个块预留 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 的剩余空间用来后移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记一下当前块的长度即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>查询的时候每访问一个块就把查询编号减去当前块的长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不难发现这样做单次操作时间复杂度 <span class="markdown-them-math-inline">$\Theta(\sqrt{n}).$</span></p><p>但是我们发现一个问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果插入全在一个块内的话复杂度很快就会变成 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑每进行插入操作 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 次就重构分块即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="t7-区间修改(包含加和乘), 单点查询">T7 区间修改(包含加和乘), 单点查询</h3><p>考虑对每个块记 <span class="markdown-them-math-inline">$\rm add$</span> 和 <span class="markdown-them-math-inline">$\rm mul$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示块内元素的真实值为 <span class="markdown-them-math-inline">$a\times \rm mul+add$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>区间加的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给 <span class="markdown-them-math-inline">$\rm add$</span> 加上 <span class="markdown-them-math-inline">$k$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>区间乘的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不仅需要给 <span class="markdown-them-math-inline">$\rm mul$</span> 乘上 <span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还需要给 <span class="markdown-them-math-inline">$\rm add$</span> 乘上 <span class="markdown-them-math-inline">$k.$</span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="t8-区间查询数的个数并全部修改成这个数">T8 区间查询数的个数并全部修改成这个数</h3><p>我们发现如果询问区间小的话查询和修改都很容易<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果询问区间大的话会把很长一段都变成相同的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果记录一个块是否都是同一个数的话就很容易维护了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>不难发现这样做复杂度是 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n})$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="t9-询问区间最小众数">T9 询问区间最小众数</h3><p>记 <span class="markdown-them-math-inline">$s_{i,j}$</span> 表示前 <span class="markdown-them-math-inline">$i$</span> 个块中 <span class="markdown-them-math-inline">$j$</span> 出现的次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p_{i,j}$</span> 表示第 <span class="markdown-them-math-inline">$i$</span> 个块到第 <span class="markdown-them-math-inline">$j$</span> 个块的众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于一次询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案一定是整块的众数或散块的众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个只需要对比一下即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="经典例题">经典例题</h2><h3 id="[tjoi2009]-开关">[TJOI2009] 开关</h3><p>记 <span class="markdown-them-math-inline">$c_i$</span> 表示第 <span class="markdown-them-math-inline">$i$</span> 盏灯是否开着<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$sum_i$</span> 表示第 <span class="markdown-them-math-inline">$i$</span> 个块中有多少盏灯开着<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$d_i$</span> 表示第 <span class="markdown-them-math-inline">$i$</span> 个块的状态是否整体改变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于区间取反操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>零散操作直接修改 <span class="markdown-them-math-inline">$c_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并根据 <span class="markdown-them-math-inline">$c_i$</span> 和 <span class="markdown-them-math-inline">$d_i$</span> 决定 <span class="markdown-them-math-inline">$sum_i+1$</span> 或 <span class="markdown-them-math-inline">$-1$</span>. 整块操作不用改变 <span class="markdown-them-math-inline">$c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接令 <span class="markdown-them-math-inline">$sum_i=R_i-L_i+1-sum_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且将 <span class="markdown-them-math-inline">$d_i$</span> 取反<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于区间求和操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>零散点求和直接加上 <span class="markdown-them-math-inline">$c_i\oplus d_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整块求和则加上 <span class="markdown-them-math-inline">$sum_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>单次操作复杂度 <span class="markdown-them-math-inline">$\Theta(\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(q\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[lg3396]-哈希冲突">[LG3396] 哈希冲突</h3><p>转化题意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设计一种数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>支持<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>单点修改</p></li><li><p>求从某一点 <span class="markdown-them-math-inline">$pos(pos\leqslant d)$</span> 开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以步长 <span class="markdown-them-math-inline">$d$</span> 遍历数列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求所经过的所有数之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>考虑根号分治<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于 <span class="markdown-them-math-inline">$d\geqslant \sqrt{n}$</span> 的询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接暴力查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于 <span class="markdown-them-math-inline">$d \leqslant \sqrt{n}$</span> 的询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$sum_{i,j}$</span> 表示从 <span class="markdown-them-math-inline">$i(i\leqslant \sqrt{n})$</span> 开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>步长为 <span class="markdown-them-math-inline">$j(j\leqslant \sqrt{n})$</span> 的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>预处理的时候直接枚举计算即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于修改操作 <span class="markdown-them-math-inline">$a[pos]\leftarrow x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先直接在原数列上进行修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再考虑其对 <span class="markdown-them-math-inline">$sum$</span> 数组造成了什么影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>易知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于步长为 <span class="markdown-them-math-inline">$d$</span> 的预处理数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只会对 <span class="markdown-them-math-inline">$sum_{pos\%d,d}$</span> 造成影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是对每个 <span class="markdown-them-math-inline">$d(d\leqslant \sqrt{n})$</span> 修改一下即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单次修改时间复杂度 <span class="markdown-them-math-inline">$\Theta(\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta[(n+q)\sqrt{n}]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[lg2801]-教主的魔法">[LG2801] 教主的魔法</h3><p>考虑分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>记原数列为 <span class="markdown-them-math-inline">$A$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将 <span class="markdown-them-math-inline">$A$</span> 复制一份记为 <span class="markdown-them-math-inline">$B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将 <span class="markdown-them-math-inline">$B$</span> 分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>块内排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于修改操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整块直接打标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>散点修改完后再块内排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样完成操作后仍能保持分块数列的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单次操作复杂度 <span class="markdown-them-math-inline">$\Theta(\sqrt{n}\log\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于查询操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>二分查找第 <span class="markdown-them-math-inline">$i$</span> 个块内有多少个元素不小于 <span class="markdown-them-math-inline">$k-add_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单次操作复杂度 <span class="markdown-them-math-inline">$\Theta(\sqrt{n}\log \sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta[(n+q\sqrt{n})\log n]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑再对复杂度做一些优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令块的大小为 <span class="markdown-them-math-inline">$s$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则修改操作若采用归并排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单次操作复杂度为 <span class="markdown-them-math-inline">$\Theta(s+\frac{n}{s})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时单次查询复杂度为 <span class="markdown-them-math-inline">$\Theta(s+\frac{n}{s}\log s)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当询问次数为 <span class="markdown-them-math-inline">$q$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总复杂度为 <span class="markdown-them-math-inline">$\Theta[q(s+\frac{n}{s}\log n)]\geqslant \Theta(q\sqrt{n\log n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取最小值当且仅当 <span class="markdown-them-math-inline">$s=\sqrt{n\log n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[国家集训队]-排队">[国家集训队] 排队</h3><p>分块 <span class="markdown-them-math-inline">$+$</span> 树状数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑交换两个数 <span class="markdown-them-math-inline">$a_u$</span> 和 <span class="markdown-them-math-inline">$a_v$</span> 的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>显然 <span class="markdown-them-math-inline">$u$</span> 左边的数和 <span class="markdown-them-math-inline">$v$</span> 右边的数没有贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>对于 <span class="markdown-them-math-inline">$a_u$</span> 来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>贡献为 <span class="markdown-them-math-inline">$u$</span> 到 <span class="markdown-them-math-inline">$v$</span> 之间比它大的数的数量减去比它小的数的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>对于 <span class="markdown-them-math-inline">$a_v$</span> 来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>贡献为 <span class="markdown-them-math-inline">$u$</span> 到 <span class="markdown-them-math-inline">$v$</span> 之间比它小的数的数量减去比它大的数的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>至于如何计算 <span class="markdown-them-math-inline">$u$</span> 到 <span class="markdown-them-math-inline">$v$</span> 之间比某个数大或小的值的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分块后散块直接暴力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整块建两颗树状数组即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>令块大小为 <span class="markdown-them-math-inline">$siz$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则时间复杂度为 <span class="markdown-them-math-inline">$\Theta[nlogn+q(siz+\frac{n}{siz}logn)]\geqslant nlogn+q\sqrt{nlogn}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取最小值当且仅当 <span class="markdown-them-math-inline">$siz=\sqrt{nlogn}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时块的数量 <span class="markdown-them-math-inline">$num=\sqrt{\frac{n}{logn}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[lg4168]-violet 蒲公英">[LG4168] Violet 蒲公英</h3><p>考虑分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$s_{i,j}$</span> 表示前 <span class="markdown-them-math-inline">$i$</span> 个块中颜色为 <span class="markdown-them-math-inline">$j$</span> 的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p_{i,j}$</span> 表示第 <span class="markdown-them-math-inline">$i$</span> 个块到第 <span class="markdown-them-math-inline">$j$</span> 个块的众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于一次询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先求出整块中的众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>众数的出现次数和所有在零散块中出现了的颜色的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果零散块中出现的颜色没有一个比众数出现的次数多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么要求的众数就是整块的众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则是出现次数最多的颜色<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{m})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>此时块大小 <span class="markdown-them-math-inline">$B=\frac{n}{\sqrt{m}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构」(带权)并查集</title>
      <link href="/2023/06/24/shu-ju-jie-gou-dai-quan-bing-cha-ji/"/>
      <url>/2023/06/24/shu-ju-jie-gou-dai-quan-bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<p>(带权)并查集 学习笔记及代码实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="用途">用途</h2><p>并查集可以用来维护一类具有传递性的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护形如将 <span class="markdown-them-math-inline">$x$</span> 与 <span class="markdown-them-math-inline">$y$</span> 所在集合合并和询问 <span class="markdown-them-math-inline">$x$</span> 和 <span class="markdown-them-math-inline">$y$</span> 是否在同一个集合的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="实现">实现</h2><h3 id="查询祖先节点">查询祖先节点</h3><p>对于普通并查集来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有路径压缩和按秩合并等优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>路径压缩一般实现如下 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x != fa[x]) fa[x] = <span class="hljs-built_in">Find</span>(fa[x]);    <span class="hljs-keyword">return</span> fa[x];&#125;</code></pre></div><p>按秩合并则取点数小的连向点数大的即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>而对于带边权的并查集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要在路径压缩的时候考虑加上其父亲的权值以维护其到根的差值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有路径压缩优化的带权并查集一般实现如下 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x != fa[x]) &#123;        <span class="hljs-keyword">int</span> mark = fa[x];        fa[x] = <span class="hljs-built_in">Find</span>(fa[x]), val[x] += val[mark];    &#125;    <span class="hljs-keyword">return</span> fa[x];&#125;</code></pre></div><p>由于路径压缩后 <span class="markdown-them-math-inline">$x$</span> 的父亲就是根节点了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以需要记录其父亲到根的总权值并加到它的边权上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果要查询某个点 <span class="markdown-them-math-inline">$x$</span> 到根的权值和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于一次路径压缩以后 <span class="markdown-them-math-inline">$x$</span> 的父亲会变成根<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而此时的 <span class="markdown-them-math-inline">$val_x$</span> 就是路径和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以先调用一次 <code>Find(x)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时的 <span class="markdown-them-math-inline">$val_x$</span> 即为答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="合并两个结点所在集合">合并两个结点所在集合</h3><p>对于普通并查集来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两个集合合并直接将其中一个根节点接到另一个根节点上即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>而对于带权并查集而言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们必须求出需要连接的两个根节点之间连边的权值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这个权值是可以直接确定的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设现在要给 <span class="markdown-them-math-inline">$x\to y$</span> 连一条长度为 <span class="markdown-them-math-inline">$w$</span> 的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$x$</span> 的祖先为 <span class="markdown-them-math-inline">$Rx$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$val_{Rx}=val_y+w-val_x.$</span> 另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 <span class="markdown-them-math-inline">$x$</span> 和 <span class="markdown-them-math-inline">$y$</span> 已经在同一个集合中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且 <span class="markdown-them-math-inline">$val_{Rx}+val_x-val_y\not = w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则这条连边不合法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实现如下 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Merge</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> w)</span> </span>&#123;    <span class="hljs-keyword">int</span> Rx = <span class="hljs-built_in">Find</span>(x), Ry = <span class="hljs-built_in">Find</span>(y);    <span class="hljs-keyword">if</span> (Rx != Ry) fa[Rx] = Ry, val[Rx] = val[y] + w - val[x];    <span class="hljs-keyword">return</span> val[Rx] + val[x] - val[y] == w;&#125;</code></pre></div><h2 id="code">Code</h2><p>带路径压缩和按秩合并优化的普通并查集 :</p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x != fa[x]) fa[x] = <span class="hljs-built_in">Find</span>(fa[x]);    <span class="hljs-keyword">return</span> fa[x];&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Merge</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">int</span> Rx = <span class="hljs-built_in">Find</span>(x), Ry = <span class="hljs-built_in">Find</span>(y);    <span class="hljs-keyword">if</span> (x != y) &#123;        <span class="hljs-keyword">if</span> (pnum[Rx] &lt; pnum[Ry])            fa[Rx] = Ry, pnum[Ry] += pnum[Rx];        <span class="hljs-keyword">else</span> fa[Ry] = Rx, pnum[Rx] += pnum[Ry];    &#125;    <span class="hljs-keyword">return</span> Rx != Ry;&#125;</code></pre></div><p>带路径压缩和按秩合并优化的带权并查集 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x != fa[x]) &#123;        <span class="hljs-keyword">int</span> mark = fa[x];        fa[x] = <span class="hljs-built_in">Find</span>(fa[x]), val[x] += val[mark];    &#125;    <span class="hljs-keyword">return</span> fa[x];&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Merge</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> w)</span> </span>&#123;    <span class="hljs-keyword">int</span> Rx = <span class="hljs-built_in">Find</span>(x), Ry = <span class="hljs-built_in">Find</span>(y);    <span class="hljs-keyword">if</span> (Rx == Ry) <span class="hljs-keyword">return</span> (val[x] - val[y] == w);    <span class="hljs-keyword">if</span> (pnum[Rx] &lt; pnum[Ry])        fa[Rx] = Ry, pnum[Ry] += pnum[Rx], val[Rx] = val[y] + w - val[x];    <span class="hljs-keyword">else</span> fa[Ry] = Rx, pnum[Rx] += pnum[Ry], val[Ry] = val[x] - w - val[y];    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><p>不带任何优化的并查集复杂度是 <span class="markdown-them-math-inline">$\Theta(n ^ 2)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>带路径压缩的并查集时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>期望复杂度 <span class="markdown-them-math-inline">$\Theta(n \alpha(n))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>再加上按秩合并可以做到严格 <span class="markdown-them-math-inline">$\Theta(n \alpha(n))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」线性同余方程</title>
      <link href="/2023/06/24/shu-xue-xian-xing-tong-yu-fang-cheng/"/>
      <url>/2023/06/24/shu-xue-xian-xing-tong-yu-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一种线性同余方程的求解方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><p>考虑如何求解以下方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$ax\equiv 1\pmod b$$</div><p>显然可以转化为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$ax+by=1$$</div><p>有裴蜀定理 :</p><blockquote><p>对于不定方程 <span class="markdown-them-math-inline">$ax+by=c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其有解当且仅当 <span class="markdown-them-math-inline">$\gcd(a,b)|c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>可以发现上述方程有解当且仅当 <span class="markdown-them-math-inline">$\gcd(a,b)=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故可以转化为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$ax+by=\gcd(a,b)$$</div><p>观察到当 <span class="markdown-them-math-inline">$b=0$</span> 时方程有特解 <span class="markdown-them-math-inline">$x=1,y=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑如何递归求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因为上式中有辗转相除的影子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是尝试构造 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$bx'+(a~mod~b)y'=\gcd(b,a~mod~b)$$</div><p>有 <span class="markdown-them-math-inline">$a~mod~b=a-\lfloor\frac{a}{b}\rfloor b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>化简可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$ay'+b\left(x'-\lfloor\frac{a}{b}\rfloor y'\right)=\gcd(b,a~mod~b)=\gcd(a,b)$$</div><p>于是我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果求出了方程 <span class="markdown-them-math-inline">$bx'+(a~mod~b)y'=\gcd(b,a~mod~b)$</span> 的解 <span class="markdown-them-math-inline">$x'$</span> 和 <span class="markdown-them-math-inline">$y'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么方程 <span class="markdown-them-math-inline">$ax+by=\gcd(a,b)$</span> 的解为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$x=y',y=x'-\lfloor\frac{a}{b}\rfloor y'$$</div><p>于是这样就可以在辗转相除的过程中递归求解了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> a, b, x, y;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Exgcd</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;x = <span class="hljs-number">1</span> , y = <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">Exgcd</span>(b, a % b);<span class="hljs-keyword">int</span> tmp = x;x = y, y = tmp - a / b * y;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;cin &gt;&gt; a &gt;&gt; b;<span class="hljs-built_in">Exgcd</span>(a, b);cout &lt;&lt; (x + b) % b &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」线性筛</title>
      <link href="/2023/06/24/shu-xue-xian-xing-shai/"/>
      <url>/2023/06/24/shu-xue-xian-xing-shai/</url>
      
        <content type="html"><![CDATA[<p>线性筛学习笔记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="筛素数">筛素数</h2><p>考虑如何筛出 <span class="markdown-them-math-inline">$n$</span> 以内的所有素数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有一个最简单的想法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即将所有已求出的质数的倍数标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示它们不为质数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且从小到大遍历到数 <span class="markdown-them-math-inline">$i$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若它没有被标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$i\in Prime$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 在此算法中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个数都被自己所有本质不同的质因子筛了一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以总复杂度为 <span class="markdown-them-math-inline">$\Theta(n\ln \ln n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于上面的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>算力的浪费主要在于很多数被多个质数筛过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们考虑让每个数都只被自己的最小质因子筛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当遍历到 <span class="markdown-them-math-inline">$i$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举已经筛出来的所有质数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若当前枚举的质数为 <span class="markdown-them-math-inline">$p_j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然 <span class="markdown-them-math-inline">$i\times p_j$</span> 不为质数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>另一方面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$p_j|i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$i$</span> 中有一个质因子 <span class="markdown-them-math-inline">$p_j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么后面枚举到 <span class="markdown-them-math-inline">$p_{j+1}$</span> 的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p_{j+1}$</span> 就一定不是 <span class="markdown-them-math-inline">$i\times p_{j+1}$</span> 的最小质因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以此时要停止枚举质数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个数都只被自己的最小质因子筛过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以总复杂度为 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">if</span> (!vis[i]) p[++cnt] = i;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= n; j++) &#123;        vis[i * p[j]] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><h2 id="筛欧拉函数">筛欧拉函数</h2><p>考虑到 <span class="markdown-them-math-inline">$\varphi$</span> 函数有如下性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{cases}\varphi(p)=p-1~~~~~~~~~~~~~~~~~~p\in Prime\\\varphi(ap)=\varphi(a)\times p~~~~~~~~~~p\in Prime\\\varphi(ab)=\varphi(a)\times \varphi(b)~~~~\gcd(a,b)=1\end{cases}$$</div><ul><li><p>对于 <span class="markdown-them-math-inline">$\varphi(p),p\in Prime$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接在筛出质数的同时求解即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>对于 <span class="markdown-them-math-inline">$\varphi(ap),p\in Prime$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$p_j|i$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\varphi(i\times p_j)=\varphi(i)\times p_j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>对于 <span class="markdown-them-math-inline">$\varphi(ab),\gcd(a,b)=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接在筛去合数的时候 <span class="markdown-them-math-inline">$\varphi(i\times p_j)=\varphi(i)\times \varphi(p_j)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><div class="highlight"><pre class="code"><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">if</span> (!vis[i]) p[++cnt] = i, phi[i] = i - <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= n; j++) &#123;        vis[i * p[j]] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) &#123;            phi[i * p[j]] = phi[i] * p[j];            <span class="hljs-keyword">break</span>;        &#125;        phi[i * p[j]] = phi[i] * phi[p[j]];    &#125;&#125;</code></pre></div><h2 id="筛不同质因子的个数">筛不同质因子的个数</h2><p>令 <span class="markdown-them-math-inline">$\alpha(x)$</span> 表示 <span class="markdown-them-math-inline">$x$</span> 不同质因子的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\beta(x)$</span> 表示 <span class="markdown-them-math-inline">$x$</span> 的所有最小质因子的乘积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑到 <span class="markdown-them-math-inline">$\alpha$</span> 函数有如下性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{cases}\alpha(p^k)=1~~~~~~~~~~~~~~~~~~~~~~p\in Prime \\\alpha(ab)=\alpha(a)+\alpha(b)~~~\gcd(a,b)=1\\\alpha(ap)=\alpha(\frac{a}{\beta(a)})+1~~~~p为a的最小质因子\end{cases}$$</div><p>于是用与筛欧拉函数相似的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">if</span> (!vis[i]) p[++cnt] = g[i]= i, f[i] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt; N; j++) &#123;    vis[i * p[j]] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) &#123;        g[i * p[j]] = g[i] * p[j];        f[i * p[j]] = f[i / g[i]] + <span class="hljs-number">1</span>;        <span class="hljs-keyword">break</span>;    &#125;    g[i * p[j]] = p[j];    f[i * p[j]] = f[i] + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」生成函数</title>
      <link href="/2023/06/24/shu-xue-sheng-cheng-han-shu/"/>
      <url>/2023/06/24/shu-xue-sheng-cheng-han-shu/</url>
      
        <content type="html"><![CDATA[<p>生成函数学习笔记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>包含普通生成函数和指数型生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="普通生成函数">普通生成函数</h2><p>序列 <span class="markdown-them-math-inline">$a$</span> 的普通生成函数 <span class="markdown-them-math-inline">$\rm (Ordinary~Generating~Function,OGF)$</span> 被定义为形式幂级数 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \sum _n a_n x ^ n \tag{1.0.1}$$</div><p><span class="markdown-them-math-inline">$a$</span> 既可以是有穷序列也可以是无穷序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$x$</span> 不具有实际意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅作为一个形式上的变量参与运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="两种基本形式">两种基本形式</h3><h4 id="加法与乘法">加法与乘法</h4><p>假设两个序列 <span class="markdown-them-math-inline">$a,b$</span> 的 <span class="markdown-them-math-inline">$\rm OGF$</span> 分别为 <span class="markdown-them-math-inline">$F(x),G(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>加减不必多说 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) \pm G(x) = \sum _n (a_n \pm b_n) x ^ n \tag{1.1.1}$$</div><p>乘法用卷积定义 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x)G(x) = \sum _n x ^ n \sum _{i = 0} ^n a_ib_{n - i} \tag{1.1.2}$$</div><h4 id="封闭形式">封闭形式</h4><p>在使用生成函数的过程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们不会一直使用形式幂级数形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有时候会为了计算方便将其替换成封闭形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li><span class="markdown-them-math-inline">$F(x) = \sum _n x ^ n$</span></li></ul><div class="markdown-them-math-block">$$F(x) - xF(x) = 1$$</div><div class="markdown-them-math-block">$$F(x) = \frac{1}{1 - x} \tag{1.2.1}$$</div><ul><li><span class="markdown-them-math-inline">$F(x) = \sum _n q^n x ^ n$</span></li></ul><div class="markdown-them-math-block">$$F(x) - qxF(x) = 1$$</div><div class="markdown-them-math-block">$$F(x) = \frac{1}{1 - qx} \tag{1.2.2}$$</div><ul><li><span class="markdown-them-math-inline">$F(x) = \sum _n (n + 1)x ^ n$</span></li></ul><div class="markdown-them-math-block">$$\begin{aligned}    F(x) &amp;= \sum _{n \geqslant 1} nx ^ {n - 1}\\    &amp;= \sum _ {n} (x  ^ n)'\\    &amp;= \left(\frac{1}{1 - x}\right)'\end{aligned}$$</div><div class="markdown-them-math-block">$$F(x) = \frac{1}{(1 - x) ^ 2} \tag{1.2.3}$$</div><ul><li><span class="markdown-them-math-inline">$F(x) = \sum _n \binom{m}{n} x ^ n$</span></li></ul><div class="markdown-them-math-block">$$F(x) = (1 + x) ^ m \tag{1.2.4}$$</div><ul><li><span class="markdown-them-math-inline">$F(x) = \sum _ n \binom{n + m}{n} x ^ n$</span></li></ul><div class="markdown-them-math-block">$$F(x) = \frac{1}{(1 - x) ^ {m + 1}} \tag{1.2.5}$$</div><p>考虑归纳证明 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>显然当 <span class="markdown-them-math-inline">$m = 0$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$F(x) = \sum _n \binom{n}{n} x ^ n = \frac{1}{1 - x}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当 <span class="markdown-them-math-inline">$m &gt; 0$</span> 时 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    \frac{1}{(1 - x) ^ {m + 1}} &amp;= \frac{1}{(1 - x) ^ m}\frac{1}{1 - x}\\    &amp;= \left[\sum _ n \dbinom{m + n - 1}{n} x ^ n\right] \left(\sum _n x ^ n\right)\\    &amp;= \sum _ n x ^ n \sum _ {i = 0} ^ n \dbinom{m + i - 1}{i}\\    &amp;= \sum _ n \dbinom{m + n}{n} x ^ n\end{aligned}$$</div><p>关于上述推导过程中最后一步用到的组合恒等式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum _ {i = 0} ^ n \dbinom{m + i - 1}{i} = \dbinom{m + n}{n} \tag{1.2.6}$$</div><p>考虑其组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>左边相当于将 <span class="markdown-them-math-inline">$i$</span> 个无标号石子放进 <span class="markdown-them-math-inline">$m$</span> 个有标号盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>盒子允许为空的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑将 <span class="markdown-them-math-inline">$n$</span> 个石子放进 <span class="markdown-them-math-inline">$m + 1$</span> 个盒子中的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>规则同上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然方案数为 <span class="markdown-them-math-inline">$\binom{m + n}{n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 假设从 <span class="markdown-them-math-inline">$m + 1$</span> 个盒子中取出一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举要将 <span class="markdown-them-math-inline">$n$</span> 个石子中的多少个放入剩下的 <span class="markdown-them-math-inline">$m$</span> 个盒子中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩余的石子就只能放进取出的盒子中了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则方案数为 <span class="markdown-them-math-inline">$\sum _ {i = 0} ^ n \binom{m + i - 1}{i}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 故组合恒等式 <span class="markdown-them-math-inline">$(1.2.6)$</span> 得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>还有另一种仅通过组合意义证明式 <span class="markdown-them-math-inline">$(1.2.5)$</span> 的方法 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>可以发现 <span class="markdown-them-math-inline">$\frac{1}{(1 - x) ^ {m + 1}} = \left(\frac{1}{1 - x}\right) ^ {m + 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>相当于将初始仅有 <span class="markdown-them-math-inline">$a _ 0 = 1$</span> 的序列做了 <span class="markdown-them-math-inline">$m + 1$</span> 遍前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>又因为每做一遍前缀和的组合意义是一个位置可以走到任意一个不在自己左边的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以实际上 <span class="markdown-them-math-inline">$\frac{1}{(1 - x) ^ {m + 1}}$</span> 的第 <span class="markdown-them-math-inline">$n$</span> 项系数即为从 <span class="markdown-them-math-inline">$0$</span> 开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次向右走非负整数步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>走 <span class="markdown-them-math-inline">$m + 1$</span> 步到达 <span class="markdown-them-math-inline">$n$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>归约到一个更加经典的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是不定方程 <span class="markdown-them-math-inline">$\sum _ {i = 1} ^ {m + 1} x _ i = n$</span> 的非负整数解数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>众所周知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其值为 <span class="markdown-them-math-inline">$\binom{m + n}{n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="部分分式定理">部分分式定理</h4><p>在上文中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们已经知道了形如 <span class="markdown-them-math-inline">$F(x) = \frac{1}{(1 - qx) ^ m}$</span> 的部分分式可以简单地被转换为形式幂级数形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们想找到一种方法能够将形如 <span class="markdown-them-math-inline">$\frac{P(x)}{Q(x)}$</span> 的一般分式拆成若干个部分分式之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>部分分式定理指出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 <span class="markdown-them-math-inline">$\deg P &lt; \deg Q$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么可以先将 <span class="markdown-them-math-inline">$Q(x)$</span> 因式分解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后使用待定系数法构造若干个形如 <span class="markdown-them-math-inline">$\frac{A}{(1 - ax) ^ p}$</span> 的式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使它们的和为 <span class="markdown-them-math-inline">$\frac{P(x)}{Q(x)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>例如 <span class="markdown-them-math-inline">$F(x) = \frac{P(x)}{(x - 1) ^ 2 (x + 2)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么构造 <span class="markdown-them-math-inline">$\frac{A}{x - 1} + \frac{B}{(x - 1) ^ 2} + \frac{C}{x + 2} = \frac{P(x)}{(x - 1) ^ 2 (x + 2)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="两个经典数列的生成函数">两个经典数列的生成函数</h3><h4 id="斐波那契数列">斐波那契数列</h4><p>斐波那契数列 <span class="markdown-them-math-inline">$\rm (Fibonacci~Sequence)$</span> 被定义为 <span class="markdown-them-math-inline">$a_0 = 0, a_1 = 1,a _ n = a _ {n - 1} + a _ {n - 2}(n &gt; 1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$F(x) = \sum _ n a _ n x ^ n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = xF(x) + x ^ 2 F(x) - a_0x + a_1x + a_0$$</div><p>解得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \frac{x}{1 - x - x ^ 2} \tag{1.3.1}$$</div><p>考虑使用部分分式定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>观察到分母多项式次数为 <span class="markdown-them-math-inline">$2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么设 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\frac{A}{1 - ax} + \frac{B}{1 - bx} = \frac{x}{1 - x - x ^ 2}$$</div><p>解得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    F(x) &amp;= \frac{x}{1 - x - x ^ 2}\\    &amp;= \frac{\frac{\sqrt{5}}{5}}{1 - \frac{1 + \sqrt{5}}{2}x} + \frac{-\frac{\sqrt{5}}{5}}{1 - \frac{1 - \sqrt{5}}{2}x}\\    &amp;= \sum _ n x ^ n \frac{\sqrt{5}}{5}\left[\left(\frac{1 + \sqrt{5}}{2}\right) ^ n - \left(\frac{1 - \sqrt{5}}{2}\right) ^ n\right]\end{aligned}$$</div><p>于是上式即为斐波那契数列的形式幂级数形式和通项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="卡特兰数">卡特兰数</h4><p>首先引入牛顿二项式定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>让我们重定义组合数的运算 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\dbinom{r}{k} = \frac{r ^ {\underline{k}}}{k!}~~(r \in \mathbb{C}, k \in \mathbb{N}) \tag{1.3.3}$$</div><p>在这种情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于 <span class="markdown-them-math-inline">$\alpha \in \mathbb{C}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$(1 + x) ^ {\alpha} = \sum _n \dbinom{\alpha}{n} x ^ n \tag{1.3.4}$$</div><p>对于卡特兰数序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$a_0 = a_1 = 1, a_n = \sum\limits_{i = 0} ^ {n - 1} a_i \times a_{n - i - 1}(n &gt; 1)$</span></p><p>令其 <span class="markdown-them-math-inline">$\rm OGF$</span> 为 <span class="markdown-them-math-inline">$F(x) = \sum\limits_{n} a ^ n x ^ n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>不难发现其递推式是一个卷积的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$xF ^ 2(x) + 1 = F(x)$$</div><p>解之得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \frac{1 \pm \sqrt{1 - 4x}}{2x} \tag{1.3.5}$$</div><p>要保留哪个根呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p><p>求解上式在 <span class="markdown-them-math-inline">$x \to 0$</span> 时的极限可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$F(x) = \dfrac{1 + \sqrt{1 - 4x}}{2x}$</span> 时不收敛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>原因是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \dfrac{1 + \sqrt{1 - 4x}}{2x} = \frac{2}{1 - \sqrt{1 - 4x}}$$</div><p>则有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\lim\limits_{x \to 0 ^ {+}} \frac{2}{1 - \sqrt{1 - 4x}} = \infty$$</div><div class="markdown-them-math-block">$$\lim\limits_{x \to 0 ^ {-}} \frac{2}{1 - \sqrt{1 - 4x}} = -\infty$$</div><p>故此时 <span class="markdown-them-math-inline">$x \to 0$</span> 时极限不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因此可以得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \dfrac{1 - \sqrt{1 - 4x}}{2x} \tag{1.3.6}$$</div><p>将分子部分单独拿出来考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$G(x) = 1 - \sqrt{1 - 4x} = 1 - (1 - 4x) ^ {\frac{1}{2}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用牛顿二项式定理展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}G(x) &amp;= 1 - \sum\limits_{n \geqslant 0} \dbinom{\frac{1}{2}}{n} (-4x) ^ n \\&amp;= 1 - \sum\limits_{n \geqslant 0} \frac{\frac{1}{2} ^ {\underline n}}{n!} (-4x) ^ n \\&amp;= 1 - \sum\limits_{n \geqslant 0} \frac{\frac{1}{2} \times (-\frac{1}{2}) \times (-\frac{3}{2}) \times \cdots \times (-\frac{2n - 3}{2})}{n!} (-4x) ^ n \\\end{aligned}$$</div><p>特别要注意的是 <span class="markdown-them-math-inline">$\binom{\frac{1}{2}}{0} = \frac{\frac{1}{2} ^ 0}{0!} = 1$</span> 但是用上面那个式子是不正确的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此需要特别考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}G(x) &amp;= \sum\limits_{n \geqslant 1} (-1) ^ {2n - 1} \frac{(2n - 3)!!}{n!2 ^ n} (4x) ^ n \\&amp;= \sum\limits_{n \geqslant 1} \frac{(2n - 2)!}{n!(2n - 2)!!2 ^ n} (4x) ^ n \\&amp;= \sum\limits_{n \geqslant 1} \frac{2(2n - 2)!}{n!(n - 1)!} x ^ n \\&amp;= \sum\limits_{n \geqslant 1} \frac{\binom{2n - 1}{n}}{2n - 1} 2x ^ n\end{aligned}$$</div><p>带回原式有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}F(x) &amp;= \frac{\sum\limits_{n \geqslant 1} \frac{\binom{2n - 1}{n}}{2n - 1} 2x ^ n}{2x} \\&amp;= \sum\limits_{n \geqslant 0} \frac{\binom{2n + 1}{n + 1}}{2n + 1} x ^ n \\&amp;= \sum\limits_{n \geqslant 0} \frac{\binom{2n}{n}}{n + 1} x ^ n\end{aligned}\tag{1.3.9}$$</div><p>因此可知 <span class="markdown-them-math-inline">$a_n = \dfrac{\binom{2n}{n}}{n + 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="欧拉变换">欧拉变换</h3><p>考虑求解形如下式的 <span class="markdown-them-math-inline">$\rm OGF$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F_i(x) = \left(\sum _ j x ^ {ji}\right) ^ {f _ i} =  \left(\frac{1}{1 - x ^ i}\right) ^ {f _ i} \tag{2.3.1}$$</div><div class="markdown-them-math-block">$$\varepsilon\circ F(x) = \prod _ i F_i(x) = \prod _ i \left(\frac{1}{1 - x ^ i}\right) ^ {f _ i} \tag{2.3.2}$$</div><p>这个 <span class="markdown-them-math-inline">$\rm OGF$</span> 的组合意义是将 <span class="markdown-them-math-inline">$n$</span> 个互不区分的小球分进若干个非空集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大小为 <span class="markdown-them-math-inline">$i$</span> 的集合有 <span class="markdown-them-math-inline">$f_i$</span> 种方案的总方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>注意到式 <span class="markdown-them-math-inline">$(2.3.2)$</span> 右边是连乘<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是对其取 <span class="markdown-them-math-inline">$\ln :$</span></p><div class="markdown-them-math-block">$$\begin{aligned}    \ln \varepsilon \circ F(x) &amp;= \sum _ i \ln \left(\frac{1}{1 - x ^ i}\right) ^ {f _ i}\\    &amp;= \sum _ i f_i \times \ln\left(\frac{1}{1 - x ^ i}\right)\\    &amp;= -\sum _ i f_i \times \ln (1 - x ^ i)\\    &amp;= \sum _ i \sum _ j \frac{f_i}{j + 1} x ^ {i(j + 1)}\end{aligned}$$</div><p>关于上式中化简 <span class="markdown-them-math-inline">$\ln (1 - x ^ i)$</span> 的步骤可以参考后文中式 <span class="markdown-them-math-inline">$(2.1.5)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由于我们一般只需求生成函数的前 <span class="markdown-them-math-inline">$n$</span> 项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>观察到 <span class="markdown-them-math-inline">$i$</span> 和 <span class="markdown-them-math-inline">$j$</span> 的枚举构成了调和级数的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以直接暴力计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最后将求出的幂级数 <span class="markdown-them-math-inline">$\rm exp$</span> 回去即可得到 <span class="markdown-them-math-inline">$\varepsilon \circ F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="指数型生成函数">指数型生成函数</h2><p>序列 <span class="markdown-them-math-inline">$a$</span> 的指数型生成函数 <span class="markdown-them-math-inline">$\rm (Exponential~Generating~Function,EGF)$</span> 被定义为形式幂级数 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\hat{F}(x) = \sum _n a_n \frac{x ^ n}{n!}\tag{2.0.1}$$</div><h3 id="两种基本形式-1">两种基本形式</h3><h4 id="加法与乘法-1">加法与乘法</h4><p>形式幂级数形式的加减法与 <span class="markdown-them-math-inline">$\rm OGF$</span> 基本相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也是对应系数相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>乘法被定义为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    \hat{F}(x)\hat{G}(x) &amp;= \sum _ i a _ i \frac{x ^ i}{i!} \sum _ j b _ j \frac{x ^ j}{j!}\\    &amp;= \sum _ n x ^ n \sum _ {i = 0} ^ n a _ i b _ {n - i} \frac{1}{i!(n - i)!}\\    &amp;= \sum _ n \frac{x ^ n}{n!} \sum _ {i = 0} ^ n\dbinom{n}{i} a _ i b _ {n - i}\end{aligned}$$</div><h4 id="麦克劳林级数">麦克劳林级数</h4><p>众所周知有泰勒展开 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \sum _ n \frac{F^{(n)}(x _ 0)}{n!}(x - x _ 0) ^ n \tag{2.1.2}$$</div><p>取 <span class="markdown-them-math-inline">$x_0 = 0$</span> 时的特殊情况可以得到麦克劳林级数 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = \sum _ n F^{(n)}(0)\frac{x ^ n}{n!} \tag{2.1.3}$$</div><p>有 <span class="markdown-them-math-inline">$\exp(0) = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$e ^ x$</span> 的 <span class="markdown-them-math-inline">$\rm EGF$</span> 为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\hat{\exp}(x) = \sum _ n \frac{x ^ n}{n!} \tag{2.1.4}$$</div><h4 id="常见幂级数的封闭形式">常见幂级数的封闭形式</h4><div class="markdown-them-math-block">$$\begin{aligned}e ^ {qx} &amp;= \sum _ n q ^ n \frac{x ^ n}{n!}\\\frac{e^{x}+e^{-x}}{2}&amp;=\sum_{n}\frac{x^{2 n}}{(2 n) !} \\\frac{e^{x}-e^{-x}}{2}&amp;=\sum_{n}\frac{x^{2 n+1}}{(2 n+1) !} \\\ln (1-x)&amp;=-\sum_{n} \frac{x ^ {n + 1}}{n + 1}\\\ln (1+x)&amp;=\sum_{n}(-1)^{n} \frac{x^{n+1}}{n+1} \\(1+x)^{\alpha}&amp;=\sum_{n} \alpha^{\underline{n}} \frac{x^{n}}{n !}\end{aligned}$$</div><h3 id="组合意义">组合意义</h3><p><strong>结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$\hat{G}(x)$</span> 表示集合内部分配方案数关于集合大小的 <span class="markdown-them-math-inline">$\rm EGF$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\hat{F}(x)$</span> 表示将问题划分成若干个无标号非空子问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>子问题的方案数为 <span class="markdown-them-math-inline">$\hat{G}(x)$</span> 的关于问题总规模的方案数的 <span class="markdown-them-math-inline">$\rm EGF$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么有关系式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><div class="markdown-them-math-block">$$\hat{F}(x) = \exp \hat{G}(x) \tag{2.2.1}$$</div><p>考虑证明上述结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$f_{i, j}$</span> 表示将 <span class="markdown-them-math-inline">$j$</span> 个<strong>有标号</strong>小球放进 <span class="markdown-them-math-inline">$i$</span> 个<strong>有标号</strong>盒子中的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g_i$</span> 表示集合内有 <span class="markdown-them-math-inline">$i$</span> 个元素的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i, j} = \sum _{k = 1} ^ {j - i + 1} \dbinom{j}{k} f_{i - 1, j - k} \times g_k$$</div><p>考虑到 <span class="markdown-them-math-inline">$f_{i - 1, j - k}$</span> 在 <span class="markdown-them-math-inline">$k &gt; j - i + 1$</span> 时的值为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以将 <span class="markdown-them-math-inline">$k$</span> 的枚举上界换成 <span class="markdown-them-math-inline">$j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\hat{F}_i(x) = \hat{F}_{i - 1}(x)\hat{G}(x)$$</div><p>化简得到并根据 <span class="markdown-them-math-inline">$\hat{F}_i(x)$</span> 的定义得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\hat{F}_i(x) = \sum _ j f_{i, j} \frac{x ^ j}{j!} = \hat{G}^i(x) \tag{2.2.2}$$</div><p>于是有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    \exp \hat{G}(x) &amp;= \sum_n \frac{\hat{G}^n(x)}{n!}\\    &amp;= \sum _ n \frac{1}{n!} \sum _ i f_{n, i} \frac{x ^ i}{i!}\\    &amp;= \sum _ i \left(\sum _ n \frac{f _ {n, i}}{n!}\right) \frac{x ^ i}{i!}\end{aligned}$$</div><p>这恰好对应了 <span class="markdown-them-math-inline">$\hat{F}(x)$</span> 的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$\hat{F}(x) = \exp \hat{G}(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」简单的代数反演</title>
      <link href="/2023/06/24/shu-xue-jian-dan-de-dai-shu-fan-yan/"/>
      <url>/2023/06/24/shu-xue-jian-dan-de-dai-shu-fan-yan/</url>
      
        <content type="html"><![CDATA[<p>汇总了一下各种代数反演技巧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="二项式反演">二项式反演</h2><h3 id="数列形式">数列形式</h3><div class="markdown-them-math-block">$$g(x)=\sum_{i=x}^n\dbinom{i}{x}f(i)\iff f(x)=\sum_{i=x}^n (-1)^{i-x}\dbinom{i}{x}g(i)$$</div><p><span class="markdown-them-math-inline">$\large\rm Proof:$</span></p><p>将上式带入下式得 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(x)=\sum_{i=x}^n (-1)^{i-x}\dbinom{i}{x}\sum_{j=i}^n\dbinom{j}{i}f(j)$$</div><p>整理得 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(x)=\sum_{i=x}^n\sum_{j=i}^n(-1)^{i-x}\dbinom{j}{i}\dbinom{i}{x}f(j)$$</div><p>根据组合恒等式 <span class="markdown-them-math-inline">$\dbinom{i}{j}\dbinom{j}{k}=\dbinom{i}{k}\dbinom{i-k}{j-k}$</span> 得 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(x)=\sum_{i=x}^n\sum_{j=i}^n(-1)^{i-x}\dbinom{j}{x}\dbinom{j-x}{i-x}f(j)$$</div><p>交换枚举顺序得 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(x)=\sum_{j=x}^n\sum_{i=x}^j(-1)^{i-x}\dbinom{j}{x}\dbinom{j-x}{i-x}f(j)$$</div><p>改变代表字母<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整理得 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(x)=\sum_{i=x}^n\dbinom{i}{x}f(i)\sum_{j=x}^i(-1)^{j-x}\dbinom{i-x}{j-x}$$</div><p>将靠后的 <span class="markdown-them-math-inline">$\sum$</span> 枚举的 <span class="markdown-them-math-inline">$j$</span> 替换成 <span class="markdown-them-math-inline">$j+x$</span> 得  <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(x)=\sum_{i=x}^n\dbinom{i}{x}f(i)\sum_{j=0}^{i-x}(-1)^{j}\dbinom{i-x}{j}$$</div><div class="markdown-them-math-block">$$\because \sum_{i=0}^k(-1)^i\dbinom{k}{i}=(1-1)^k$$</div><div class="markdown-them-math-block">$$\therefore \sum_{i=0}^k(-1)^i\dbinom{k}{i}=[k=0]$$</div><p>所以此式不为 <span class="markdown-them-math-inline">$0$</span> 当且仅当 <span class="markdown-them-math-inline">$i=x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(x)=\sum_{i=x}\dbinom{x}{x}f(i)=f(x)$$</div><p>原式得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>我们来看看二项式反演的数列形式有什么应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p><strong>乱序排列问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong> 求有多少种不同的长度为 <span class="markdown-them-math-inline">$n$</span> 的排列 <span class="markdown-them-math-inline">$p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得 <span class="markdown-them-math-inline">$\forall i\in [1,n],p_i\not = i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>令 <span class="markdown-them-math-inline">$g(i)$</span> 表示钦定有 <span class="markdown-them-math-inline">$i$</span> 个数一定在自己的位置上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的随便排的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有 <span class="markdown-them-math-inline">$&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;：&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;$</span></p><div class="markdown-them-math-block">$$g(i)=\dbinom{n}{i}(n-i)!$$</div><p>令 <span class="markdown-them-math-inline">$f(i)$</span> 表示恰好有 <span class="markdown-them-math-inline">$i$</span> 个数在自己的位置上的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑到 <span class="markdown-them-math-inline">$f(i)$</span> 会被 <span class="markdown-them-math-inline">$g(j)~(j\leqslant i)$</span> 计算 <span class="markdown-them-math-inline">$\dbinom{i}{j}$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是有 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$g(i)=\sum_{j=i}^n\dbinom{j}{i}f(j)$$</div><p>根据二项式反演 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(i)=\sum_{j=i}^n(-1)^{j-i}\dbinom{j}{i}g(j)$$</div><p>将 <span class="markdown-them-math-inline">$g(i)=\dbinom{n}{i}(n-i)!$</span> 带入得 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(i)=\sum_{j=i}^n(-1)^{j-i}\dbinom{j}{i}\dbinom{n}{j}(n-j)!$$</div><p>根据组合恒等式 <span class="markdown-them-math-inline">$\dbinom{i}{j}\dbinom{j}{k}=\dbinom{i}{k}\dbinom{i-k}{j-k}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整理得 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$f(i)=\dbinom{n}{i}\sum_{j=i}^n(-1)^{j-i}\dbinom{n-i}{j-i}(n-j)!$$</div><p>考虑到当 <span class="markdown-them-math-inline">$i=0$</span> 时为答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$\begin{aligned}    Ans=f(0)&amp;=\sum_{i=0}^n(-1)^i\dbinom{n}{i}(n-i)!\\&amp;=\sum_{i=0}^n(-1)^i\dfrac{n!}{i!}\\&amp;=(n+1)!\sum_{i=0}^n(-1)^i(i!)^{-1}\end{aligned}$$</div><h3 id="集合形式">集合形式</h3><div class="markdown-them-math-block">$$f(S)=\sum_{S\subseteq T}g(T)\iff g(S)=\sum_{S\subseteq T} (-1)^{|T|-|S|}f(T)$$</div><p><span class="markdown-them-math-inline">$\large\rm Proof:$</span></p><p>同样考虑带入证明 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    f(S)&amp;=\sum_{S\subseteq T}\sum_{T\subseteq R}(-1)^{|R|-|T|}f(R)\\&amp;=\sum_{S\subseteq R}f(R)\sum_{S\subseteq T\subseteq R}(-1)^{|R|-|T|}\end{aligned}$$</div><p>考虑枚举 <span class="markdown-them-math-inline">$T-S$</span> 的大小 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    f(S)&amp;=\sum_{S\subseteq R}f(R)\sum_{i=0}^{|R|-|S|}\dbinom{|R|-|S|}{i}(-1)^{|R|-(|S|+i)}\\&amp;=\sum_{S\subseteq R}[|S|=|R|]\\&amp;=f(S)\end{aligned}$$</div><p>原式得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>我们来看看二项式反演的集合形式有什么应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p><strong>有向图无环子图计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong> 给定一张 <span class="markdown-them-math-inline">$n$</span> 个点的有向图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求其无环子图的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑动态规划<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$f_S$</span> 表示点集 <span class="markdown-them-math-inline">$S$</span> 导出子图的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由于是 <span class="markdown-them-math-inline">$\rm DAG$</span> 计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以我们可以很自然地想到枚举入度为 <span class="markdown-them-math-inline">$0$</span> 的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设 <span class="markdown-them-math-inline">$T$</span> 是 <span class="markdown-them-math-inline">$S$</span> 的子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且其中的每个点都没有入边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么显然有转移 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_S=\sum_{T\subseteq S,T\not = \varnothing}2^{cnt_{T,S-T}}\times f_{S-T}$$</div><p>其中 <span class="markdown-them-math-inline">$cnt_{S,T}$</span> 表示集合 <span class="markdown-them-math-inline">$S$</span> 到集合 <span class="markdown-them-math-inline">$T$</span> 的连边总数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>但我们发现这样做实际上是错的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 <span class="markdown-them-math-inline">$T$</span> 不一定包含了 <span class="markdown-them-math-inline">$S$</span> 中所有入度为 <span class="markdown-them-math-inline">$0$</span> 的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们考虑容斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$q_T=2^{cnt_{T,S-T}}\times f_{S-T}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p_T$</span> 表示 <span class="markdown-them-math-inline">$S$</span> 中恰好有 <span class="markdown-them-math-inline">$T$</span> 作为入度为 <span class="markdown-them-math-inline">$0$</span> 的点的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$q_T=\sum\limits_{T\subseteq S} p_S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由二项式反演的集合形式可以得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$p_S=\sum_{S\subseteq T}(-1)^{|T|-|S|}q_T$$</div><p>回到原本的 <span class="markdown-them-math-inline">$\rm DP$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要求 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    f_S&amp;=\sum_{T\subseteq S,T\not= \varnothing}p_T\\&amp;=\sum_{T\subseteq S,T\not= \varnothing}\sum_{T\subseteq R\subseteq S}(-1)^{|R|-|T|}q_R\\&amp;=\sum_{R\subseteq S,R\not= \varnothing}q_R \sum_{T\subseteq R,T\not=\varnothing}(-1)^{|R|-|T|}\\&amp;=\sum_{R\subseteq S,R\not= \varnothing}q_R (-1)^{|R|}\left(\sum_{T\subseteq R}(-1)^{-|T|}-1\right)\\&amp;=\sum_{T\subseteq S,T\not= \varnothing}(-1)^{|T|-1}q_T\end{aligned}$$</div><p>于是转移方程为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_S=\sum_{T\subseteq S,T\not= \varnothing}(-1)^{|T|-1}2^{cnt_{T,S-T}}f_{S-T}$$</div><p>现在只需要 <span class="markdown-them-math-inline">$\Theta(1)$</span> 计算 <span class="markdown-them-math-inline">$cnt_{T,S-T}$</span> 即可做到 <span class="markdown-them-math-inline">$\Theta(3^n)$</span> 计算计算答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑预处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以在枚举了每个 <span class="markdown-them-math-inline">$S$</span> 做转移的时候再算这个东西<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时只需要记 <span class="markdown-them-math-inline">$cnt_T~(T\subseteq S,T\not=\varnothing)$</span> 表示 <span class="markdown-them-math-inline">$T$</span> 恰好作为 <span class="markdown-them-math-inline">$S$</span> 中没有入度的点集的路径数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑在进行所有计算之前预处理 <span class="markdown-them-math-inline">$A_{i,S}$</span> 表示 <span class="markdown-them-math-inline">$i$</span> 到 <span class="markdown-them-math-inline">$S$</span> 中的边数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$D_{i,S}$</span> 表示 <span class="markdown-them-math-inline">$S$</span> 中的点到 <span class="markdown-them-math-inline">$i$</span> 的边数和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这两个数组都可以 <span class="markdown-them-math-inline">$\Theta(n2^n)$</span> 预处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>计算 <span class="markdown-them-math-inline">$cnt$</span> 时考虑从小到大枚举每个 <span class="markdown-them-math-inline">$T$</span> 计算答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现 <span class="markdown-them-math-inline">$T$</span> 的每个真子集的答案都已经被计算出来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是任取一个点从 <span class="markdown-them-math-inline">$T$</span> 中移到 <span class="markdown-them-math-inline">$S-T$</span> 即可算出答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里考虑 <span class="markdown-them-math-inline">$\Theta(1)$</span> 枚举 <code>lowbit</code>. 可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移式为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$cnt_T=cnt_{T-\{u\}}+A_{u,S-T}-D_{T-\{u\},u}$$</div><p>于是本题到此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以做到时间复杂度 <span class="markdown-them-math-inline">$\Theta(3^n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>空间复杂度 <span class="markdown-them-math-inline">$\Theta(n2^n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="子集反演">子集反演</h3><div class="markdown-them-math-block">$$f(S)=\sum_{T\subseteq S}g(T)\iff g(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}f(T)$$</div><p><span class="markdown-them-math-inline">$\large\rm Proof:$</span></p><p>还是考虑带入证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与二项式反演的集合形式类似 <span class="markdown-them-math-inline">$:$</span></p><div class="markdown-them-math-block">$$\begin{aligned}    f(S)&amp;=\sum_{T\subseteq S}\sum_{R\subseteq T}(-1)^{|T|-|R|}f(R)\\&amp;=\sum_{R\subseteq S}f(R)\sum_{R\subseteq T\subseteq S}(-1)^{|T|-|R|}\\&amp;=\sum_{R\subseteq S}f(R)\sum_{i=0}^{|S|-|R|}\dbinom{|S|-|R|}{i}(-1)^{(|S|-i)-|R|}\\&amp;=\sum_{R\subseteq S}[|R|=|S|]\\&amp;=f(S)\end{aligned}$$</div><p>原式得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="斯特林反演">斯特林反演</h2><h3 id="第二类斯特林数">第二类斯特林数</h3><h4 id="定义">定义</h4><p>定义 <span class="markdown-them-math-inline">$\begin{Bmatrix}n \\ m\end{Bmatrix}$</span> 为将 <span class="markdown-them-math-inline">$n$</span> 个有标号小球放入 <span class="markdown-them-math-inline">$m$</span> 个无标号盒子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子不能为空的方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="递推式">递推式</h4><div class="markdown-them-math-block">$$\begin{Bmatrix}n \\ m\end{Bmatrix} = \begin{Bmatrix}n - 1 \\ m - 1\end{Bmatrix} + m \times \begin{Bmatrix}n - 1 \\ m\end{Bmatrix}$$</div><p>根据组合意义不难证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="求一行第二类斯特林数">求一行第二类斯特林数</h4><p>考虑以下第二类斯特林数的组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们考虑使用容斥描述第二类斯特林数的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先我们求出将 <span class="markdown-them-math-inline">$n$</span> 个有标号小球放入 <span class="markdown-them-math-inline">$m$</span> 个有标号盒子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>盒子不能为空的方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据这个问题的特殊性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任意一种无标号盒子的方案恰好双向对应 <span class="markdown-them-math-inline">$m!$</span> 中有标号盒子的方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后除 <span class="markdown-them-math-inline">$m!$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于盒子是否为空进行容斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{Bmatrix}n \\ m\end{Bmatrix} = \frac{1}{m!} \sum\limits_i ^ m (-1) ^ i \dbinom{m}{i}(m - i) ^ n$$</div><p>显然是一个卷积的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\rm NTT$</span> 即可做到 <span class="markdown-them-math-inline">$\mathcal{O(n \log n)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="求一列第二类斯特林数">求一列第二类斯特林数</h4><p>不难发现第二类斯特林数的定义与 <span class="markdown-them-math-inline">$\exp$</span> 的组合意义很相似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们考虑 <span class="markdown-them-math-inline">$\rm EGF:$</span> <span class="markdown-them-math-inline">$\widehat F(x) = \sum\limits_{i = 1} ^ \infty \frac{x ^ i}{i!} = e ^ x - 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>那么根据 <span class="markdown-them-math-inline">$\rm EGF$</span> 相乘的组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$[\dfrac{x ^ n}{n!}]\widehat F ^ m(x) = [\dfrac{x ^ n}{n!}](e ^ x - 1) ^ m = \begin{Bmatrix}n \\ m\end{Bmatrix}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>使用多项式快速幂即可做到 <span class="markdown-them-math-inline">$\mathcal{O(n \log n)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="第一类斯特林数">第一类斯特林数</h3><h4 id="定义-1">定义</h4><p>定义 <span class="markdown-them-math-inline">$\begin{bmatrix}n \\ m\end{bmatrix}$</span> 为将 <span class="markdown-them-math-inline">$n$</span> 个数划分成 <span class="markdown-them-math-inline">$m$</span> 个互不区分的非空置换的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="递推式-1">递推式</h4><div class="markdown-them-math-block">$$\begin{bmatrix}n \\ m\end{bmatrix} = \begin{bmatrix}n - 1 \\ m - 1\end{bmatrix} + (n - 1) \times \begin{bmatrix}n - 1 \\ m\end{bmatrix}$$</div><p>由组合意义不难证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="求一行第一类斯特林数">求一行第一类斯特林数</h4><p>因为第一类斯特林数不具有较好的组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此不能像第二类斯特林数那样使用另一种方式来描述其<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此我们直接考虑第一类斯特林数的 <span class="markdown-them-math-inline">$\rm OGF$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}F_i(x) &amp;= \sum\limits_j ^ \infty \begin{bmatrix}i \\ j\end{bmatrix} x ^ j \\&amp;= x \times F_{i - 1}(x) + (i - 1) F_{i - 1}(x) \\&amp;= (i + x - 1) F_{i - 1}(x) \\&amp;= \prod\limits_j ^ {i - 1} (x + j)\end{aligned}$$</div><p>那么就有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F_n(x) = \prod\limits_i ^ {n - 1} (x + i)$$</div><p>当然可以直接使用启发式合并做到 <span class="markdown-them-math-inline">$\mathcal{O(n \log ^ 2n)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但还存在一个更加优秀的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>倍增法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F_{2n}(x) = F_n(x) \times F_n(x + n)$$</div><p>只需快速计算 <span class="markdown-them-math-inline">$F_n(x + n)$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$F_n(x) = \sum\limits_i ^ \infty f_i x ^ i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}F_n(x + n) &amp;= \sum\limits_i ^ n f_i(x + n) ^ i \\&amp;= \sum\limits_i ^ n f_i\sum\limits_j ^ i x ^ j n ^ {i - j}\end{aligned}$$</div><p>后者很明显是一个卷积的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接计算即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据倍增的复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以做到 <span class="markdown-them-math-inline">$\mathcal{O(n \log n)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="求一列第一类斯特林数">求一列第一类斯特林数</h4><p>类似于求一列第二类斯特林数的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑 <span class="markdown-them-math-inline">$\rm EGF:$</span> <span class="markdown-them-math-inline">$\widehat F(x) = \sum\limits_i ^ \infty \dfrac{(i - 1)!x ^ i}{i!} = \sum\limits_i ^ \infty \dfrac{x ^ i}{i} = \ln\left(\dfrac{1}{1 - x}\right)$</span></p><p>那么就有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{bmatrix}n \\ m\end{bmatrix} = [\frac{x ^ n}{n!}]\widehat F ^ m(x)$$</div><p>使用多项式快速幂即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度 <span class="markdown-them-math-inline">$\mathcal{O(n \log n)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="普通幂,-上升幂, 下降幂的转换">普通幂, 上升幂, 下降幂的转换</h3><p>先介绍两个最简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>上升幂和下降幂的转换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$x ^ {\underline{n}} = (-1) ^ n (-x) ^ {\overline n}$$</div><div class="markdown-them-math-block">$$x ^ {\overline{n}} = (-1) ^ n (-x) ^ {\underline n}$$</div><p>再根据我们求一行斯特林数的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以得到上升幂转普通幂公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$x ^ {\overline n} = \sum\limits_i ^ n \begin{bmatrix} n \\ i \end{bmatrix} x ^ i$$</div><p>而根据第二类斯特林数的组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再根据普通幂 <span class="markdown-them-math-inline">$x ^ n$</span> 的组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以得到普通幂转下降幂公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$x ^ n = \sum\limits_i ^ x \dbinom{x}{i} \begin{Bmatrix} n \\ i \end{Bmatrix} i! = \sum\limits_i ^ x \begin{Bmatrix} n \\ i \end{Bmatrix} x ^ {\underline{i}}$$</div><p>再利用最开始提到的下降幂转上升幂公式变形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以得到普通幂转上升降幂公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}(-x) ^ n &amp;= \sum\limits_i ^ x \begin{Bmatrix} n \\ i \end{Bmatrix} (-x) ^ {\underline{i}} \\&amp;= \sum\limits_i ^ x \begin{Bmatrix} n \\ i \end{Bmatrix} (-1) ^ i x ^ {\overline{i}}\end{aligned}$$</div><div class="markdown-them-math-block">$$\Longleftrightarrow x ^ n = \sum\limits_i ^ x (-1) ^ {n - i}\begin{Bmatrix} n \\ i \end{Bmatrix}x ^ {\overline{i}}$$</div><p>同理可得下降幂转普通幂公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$x ^ {\underline{n}} = \sum\limits_i ^ x (-1) ^ {n - i} \begin{bmatrix} n \\ i \end{bmatrix} x ^ i$$</div><p>总结一下四个公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>普通幂转出去使用第二类斯特林数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转回来使用第一类斯特林数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>阶数上升<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>下转普<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>普转上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>加 <span class="markdown-them-math-inline">$-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>通过这四个公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们也能完成一般多项式和上升幂下降幂多项式的互相转化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>我们来看看这几个式子有什么应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p><strong>例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong> 给定 <span class="markdown-them-math-inline">$k$</span> 次多项式 <span class="markdown-them-math-inline">$f(x)$</span> 的各项系数和一个整数 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求以下式子对 <span class="markdown-them-math-inline">$998244353$</span> 取模后的值 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{i=0}^n\dbinom{n}{i}2^{n-i}f(i)$$</div><p>我们发现带 <span class="markdown-them-math-inline">$f(x)$</span> 的式子没有前途<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是将其拆开 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{i=0}^n\dbinom{n}{i}2^{n-i}\sum_{j=0}^ka_ji^j$$</div><p>这里有个套路是将整数幂转第二类斯特林数 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    m^n&amp;=\sum_{k=0}^m\dbinom{m}{k}\begin{Bmatrix}n\\m-k\end{Bmatrix}(m-k)!\\&amp;=\sum_{k=0}^m\begin{Bmatrix}n\\k\end{Bmatrix}m^{\underline{k}}\end{aligned}$$</div><p>转化的含义是将 <span class="markdown-them-math-inline">$m^n$</span> 看作 <span class="markdown-them-math-inline">$\rm LLA$</span> 问题的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现 <span class="markdown-them-math-inline">$\small\begin{Bmatrix}n\\m\end{Bmatrix}$</span> 是 <span class="markdown-them-math-inline">$\rm LUB$</span> 问题的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是枚举 <span class="markdown-them-math-inline">$m$</span> 个集合中有 <span class="markdown-them-math-inline">$k$</span> 个 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后用第二类斯特林数将 <span class="markdown-them-math-inline">$\rm LUA$</span> 算出来后乘上 <span class="markdown-them-math-inline">$(m-k)!$</span> 得到 <span class="markdown-them-math-inline">$\rm LLA$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是就可以开始推式子了 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    &amp;\quad~\sum_{i=0}^n\dbinom{n}{i}2^{n-i}f(i)\\&amp;=\sum_{i=0}^n\dbinom{n}{i}2^{n-i}\sum_{j=0}^ka_ji^j\\&amp;=\sum_{i=0}^n\dbinom{n}{i}2^{n-i}\sum_{j=0}^ka_j\sum_{p=0}^i\dbinom{i}{p}\begin{Bmatrix}j\\p\end{Bmatrix}p!\\&amp;=\sum_{i=0}^n\sum_{j=0}^k\sum_{p=0}^i\dbinom{n}{i}\dbinom{i}{p}2^{n-i}a_j\begin{Bmatrix}j\\p\end{Bmatrix}p!\\&amp;=\sum_{j=0}^ka_j\sum_{p=0}^n\begin{Bmatrix}j\\p\end{Bmatrix}p!\sum_{i=p}^n\dbinom{n}{i}\dbinom{i}{p}2^{n-i}\\&amp;=\sum_{j=0}^ka_j\sum_{p=0}^n\begin{Bmatrix}j\\p\end{Bmatrix}p!\sum_{i=p}^n\dbinom{n}{p}\dbinom{n-p}{i-p}2^{n-i}\\&amp;=\sum_{j=0}^ka_j\sum_{p=0}^n\dbinom{n}{p}\begin{Bmatrix}j\\p\end{Bmatrix}p!\sum_{i=0}^{n-p}\dbinom{n-p}{i}2^{n-p-i}\\&amp;=\sum_{j=0}^k\sum_{p=0}^na_j\begin{Bmatrix}j\\p\end{Bmatrix}\dbinom{n}{p}p!3^{n-p}\\&amp;=\sum_{j=0}^k\sum_{p=0}^j\begin{Bmatrix}j\\p\end{Bmatrix}a_j\times n^{\underline{p}}\times 3^{n-p}\end{aligned}$$</div><p>最后这个式子可以通过预处理第二类斯特林数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$3$</span> 的次幂和 <span class="markdown-them-math-inline">$n$</span> 的 <span class="markdown-them-math-inline">$p$</span> 阶下降幂做到 <span class="markdown-them-math-inline">$\Theta(k^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="斯特林反演-1">斯特林反演</h3><p>非常类似二项式反演的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_n = \sum\limits_i ^ n \begin{Bmatrix} n \\ i \end{Bmatrix} g_i \Longleftrightarrow g_n = \sum\limits_i ^ n (-1) ^ {n - i} \begin{bmatrix} n \\ i \end{bmatrix} f_i$$</div><p>我们首先需要了解斯特林反演基于的恒等式 <span class="markdown-them-math-inline">$-$</span> 反转公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum\limits_{i = m} ^ n (-1) ^ {n - i} \begin{Bmatrix} n \\ i \end{Bmatrix} \begin{bmatrix} i \\ m \end{bmatrix} = [n = m]$$</div><div class="markdown-them-math-block">$$\sum\limits_{i = m} ^ n (-1) ^ {n - i} \begin{bmatrix} n \\ i \end{bmatrix} \begin{Bmatrix} i \\ m \end{Bmatrix} = [n = m]$$</div><p>不难发现两式的形式非常类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只证明第一条式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第二条式子是类似的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}x ^ n &amp;= \sum\limits_i ^ n \begin{Bmatrix} n \\ i \end{Bmatrix} x ^ {\underline{i}} \\&amp;= \sum\limits_i ^ n \begin{Bmatrix} n \\ i \end{Bmatrix} (-1) ^ i (-x) ^ {\overline{i}} \\&amp;= \sum\limits_i ^ n (-1) ^ i \begin{Bmatrix} n \\ i \end{Bmatrix} \sum\limits_j ^ i (-1) ^ j \begin{bmatrix} i \\ j \end{bmatrix} x ^ j \\&amp;= \sum\limits_i ^ n \left( \sum\limits_{j = i} ^ n (-1) ^ {i - j} \begin{Bmatrix} n \\ j \end{Bmatrix} \begin{bmatrix} j \\ i \end{bmatrix}\right) x ^ i\end{aligned}$$</div><p>根据多项式恒等原理即可证明第一条反转公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有了这两条反转公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就可以直接将斯特林反演左式带入右式以及右式带入左式来证明正确性了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>过程是不难的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="min-max-反演">Min-Max 反演</h2><p>令 <span class="markdown-them-math-inline">$\max\limits_k(S)$</span> 表示有限集 <span class="markdown-them-math-inline">$S$</span> 中的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\min\limits_k(S)$</span> 表示有限集中的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="基本形式">基本形式</h3><div class="markdown-them-math-block">$$\max(S)=\sum\limits_{T\subseteq S}(-1)^{|T|-1}\min(T)$$</div><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于所有 <span class="markdown-them-math-inline">$T\subseteq S-\{\max(S)\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>均存在 <span class="markdown-them-math-inline">$T+\max(S)\subseteq S$</span> 与之一一对应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$\min(T)=\min(T+\max(S))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 由于它们的大小恰好相差 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故对每个集合 <span class="markdown-them-math-inline">$S$</span> 配上 <span class="markdown-them-math-inline">$(-1)^{|S|}$</span> 的系数可以恰好它们消掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后仅剩下集合 <span class="markdown-them-math-inline">$\{\max(S)\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的最小值恰好等于 <span class="markdown-them-math-inline">$\max(S)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>同理 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\min(S)=\sum\limits_{T\subseteq S}(-1)^{|T|-1}\max(T)$$</div><h3 id="拓展形式">拓展形式</h3><div class="markdown-them-math-block">$$\max_k(S)=\sum_{T\subseteq S,|T|\geqslant k}(-1)^{|T|-k}\dbinom{|T|-1}{k-1}\min(T)$$</div><p>考虑 <span class="markdown-them-math-inline">$S$</span> 中的第 <span class="markdown-them-math-inline">$i$</span> 大数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它作为最小值被包含在大小为 <span class="markdown-them-math-inline">$|T|$</span> 的集合中共 <span class="markdown-them-math-inline">$\binom{i-1}{|T|-1}$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次出现会乘上 <span class="markdown-them-math-inline">$\binom{|T|-1}{k-1}$</span> 的权值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故一个数 <span class="markdown-them-math-inline">$\max\limits_i(S)$</span> 的总贡献为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    val_i&amp;=\max_i(S)\sum_{|T|=k}^i(-1)^{|T|-k}\dbinom{i-1}{|T|-1}\dbinom{|T|-1}{k-1}\\&amp;=\max_i(S)\dbinom{i-1}{k-1}\sum_{|T|=k}^i(-1)^{|T|-k}\dbinom{i-k}{|T|-k}\\&amp;=\max_i(S)\dbinom{i-1}{k-1}[i=k]\end{aligned}$$</div><p>所有数的贡献之和即为 <span class="markdown-them-math-inline">$\sum\limits_{i=1}^{|S|}val_i=\max\limits_k(S)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故原式成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于期望具有线性性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以上面的式子在期望意义下也成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>我们来看看 <span class="markdown-them-math-inline">$\rm Min-Max$</span> 反演有什么应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p><a href="https://www.luogu.com.cn/problem/P4707"><strong>重返现世</strong></a> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>你需要收集 <span class="markdown-them-math-inline">$n$</span> 种物品中的任意 <span class="markdown-them-math-inline">$k$</span> 种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个时刻会有一种物品被生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第 <span class="markdown-them-math-inline">$i$</span> 种物品被生成的概率为 <span class="markdown-them-math-inline">$\frac{p_i}{m}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果你还没有收集这种物品则可以收集它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求你收集到这 <span class="markdown-them-math-inline">$n$</span> 个物品中任意 <span class="markdown-them-math-inline">$k$</span> 个的期望时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>保证 <span class="markdown-them-math-inline">$k\leqslant n\leqslant 10^3,|n-k|\leqslant 10,0\leqslant p_i\leqslant m,\sum p=m,m\leqslant 10^4$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先可以发现所有物品出现的时间不重<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故构成一个集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以题目要求的为 <span class="markdown-them-math-inline">$E\left(\max (S)_{k}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>套用拓展 <span class="markdown-them-math-inline">$\rm Min -Max$</span> 得到:</p><div class="markdown-them-math-block">$$E\left(\max (S)_{k}\right)=\sum_{T \subseteq S}\left(\begin{array}{c}|T|-1 \\k-1\end{array}\right)(-1)^{|T|-k} E(\min (T))$$</div><p>我们知道原来要求的是全集合中出现时间排第 <span class="markdown-them-math-inline">$k$</span> 的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于变成了正过来看<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时的 <span class="markdown-them-math-inline">$k$</span> 变成了 <span class="markdown-them-math-inline">$n-k+ 1$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的值非常小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们知道一个集合每次操作出现一个属于它的元素的概率为:</p><div class="markdown-them-math-block">$$e(S)=\sum_{i \in S} \frac{p_{i}}{m}$$</div><p>于是我们知道期望时间为:</p><div class="markdown-them-math-block">$$\sum_{i=1}^{\infty} e(S)(1-e(S))^{i-1}=\frac{1}{e(S)}$$</div><p>于是现在我们得到了一个复杂度为 <span class="markdown-them-math-inline">$\Theta\left(2^{n}\right)$</span> 的做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>暴力枚举子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于每个集合求出此式子并计算贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>接下来看来需要一点魔法了 <span class="markdown-them-math-inline">$&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;。&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;....$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们来看下这个式子:</p><div class="markdown-them-math-block">$$E\left(\max (S)_{k}\right)=\sum_{T \subseteq S}\left(\begin{array}{c}|T|-1 \\k-1\end{array}\right)(-1)^{|T|-k} E(\min (T))$$</div><p>考虑一个固定的集合大小 <span class="markdown-them-math-inline">$|T|$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其分配的系数相同均为 <span class="markdown-them-math-inline">$\left(\begin{array}{c}|T|-1 \\ k-1\end{array}\right)(-1)^{|T|-k}$</span></p><p>则我们只需要求出 <span class="markdown-them-math-inline">$\sum_{|T|=x} E(\min (T))$</span></p><p>注意到 <span class="markdown-them-math-inline">$E(\min (T))=\frac{1}{e(S)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们可以给 <span class="markdown-them-math-inline">$d p$</span> 加一个维度记录 <span class="markdown-them-math-inline">$\sum p=e(S)$</span>, 这样只需要统计有多少 个点满足 <span class="markdown-them-math-inline">$\sum p=i,|T|=j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是不妨记 <span class="markdown-them-math-inline">$d p_{i, j, k}$</span> 表示考虑到前 <span class="markdown-them-math-inline">$i$</span> 个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="markdown-them-math-inline">$|T|=j, \sum p=k$</span> 的集合数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可以得到转移:</p><div class="markdown-them-math-block">$$d p_{i, j, k}=d p_{i-1, j, k}+d p_{i-1, j-1, k-p_{i}}$$</div><p>这样便可以得到一个复杂度为 <span class="markdown-them-math-inline">$\Theta\left(n^{2} m\right)$</span> 的做法了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>现在问题在于如何优化复杂度 <span class="markdown-them-math-inline">$?$</span></p><p>我们发现转移已经是最优了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不能从这里下手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是只能从状态下手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于 <span class="markdown-them-math-inline">$k$</span> 这一维附带了一个 <span class="markdown-them-math-inline">$\frac{1}{k}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是肯定定是不能省略的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>唯一的办法是把记录中的 <span class="markdown-them-math-inline">$|T|$</span> 给去掉试试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>换而言之我们只统计到第 <span class="markdown-them-math-inline">$i$</span> 个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任意放满足 <span class="markdown-them-math-inline">$\sum p=k$</span> 的数前面安排的系数之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑系数为:</p><div class="markdown-them-math-block">$$\sum\left(\begin{array}{c}|T|-1 \\k-1\end{array}\right)(-1)^{|T|-k}$$</div><p>拆开试试 <span class="markdown-them-math-inline">$?$</span></p><div class="markdown-them-math-block">$$\sum \frac{(|T|-1) !}{(k-1) !(|T|-k) !}(-1)^{|T|-k}$$</div><p>好像还是不行…</p><p>但是这个时候可以得到转移大致为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$d p_{i, j}=d p_{i-1, j}+\ldots$$</div><p>这个奇怪的东西应该表示为:</p><p>对于 <span class="markdown-them-math-inline">$d p_{i-1, j-p i}$</span> 的:</p><div class="markdown-them-math-block">$$\sum\left(\begin{array}{c}|T|-1 \\k-1\end{array}\right)(-1)^{|T|-k}$$</div><p>首先可以注意到所有 <span class="markdown-them-math-inline">$|T| \rightarrow|T|+1$</span> 于是整体需要乘一个 <span class="markdown-them-math-inline">$-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意到 <span class="markdown-them-math-inline">$|T| \rightarrow|T|+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是组合数变成了:</p><div class="markdown-them-math-block">$$\left(\begin{array}{c}|T| \\k-1\end{array}\right)$$</div><p>但是我们知道组合数可以递推所以有:</p><div class="markdown-them-math-block">$$\left(\begin{array}{c}|T| \\k-1\end{array}\right)=\left(\begin{array}{c}|T|-1 \\k-1\end{array}\right)+\left(\begin{array}{c}|T|-1 \\k-2\end{array}\right)$$</div><p>然而真正有趣的是这个式子可以放在一起一起递推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为考虑计算 <span class="markdown-them-math-inline">$dp$</span> 时强制放入一个数则等价于 <span class="markdown-them-math-inline">$|T|$</span> 必然变大 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们可以给 <span class="markdown-them-math-inline">$dp$</span> 增加一个维度 <span class="markdown-them-math-inline">$k$</span> 来计算 <span class="markdown-them-math-inline">$dp$</span> 系数</p><div class="markdown-them-math-block">$$d p_{i, j, k}=d p_{i-1, j, k}+(-1) \times d p_{i-1, j-p i, k}+(-1)^{2} \times d p_{i-1, j-p i, k-1}$$</div><p>即:</p><div class="markdown-them-math-block">$$d p_{i, j, k}=d p_{i-1, j, k}-d p_{i-1, j-p i, k}+d p_{i-1, j-p i, k-1}$$</div><p>接下来考虑边界条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个好像有点难<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为我们的 <span class="markdown-them-math-inline">$dp$</span> 是按照转移的需求设计<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以它存在的实际意义也是为了方便转移而存在的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们知道 <span class="markdown-them-math-inline">$d p_{0, j, k}$</span> 的意义应该是: <span class="markdown-them-math-inline">$\sum_{\sum p=j}\left(\begin{array}{c}|T|-1 \\ k-1\end{array}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑前面的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>唯一的一个 <span class="markdown-them-math-inline">$\sum p=j$</span> 是空集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$\sum p=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时有 <span class="markdown-them-math-inline">$|T|=0$</span> 求的则是:</p><div class="markdown-them-math-block">$$dp_{0,0, k}=\dbinom{-1}{k-1}$$</div><p>这个时候我们需要拓宽组合数的意义, 你可以认为 <span class="markdown-them-math-inline">$\binom{-1}{-1}=1$</span> 而 <span class="markdown-them-math-inline">$\binom{x}{y}$</span> 在 <span class="markdown-them-math-inline">$x&lt;y$</span> 的时候为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$x=y$</span> 的时候为 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 所以 <span class="markdown-them-math-inline">$dp$</span> 的边界为 <span class="markdown-them-math-inline">$dp_{0,0,0}=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>转移的时候可以用滚动数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总时间复杂度为 <span class="markdown-them-math-inline">$\Theta(nm(n-k))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="gcd-lcm-反演">Gcd-Lcm 反演</h3><p>一般地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求 <span class="markdown-them-math-inline">$\rm lcm$</span> 通常转化为求解 <span class="markdown-them-math-inline">$\gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 <span class="markdown-them-math-inline">$\gcd$</span> 的性质更为优秀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以借助莫比乌斯反演<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>通用形式为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\mathrm{lcm}(S) = \prod\limits_{T \subseteq S, T \ne \varnothing} \gcd(T) ^ {(-1) ^ {|T| - 1}}$$</div><p>证明考虑使用 <span class="markdown-them-math-inline">$\rm Min-Max$</span> 容斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑每个质因子 <span class="markdown-them-math-inline">$p$</span> 对左右的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}p ^ {\max(p, S)} &amp;= p ^ {\sum\limits_{T \subseteq S, T \ne \varnothing} (-1) ^ {|T| - 1} \min(p, T)} \\&amp;= \prod\limits_{T \subseteq S, T \ne \varnothing} p ^ {(-1) ^ {|T| - 1} \min(p, T)} \\&amp;= \prod\limits_{T \subseteq S, T \ne \varnothing} \left(p ^ {\min(p, T)}\right) ^ {(-1) ^ {|T| - 1} }\end{aligned}$$</div><p>那么有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}\mathrm{lcm}(S) &amp;= \prod\limits_p p ^ {\max(p, S)} \\&amp;= \prod\limits_{p} \prod\limits_{T \subseteq S, T \ne \varnothing} \left(p ^ {\min(p, T)}\right) ^ {(-1) ^ {|T| - 1} } \\&amp;= \prod\limits_{T \subseteq S, T \ne \varnothing} \left(\prod\limits_p p ^ {\min(p, T)}\right) ^ {(-1) ^ {|T| - 1} } \\&amp;= \prod\limits_{T \subseteq S, T \ne \varnothing} \gcd(T) ^ {(-1) ^ {|T| - 1}}\end{aligned}$$</div><p><strong>我们来看看 <span class="markdown-them-math-inline">$\rm Gcd-Lcm$</span> 反演有什么应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p><strong>前路<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>出题人<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>本校学长 @<span class="markdown-them-math-inline">$\rm remoon$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>:</strong></p><p>给定 <span class="markdown-them-math-inline">$A,B,C$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\mathrm{lcm}(i,j,k)$$</div><p>保证 <span class="markdown-them-math-inline">$A,B,C\leqslant 5\times 10^4$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案对 <span class="markdown-them-math-inline">$10^9+7$</span> 取模<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>首先给出一个复杂度估界为 <span class="markdown-them-math-inline">$\Theta(n^2)$</span> 的做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但实测非常快<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p><p>请注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以下的推导遵循一个原则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对 <span class="markdown-them-math-inline">$i, j, k$</span> 做相同变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不会先处理一部分再处理一部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}Ans &amp;= \sum\limits_{i = 1} ^ A \sum\limits_{j = 1} ^ B \sum\limits_{k = 1} ^ C \mathrm{lcm}(i, j, k) \\&amp;= \sum\limits_{i = 1} ^ A \sum\limits_{j = 1} ^ B \sum\limits_{k = 1} ^ C \frac{ijk(i, j, k)}{(i, j)(j, k)(k, i)} \qquad (\mathrm{Min-Max} ~ for ~ index) \\&amp;= \sum\limits_{i = 1} ^ A \sum\limits_{j = 1} ^ B \sum\limits_{k = 1} ^ C \frac{ijk}{(i, j)(j, k)(k, i)} \left( f \times \mu \times I \left((i, j, k)\right)\right) \qquad (f(i) = i)\\&amp;= \sum\limits_{d = 1} ^ A f \times \mu (d) \sum\limits_{i = 1} ^ {A / d} \sum\limits_{i = 1} ^ {B / d} \sum\limits_{i = 1} ^ {C / d} \frac{ijk}{(i, j)(j, k)(k, i)}\end{aligned}$$</div><p>令 <span class="markdown-them-math-inline">$F(A, B, C) = \sum\limits_{i = 1} ^ A \sum\limits_{i = 1} ^ B \sum\limits_{i = 1} ^ C \dfrac{ijk}{(i, j)(j, k)(k, i)}, g(i) = \dfrac{1}{i}, h = g \times \mu$</span> 则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}F(A, B, C) &amp;= \sum\limits_{i = 1} ^ A \sum\limits_{i = 1} ^ B \sum\limits_{i = 1} ^ C ijk ( f \times \mu \times I ((i, j)))( f \times \mu \times I ((j, k)))( f \times \mu \times I ((k, i))) \\&amp;= \sum\limits_{i = 1} ^ A \sum\limits_{i = 1} ^ B \sum\limits_{i = 1} ^ C ijk \sum\limits_{x \mid (i, j)} g \times \mu(x) \sum\limits_{y \mid (j, k)} g \times \mu(y) \sum\limits_{z \mid (k, i)} g \times \mu(z) \\&amp;= \sum\limits_{x = 1} ^ A \sum\limits_{y = 1} ^ B \sum\limits_{z = 1} ^ C h(x) h(y) h(z) \sum\limits_{x, z \mid i} i \sum\limits_{x, y \mid j} j \sum\limits_{y, z \mid k} k \\&amp;= \sum\limits_{x = 1} ^ A \sum\limits_{y = 1} ^ B \sum\limits_{z = 1} ^ C h(x) h(y) h(z) \sum\limits_{i = 1} ^ {A / \mathrm{lcm}(x, z)} i \times \mathrm{lcm}(x, z) \sum\limits_{j = 1} ^ {B / \mathrm{lcm}(x, y)} j \times \mathrm{lcm}(x, y) \sum\limits_{k = 1} ^ {C / \mathrm{lcm}(y, z)} k \times \mathrm{lcm}(y, z) \\&amp;= \sum\limits_{x = 1} ^ A \sum\limits_{y = 1} ^ B \sum\limits_{z = 1} ^ C h(x) h(y) h(z) S(A, \mathrm{lcm}(x, z)) S(B, \mathrm{lcm}(x, y)) S(C, \mathrm{lcm}(y, z))\end{aligned}$$</div><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后者 <span class="markdown-them-math-inline">$x \rightarrow y \rightarrow z \rightarrow x$</span> 构成了一个三元环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以大概给出估界为 <span class="markdown-them-math-inline">$\mathcal{O(n \log n \log \log n)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 因此暴力找出所有三元环的复杂度为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathcal{O(n \log n \log \log n\sqrt{n \log n \log \log n})}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为这个在 <span class="markdown-them-math-inline">$n = 5000$</span> 时与 <span class="markdown-them-math-inline">$n ^ 2$</span> 无区别<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此连边可以使用暴力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但也可以枚举 <span class="markdown-them-math-inline">$\mathrm{Lcm}$</span> 再枚举其约数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用 <span class="markdown-them-math-inline">$\mathcal{O(n \log ^ 3n)}$</span> 连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>此时我们算完了 <span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可知总共需要算的 <span class="markdown-them-math-inline">$F$</span> 只有 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若将单次复杂度看作 <span class="markdown-them-math-inline">$n ^ 2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此总复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\mathcal{O(n ^ 2\sum\limits_{i = 1} ^ {n} \frac{1}{i ^ 2})} = O(n ^ 2)$$</div><p>经过卡常之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>效率提升大约五倍多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以下是如何卡常的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>我写了一个大范围内的打表程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现实际原做法的连边数量大约是 <span class="markdown-them-math-inline">$n \log n \log \log n$</span> 级别的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此这个做法很有卡常前途<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li><p>我们把暴力连边换掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举其约数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用 <span class="markdown-them-math-inline">$\mathcal{O(n \log ^ 3n)}$</span> 连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>连边暴力判断时不要求 <span class="markdown-them-math-inline">$\rm lcm$</span> 只需要求 <span class="markdown-them-math-inline">$\gcd(i / d_j, i / d_k)$</span> 具体参见代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果你想要过本题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是一定要优化连边的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>可以发现我们需要调用的 <span class="markdown-them-math-inline">$\rm lcm$</span> 只有每条边的两个端点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而在枚举 <span class="markdown-them-math-inline">$\rm Lcm$</span> 时是可以 <span class="markdown-them-math-inline">$\mathcal{O(1)}$</span> 得知的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此我们在连边时记录这个值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S$</span> 函数有很多是无用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有用的第一维只有 <span class="markdown-them-math-inline">$\sqrt{A}$</span> 个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此可以只预处理 <span class="markdown-them-math-inline">$A \sqrt{A}$</span> 个值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p><span class="markdown-them-math-inline">$\gcd$</span> 请不要暴力求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们记忆化 <span class="markdown-them-math-inline">$a, b \leqslant 2e4$</span> 的部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并用 <span class="markdown-them-math-inline">$\rm short$</span> 类型存储<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>减少空间消耗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p><strong>然后我们再给出一个复杂度为 <span class="markdown-them-math-inline">$\Theta(n^{1.5})$</span> 的正解做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p><p>方便起见用 <span class="markdown-them-math-inline">$(x, y)$</span> 代指 <span class="markdown-them-math-inline">$\operatorname{gcd}(x, y)$</span></p><div class="markdown-them-math-block">$$\sum_{i=1}^{A} \sum_{j=1}^{B} \sum_{k=1}^{C} \frac{(i, j, k) i j k}{(i, j)(j, k)(i, k)}$$</div><p>枚举 <span class="markdown-them-math-inline">$d$</span>, 设 <span class="markdown-them-math-inline">$F(A, B, C)=\sum_{i=1}^{A} \sum_{j=1}^{B} \sum_{k=1}^{C} \frac{i j k}{(i, j)(j, k)(i, k)}$</span> 考虑计算:</p><div class="markdown-them-math-block">$$\sum_{d} \varphi(d) F\left(\frac{A}{d}, \frac{B}{d}, \frac{C}{d}\right)$$</div><p>令 <span class="markdown-them-math-inline">$n=\max (A, B, C)$</span>, 假定我们可以在 <span class="markdown-them-math-inline">$\mathcal{O}\left(n^{c} \log ^{k} n\right)$</span> 的复杂度计算一组 <span class="markdown-them-math-inline">$F(A, B, C)$</span>, 则当 <span class="markdown-them-math-inline">$c&gt;1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>恒有 <span class="markdown-them-math-inline">$\sum \frac{1}{d^{c}}$</span> 是收敛的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以认为其为常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> (不过比较大)<br>只需要考虑快速计算一组 <span class="markdown-them-math-inline">$F(A, B, C)$</span>, <span class="markdown-them-math-inline">$\rm remoon$</span> 给出的做法是同时反演三组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后考虑通过三元环计数来计算答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里给出略为不同的思路:</p><div class="markdown-them-math-block">$$\begin{aligned}&amp;F(A, B, C)=\sum_{i=1}^{A} \sum_{j=1}^{B} \sum_{k=1}^{C} \frac{i j k}{(i, j)(j, k)(i, k)} \\&amp;=\sum_{k} k \sum_{d}(f * \mu)(d) \sum_{d \mid i}^{A} \frac{i}{\operatorname{gcd}(i, k)} \sum_{d \mid j}^{B} \frac{j}{\operatorname{gcd}(j, k)} \\&amp;=\sum_{k} k \sum_{d}(f * \mu)(d) \frac{d^{2}}{\operatorname{gcd}(k, d)^{2}}\left(\sum_{i=1}^{A / d} \frac{i}{\operatorname{gcd}\left(i, \frac{k}{\operatorname{gcd}(k, d)}\right)}\right)\left(\sum_{i=1}^{B / d} \frac{i}{\operatorname{gcd}\left(i, \frac{k}{\operatorname{gcd}(k, d)}\right)}\right)\end{aligned}$$</div><p>不妨设 <span class="markdown-them-math-inline">$F(t, x)=\sum_{i \leq t} \frac{i}{\operatorname{gcd}(i, x)}$</span>, 记 <span class="markdown-them-math-inline">$g(d)=(f * \mu)(d) d^{2}$</span><br>答案等价于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{k}^{C} k \sum_{d} \frac{g(d)}{\operatorname{gcd}(k, d)^{2}} F\left(\frac{A}{d}, \frac{k}{\operatorname{gcd}(k, d)}\right) F\left(\frac{B}{d}, \frac{k}{\operatorname{gcd}(k, d)}\right)$$</div><p>枚举 <span class="markdown-them-math-inline">$\frac{k}{\operatorname{gcd}(k, d)}$</span> 为 <span class="markdown-them-math-inline">$x$</span>, 此时考虑到我们只需要计算 <span class="markdown-them-math-inline">$\mathcal{O}(n \sqrt{n})$</span> 组 <span class="markdown-them-math-inline">$F(n, x)$</span><br>考虑到 <span class="markdown-them-math-inline">$F(n, x)$</span> 事实上就是:</p><div class="markdown-them-math-block">$$\begin{aligned}&amp;\sum_{i=1}^{n} \frac{i}{\operatorname{gcd}(i, x)} \\&amp;=\sum_{d \mid x}(f * \mu)(d) \times d S\left(\frac{n}{d}\right)\end{aligned}$$</div><p>枚举这 <span class="markdown-them-math-inline">$\sqrt{A}$</span> 种 <span class="markdown-them-math-inline">$n$</span>, 可以发现后式就是一个高维前缀和的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以在 <span class="markdown-them-math-inline">$\mathcal{O}\left(n^{1.5} \log \log n \sim n^{1.5} \log n\right)$</span> 的复杂度完成计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 考虑前半部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不妨枚举 <span class="markdown-them-math-inline">$d, \operatorname{gcd}(k, d)$</span> <span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>设为 <span class="markdown-them-math-inline">$t$</span> ) 以及 <span class="markdown-them-math-inline">$x$</span>, 此时我们知道:</p><ul><li><span class="markdown-them-math-inline">$k=x t$</span>, 故 <span class="markdown-them-math-inline">$x t \leq C$</span></li><li><span class="markdown-them-math-inline">$t \mid d$</span></li><li><span class="markdown-them-math-inline">$\operatorname{gcd}\left(\frac{d}{t}, x\right)=1$</span></li><li>固定了 <span class="markdown-them-math-inline">$\frac{A}{d}, \frac{B}{d}$</span> 之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以发现 <span class="markdown-them-math-inline">$d$</span> 属于区间 <span class="markdown-them-math-inline">$[l, r]$</span>, 此时我们考虑将答案差分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>简而言之<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们的任务是计算 <span class="markdown-them-math-inline">$n \sqrt{n}$</span> 次下式:</li><li></li></ul><div class="markdown-them-math-block">$$\begin{aligned}&amp;x \sum_{d \leq R} g(d) \sum_{t \mid d} \frac{1}{t}[x t \leq C]\left[\operatorname{gcd}\left(x, \frac{d}{t}\right)=1\right] \\&amp;=x \sum_{c \mid x} \mu(c) \sum_{c \mid d, d \leq R} g(d) \sum_{t \mid \frac{d}{\epsilon}} \frac{1}{t}\left[t \leq \frac{C}{x}\right]\end{aligned}$$</div><p>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们不难考虑到本质不同的 <span class="markdown-them-math-inline">$\frac{C}{x}$</span> 只有 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以考虑枚举每种 <span class="markdown-them-math-inline">$\frac{C}{x}=m$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并在此时预处理:</p><div class="markdown-them-math-block">$$g(d) \sum_{t \mid d} \frac{1}{t}[t \leq m]$$</div><p>对于某个 <span class="markdown-them-math-inline">$m$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这可以在 <span class="markdown-them-math-inline">$\mathcal{O}(n \log \log n)$</span> 的复杂度完成计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总体而言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此部分可以在 <span class="markdown-them-math-inline">$\mathcal{O}\left(n^{1.5} \log \log n \sim n^{1.5} \log n\right)$</span> 完成预处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设其为 <span class="markdown-them-math-inline">$G\left(d, \frac{C}{x}\right)$</span><br>最后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>让我们为每个 <span class="markdown-them-math-inline">$c$</span> 考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>穷举可能的 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 种 <span class="markdown-them-math-inline">$m$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并为每个 <span class="markdown-them-math-inline">$c$</span> 建立大小为 <span class="markdown-them-math-inline">$\frac{\max R}{c}$</span> 的表格<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然表格的总大小为 <span class="markdown-them-math-inline">$n \log n$</span>, 此时单组查询显然可以做到 <span class="markdown-them-math-inline">$\mathcal{O}(1)$</span>, 由于 <span class="markdown-them-math-inline">$x$</span> 穷举 <span class="markdown-them-math-inline">$1 \sim n$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察其约数个数和显然为 <span class="markdown-them-math-inline">$\mathcal{O}(n \log n)$</span>, 总体而言我们可以在 <span class="markdown-them-math-inline">$\mathcal{O}\left(n^{1.5} \log n\right)$</span> 解决此问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>一点新的思路:<br>我们考虑枚举 <span class="markdown-them-math-inline">$c$</span>, 并为每个 <span class="markdown-them-math-inline">$c$</span>, 对 <span class="markdown-them-math-inline">$\frac{C / c}{x}$</span> 的所有可能的取值进行预处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不难发现这个部分的复杂度为 <span class="markdown-them-math-inline">$\sum\left(\frac{n}{c}\right)^{1.5}$</span><br>通过积分不难证明这部分等效于 <span class="markdown-them-math-inline">$n^{1.5}$</span></p><h2 id="莫比乌斯反演">莫比乌斯反演</h2><h3 id="一些定义和性质">一些定义和性质</h3><p><strong><span class="markdown-them-math-inline">$\rm Dirichlet$</span> 卷积 :</strong> <span class="markdown-them-math-inline">$\sum\limits_{d|n}f(d)g(\frac{n}{d})$</span> 被定义为 <span class="markdown-them-math-inline">$\rm Dirichlet$</span> 卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>莫比乌斯 <span class="markdown-them-math-inline">$(\mu)$</span> 函数 :</strong></p><div class="markdown-them-math-block">$$\mu(n)= \begin{cases}1 &amp; n=1 \\ 0 &amp; n \text { 含有平方因子 } \\ (-1)^{k} &amp; k \text { 为 } n \text { 的本质不同质因子个数 }\end{cases}$$</div><p>显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mu$</span> 是积性函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且它还有一些更加巧妙的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中最常用的一个是 <span class="markdown-them-math-inline">$\mu \times 1=\varepsilon$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\large\rm Proof:$</span></p><p>此处的乘号表示 <span class="markdown-them-math-inline">$\rm Dirichlet$</span> 卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1$</span> 表示常数函数 <span class="markdown-them-math-inline">$\forall x\in [1,+\infty),f(x)=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\varepsilon$</span> 表示单位函数 <span class="markdown-them-math-inline">$\forall x\in [1,+\infty),f(x)=[x=1]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$n=\prod_{i=1}^{k} p_{i}^{c_{i}}, n^{\prime}=\prod_{i=1}^{k} p_{i}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>那么 <span class="markdown-them-math-inline">$\sum\limits_{d \mid n} \mu(d)=\sum\limits_{d \mid n^{\prime}} \mu(d)=\sum\limits_{i=0}^{k}\tbinom{k}{i}\cdot(-1)^{i}=(1+(-1))^{k}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>根据二项式定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>易知该式子的值在 <span class="markdown-them-math-inline">$k=0$</span> 即 <span class="markdown-them-math-inline">$n=1$</span> 时值为 <span class="markdown-them-math-inline">$1$</span> 否则为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这也同时证明了 <span class="markdown-them-math-inline">$\sum\limits_{d \mid n} \mu(d)=[n=1]=\varepsilon(n)$</span> 以及 <span class="markdown-them-math-inline">$\mu * 1=\varepsilon$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="两个反演式子">两个反演式子</h3><div class="markdown-them-math-block">$$[n=1]=\sum_{d|n}\mu(d)$$</div><p><span class="markdown-them-math-inline">$\large\rm Proof:$</span></p><div class="markdown-them-math-block">$$[n=1]=\varepsilon(n)=\mu \times 1(n)=\sum_{d|n}\mu(d)$$</div><p><strong>我们来看看这个式子有什么应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p><a href="http://zhengruioi.com/contest/1010/problem/2017"><strong>例题 :</strong></a> 给定一个长度为 <span class="markdown-them-math-inline">$n$</span> 的序列 <span class="markdown-them-math-inline">$a$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给定 <span class="markdown-them-math-inline">$m$</span> 个询问 <span class="markdown-them-math-inline">$l,r,x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求 <span class="markdown-them-math-inline">$a_l,a_{l+1}......a_r$</span> 中有多少个数与 <span class="markdown-them-math-inline">$x$</span> 互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>保证 <span class="markdown-them-math-inline">$n,m,a_i,x\leqslant 10^5$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑莫比乌斯反演: <span class="markdown-them-math-inline">$\left[\left(a_{i}, x\right)=1\right]=\sum\limits_{\left.d \mid a_{i}, x\right)} \mu(d)=\sum\limits_{d\left|a_{i}, d\right| x} \mu(d)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由于答案求 <span class="markdown-them-math-inline">$\sum\limits_{i=l}^{r}\left[\left(a_{i}, x\right)=1\right]=\sum\limits_{i=l}^{r} \sum\limits_{d\left|a_{i}, d\right| x} \mu(d)=\sum\limits_{d \mid x} \mu(d) \sum\limits_{i=l}^{r}\left[d \mid a_{i}\right]_{\text {.}}$</span></p><p>考虑对于每一个数, 预处理出它的倍数出现在哪些位置, 然后询问时枚举所有 <span class="markdown-them-math-inline">$x$</span> 的因数, 二分一下即可求出 <span class="markdown-them-math-inline">$[l, r]$</span> 内它的倍数有多少个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \sigma(\operatorname{maxa}) \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑对上述算法进行优化 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>我们可以只考虑 <span class="markdown-them-math-inline">$\mu$</span> 值不等于 <span class="markdown-them-math-inline">$0$</span> 的因数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>考虑预处理出小于 <span class="markdown-them-math-inline">$\sqrt{maxa}$</span> 的所有因数的前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样对于这些因数的询问是 <span class="markdown-them-math-inline">$\Theta(1)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>考虑我们相当于要求 <span class="markdown-them-math-inline">$q$</span> 个询问不大于 <span class="markdown-them-math-inline">$x$</span> 的为某个数的倍数的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>先将这些点排个序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后就可以直接 <span class="markdown-them-math-inline">$\rm two~pointers$</span> 求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>时间复杂度可以降到 <span class="markdown-them-math-inline">$\Theta(n\sigma(maxa))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>三者实现其一即可通过本题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f(n)=\sum_{d|n}g(d)\iff g(n)=\sum_{d|n}\mu(d)f\left(\frac{n}{d}\right)$$</div><p><span class="markdown-them-math-inline">$\large\rm Proof:$</span></p><div class="markdown-them-math-block">$$\because f=g\times I$$</div><div class="markdown-them-math-block">$$\therefore f\times \mu=g\times I \times \mu$$</div><div class="markdown-them-math-block">$$\therefore f\times \mu=g\times \varepsilon = g$$</div><p><strong>我们来看看这个式子有什么应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p><a href="https://www.luogu.com.cn/problem/P2522"><strong><span class="markdown-them-math-inline">$\rm [HAOI2011]Problem~B$</span> :</strong></a> 给出 <span class="markdown-them-math-inline">$n$</span> 个询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个询问给定 <span class="markdown-them-math-inline">$5$</span> 个整数 <span class="markdown-them-math-inline">$a,b,c,d,k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{i=a}^{b}\sum_{j=c}^d[\gcd(i,j)=k]$$</div><p>保证 <span class="markdown-them-math-inline">$n,a,b,c,d,k\leqslant 5\times 10^4$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>根据容斥原理, 原式可以分成 <span class="markdown-them-math-inline">$4$</span> 块来处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每一块的式子都形如 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{i=1}^{n} \sum_{j=1}^{m}[\operatorname{gcd}(i, j)=k]$$</div><p>考虑化简该式子 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor} \sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}[\operatorname{gcd}(i, j)=1]$$</div><p>因为 <span class="markdown-them-math-inline">$\operatorname{gcd}(i, j)=1$</span> 时对答案才有贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们可以将其替换为 <span class="markdown-them-math-inline">$\varepsilon(\operatorname{gcd}(i, j))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故原式化为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor} \sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor} \varepsilon(\operatorname{gcd}(i, j))$$</div><p>将 <span class="markdown-them-math-inline">$\varepsilon$</span> 函数展开得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor} \sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor} \sum_{d \mid \operatorname{gcd}(i, j)} \mu(d)$$</div><p>变换求和顺序, 先枚举 <span class="markdown-them-math-inline">$d \mid \operatorname{gcd}(i, j)$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{d=1}^{\min \left(\left\lfloor\frac{n}{k}\right\rfloor,\left\lfloor\frac{m}{k}\right\rfloor\right)} \mu(d) \sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}[d \mid i] \sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}[d \mid j]$$</div><p>易知 <span class="markdown-them-math-inline">$1 \sim\left\lfloor\frac{n}{k}\right\rfloor$</span> 中 <span class="markdown-them-math-inline">$d$</span> 的倍数有 <span class="markdown-them-math-inline">$\left\lfloor\frac{n}{k d}\right\rfloor$</span> 个, 故原式化为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{d=1}^{\min \left(\left\lfloor\frac{n}{k}\right\rfloor,\left\lfloor\frac{m}{k}\right\rfloor\right)} \mu(d)\left\lfloor\frac{n}{k d}\right\rfloor\left\lfloor\frac{m}{k d}\right\rfloor$$</div><p>很显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>式子可以数论分块求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(W+n\sqrt{W})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="莫比乌斯反演的非卷积形式">莫比乌斯反演的非卷积形式</h3><p>对于数论函数 <span class="markdown-them-math-inline">$f,g$</span> 和完全积性函数 <span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="markdown-them-math-inline">$t(1)=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f(n)=\sum_{i=1}^nt(i)g\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\ \iff g(n)=\sum_{i=1}^n\mu(i)t(i)f\left(\left\lfloor\frac{n}{i}\right\rfloor\right)$$</div><p><span class="markdown-them-math-inline">$\large\rm Proof:$</span></p><div class="markdown-them-math-block">$$\begin{aligned} g(n)&amp;=\sum_{i=1}^n\mu(i)t(i)f\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\ &amp;=\sum_{i=1}^n\mu(i)t(i) \sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}t(j) g\left(\left\lfloor\frac{\left\lfloor\frac{n}{i}\right\rfloor}{j}\right\rfloor\right)\\ &amp;=\sum_{i=1}^n\mu(i)t(i) \sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}t(j) g\left(\left\lfloor\frac{n}{ij}\right\rfloor\right)\\ &amp;=\sum_{T=1}^n \sum_{i=1}^n\mu(i)t(i) \sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}[ij=T] t(j)g\left(\left\lfloor\frac{n}{T}\right\rfloor\right) &amp;\\ &amp;=\sum_{T=1}^n \sum_{i \mid T}\mu(i)t(i) t\left(\frac{T}{i}\right)g\left(\left\lfloor\frac{n}{T}\right\rfloor\right) \\ &amp;=\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right) \sum_{i \mid T}\mu(i)t(i)t\left(\frac{T}{i}\right)\\ &amp;=\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right) \sum_{i \mid T}\mu(i)t(T)\\ &amp;=\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)t(T) \sum_{i \mid T}\mu(i)\\ &amp;=\sum_{T=1}^ng\left(\left\lfloor\frac{n}{T}\right\rfloor\right)t(T) \varepsilon(T) &amp;\\ &amp;=g(n)t(1) &amp;\\ &amp;=g(n) &amp; \end{aligned}$$</div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」杜教筛</title>
      <link href="/2023/06/24/shu-xue-du-jiao-shai/"/>
      <url>/2023/06/24/shu-xue-du-jiao-shai/</url>
      
        <content type="html"><![CDATA[<p>杜教筛学习笔记及严谨的复杂度证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><p>杜教筛被用来求积性函数的前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设有积性函数 <span class="markdown-them-math-inline">$f(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其前缀和为 <span class="markdown-them-math-inline">$S(n) = \sum \limits_ {i = 1} ^ n f(i)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑构造 <span class="markdown-them-math-inline">$h(x)$</span> 和 <span class="markdown-them-math-inline">$g(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="markdown-them-math-inline">$h = f \times g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>推一下式子 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    \sum _ {i = 1} ^ n h(i) &amp;= \sum _ {i = 1} ^ n \sum _ {d | i} g(d) \times f\left(\frac{i}{d}\right) \\    &amp;= \sum _ {d = 1} ^ n g(d) \sum _ {i = 1} ^ {\left\lfloor\frac{n}{d}\right\rfloor} f(i) \\    &amp;= \sum _ {d = 1} ^ n g(d) S\left(\left\lfloor\frac{n}{d}\right\rfloor\right)\end{aligned}$$</div><p>众所周知有数论分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>观察到式子右边的 <span class="markdown-them-math-inline">$S\left(\left\lfloor\frac{n}{d}\right\rfloor\right)$</span> 最多有 <span class="markdown-them-math-inline">$2\sqrt{n}$</span> 种取值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>证明考虑 <span class="markdown-them-math-inline">$\sum \limits_ {d = 1} ^ {\sqrt{n}} \left\lfloor\frac{n}{d}\right\rfloor$</span> 显然最多有 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 种取值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\forall d &gt; \sqrt{n},\left\lfloor\frac{n}{d}\right\rfloor &lt; \sqrt{n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$\sum \limits_ {d = \sqrt{n} + 1} ^ {n} \left\lfloor\frac{n}{d}\right\rfloor$</span> 也最多有 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 种取值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是这时候只需要考虑对于一个数 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="markdown-them-math-inline">$\left\lfloor\frac{n}{i}\right\rfloor = \left\lfloor\frac{n}{j}\right\rfloor$</span> 的最大的 <span class="markdown-them-math-inline">$j$</span> 是多少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$k = \left\lfloor\frac{n}{i}\right\rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有 <span class="markdown-them-math-inline">$\left\lfloor\frac{n}{j}\right\rfloor = k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将向下取整去掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$k \leqslant \frac{n}{j} &lt; k + 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取倒数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="markdown-them-math-inline">$\frac{1}{k + 1} &lt; \frac{j}{n} \leqslant \frac{1}{k}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>全部乘上 <span class="markdown-them-math-inline">$n$</span> 得到 <span class="markdown-them-math-inline">$\frac{n}{k + 1} &lt; j \leqslant \frac{n}{k}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>又因为 <span class="markdown-them-math-inline">$j$</span> 为整数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$j_{\max} = \left\lfloor\frac{n}{k}\right\rfloor = \left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>言归正传<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求解杜教筛最终式子时可以直接递归<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>中间需要记忆化一下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但其实不需要用到 <span class="markdown-them-math-inline">$\rm map$</span> 系列 <span class="markdown-them-math-inline">$\rm STL$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为可以证明需要求解的 <span class="markdown-them-math-inline">$S(x)$</span> 中 <span class="markdown-them-math-inline">$x \in \{\left\lfloor\frac{n}{d}\right\rfloor{}|d \in [1, n]\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>稍加思考就可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上式的一个充分条件为 <span class="markdown-them-math-inline">$\left\lfloor\frac{\left\lfloor\frac{n}{i}\right\rfloor}{j}\right\rfloor = \left\lfloor\frac{n}{ij}\right\rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑其证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$\forall x \in Z$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若有 <span class="markdown-them-math-inline">$x \leqslant \left\lfloor\frac{\left\lfloor\frac{n}{i}\right\rfloor}{j}\right\rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么有 <span class="markdown-them-math-inline">$xj \leqslant \left\lfloor\frac{n}{i}\right\rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进一步有 <span class="markdown-them-math-inline">$xij \leqslant n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再将 <span class="markdown-them-math-inline">$ij$</span> 放回去有 <span class="markdown-them-math-inline">$x \leqslant \left\lfloor\frac{n}{ij}\right\rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>原式得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>故我们只需要将 <span class="markdown-them-math-inline">$\left\lfloor\frac{n}{d}\right\rfloor~(d \in [1, n] \cap Z)$</span> 的所有取值映射到一个数组上就可以直接记忆化了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑复杂度证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记忆化以后每个 <span class="markdown-them-math-inline">$S(x)$</span> 只需要算一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而算一次 <span class="markdown-them-math-inline">$S(x)$</span> 的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(\sqrt{x})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 故总时间复杂度为 <span class="markdown-them-math-inline">$\sum\limits_{x} \sqrt{x}~(x \in \{\left\lfloor\frac{n}{d}\right\rfloor|d \in [1, n] \cap Z\})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 对于不大于 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 的 <span class="markdown-them-math-inline">$d$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其贡献的复杂度上界为 <span class="markdown-them-math-inline">$\sum \limits_{i = 1} ^ {\sqrt{n}} \Theta\left(\sqrt{\frac{n}{i}}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而对于大于 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 的 <span class="markdown-them-math-inline">$d$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\left\lfloor\frac{n}{d}\right\rfloor$</span> 的取值不大于 <span class="markdown-them-math-inline">$\sqrt{n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以其贡献的上界为 <span class="markdown-them-math-inline">$\sum \limits_{i = 1} ^ {\sqrt{n}} \Theta(\sqrt{i})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其和为 <span class="markdown-them-math-inline">$T(n) = \sum \limits_{i = 1} ^ {\sqrt{n}} \Theta\left(\sqrt{\frac{n}{i}}\right) + \sum \limits_{i = 1} ^ {\sqrt{n}} \Theta(\sqrt{i})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>积分求个近似可以得到 <span class="markdown-them-math-inline">$T(n) \approx \int_{1}^{\sqrt{n}} \Theta\left(\sqrt{\frac{n}{x}}\right) dx + \int_{1}^{\sqrt{n}} \Theta(\sqrt{x}) dx = \Theta(n ^ {\frac{3}{4}})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>事实上还可以做到更优<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>线性预处理 <span class="markdown-them-math-inline">$f$</span> 的前 <span class="markdown-them-math-inline">$m$</span> 项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>易知复杂度变成了 <span class="markdown-them-math-inline">$\Theta(m) + \Theta\left(\sum \limits_{i = 1} ^ {\frac{n}{m}} \sqrt{\frac{n}{i}}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跟之前一样积分近似一下可以得到复杂度即为 <span class="markdown-them-math-inline">$\Theta(m + nm ^ {-\frac{1}{2}})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>易知其下界为 <span class="markdown-them-math-inline">$\Theta(n ^ {\frac{2}{3}})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><hr><p>在此列举一些常见的构造<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>其证明需要用到迪利克雷生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>略过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><span class="markdown-them-math-inline">$(id ^ k \cdot \mu) \times id ^ k = \varepsilon$</span></li><li><span class="markdown-them-math-inline">$(id ^ k \cdot \varphi) \times id ^ k = id ^ {k + 1}$</span></li><li><span class="markdown-them-math-inline">$(id ^ k \cdot \sigma _ k) \times (id ^ k \cdot \mu) = id ^ {2k}$</span></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」多项式</title>
      <link href="/2023/06/24/shu-xue-duo-xiang-shi/"/>
      <url>/2023/06/24/shu-xue-duo-xiang-shi/</url>
      
        <content type="html"><![CDATA[<p>多项式科技学习笔记及模板<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="拉格朗日插值">拉格朗日插值</h2><p>插值问题形如 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>给定 <span class="markdown-them-math-inline">$n$</span> 个点的坐标 <span class="markdown-them-math-inline">$(x, y)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求出一个经过所有点的最低次多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="一般插值">一般插值</h3><p>容易构造出 <span class="markdown-them-math-inline">$f(x)$</span> 即为下式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f(x) = \sum _{i = 1} ^{n} y_i \prod _{j \not= i} \frac{x - x_j}{x_i - x_j}\tag{1.1.1}$$</div><p>正确性显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>容易证明多项式次数至少为 <span class="markdown-them-math-inline">$n - 1$</span> 才可以确保穿过 <span class="markdown-them-math-inline">$n$</span> 个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故最优性得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n^ 2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e3</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, k, x[N], y[N], ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> ( ; k; a = <span class="hljs-number">1ll</span> * a * a % mod, k &gt;&gt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x[i], &amp;y[i]);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;        <span class="hljs-keyword">int</span> S1 = <span class="hljs-number">1</span>, S2 = <span class="hljs-number">1</span>;        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) <span class="hljs-keyword">if</span> (j != i) &#123;            S1 = <span class="hljs-number">1ll</span> * S1 * (k - x[j]) % mod;            S2 = <span class="hljs-number">1ll</span> * S2 * (x[i] - x[j]) % mod;        &#125;        ans = (ans + <span class="hljs-number">1ll</span> * y[i] * S1 % mod * <span class="hljs-built_in">Pow</span>(S2, mod - <span class="hljs-number">2</span>)) % mod;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (ans + mod) % mod);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="点值连续的插值">点值连续的插值</h3><p>当给定的点值连续时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>式子可以改写为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    f(x) = \sum _{i = 1} ^{n} y_i \prod _{j \not= i} \frac{x - j}{i - j} = \sum _{i = 1} ^{n} y_i \frac{\prod \limits _{j \not= i}(x - j)}{\prod \limits_{j \not= i}(i - j)}\end{aligned}$$</div><p>考虑计算分子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$pre_i = \prod _{j = 1} ^{i} (x - j), suf_i = \prod _{j = i} ^{n} (x - j)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然 <span class="markdown-them-math-inline">$\prod _{j \not= i}(x - j) = pre_{i - 1}\times suf_{i + 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑计算分母<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$sym(x) = 1 - 2[x \equiv 1 \pmod 2]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然 <span class="markdown-them-math-inline">$\prod _{j \not= i}(i - j) = (i - 1)!\times sym(n - i)(n - i)!$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>全部带入可将式 <span class="markdown-them-math-inline">$(1.2.1)$</span> 改写为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f(x) = \sum _{i = 1} ^n y_i \frac{pre_{i - 1}\times suf_{i + 1}}{(i - 1)!\times sym(n - i)(n - i)!} \tag{1.2.2}$$</div><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">F</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, k + <span class="hljs-number">2</span>) fac[i] = fac[i - <span class="hljs-number">1</span>] * i % mod;    inv[k + <span class="hljs-number">2</span>] = <span class="hljs-built_in">Pow</span>(fac[k + <span class="hljs-number">2</span>], mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">dep</span>(i, k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) inv[i] = inv[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % mod;    pre[<span class="hljs-number">0</span>] = suf[k + <span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, k + <span class="hljs-number">2</span>) pre[i] = pre[i - <span class="hljs-number">1</span>] * (n - i) % mod;    <span class="hljs-built_in">dep</span>(i, k + <span class="hljs-number">2</span>, <span class="hljs-number">1</span>) suf[i] = suf[i + <span class="hljs-number">1</span>] * (n - i) % mod;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, k + <span class="hljs-number">2</span>) y[i] = (y[i - <span class="hljs-number">1</span>] + <span class="hljs-built_in">Pow</span>(i, k)) % mod;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, k + <span class="hljs-number">2</span>) res = (res + y[i] * pre[i - <span class="hljs-number">1</span>] % mod * suf[i + <span class="hljs-number">1</span>] % mod * inv[i - <span class="hljs-number">1</span>] % mod * inv[k + <span class="hljs-number">2</span> - i] * (((k + <span class="hljs-number">2</span> - i) &amp; <span class="hljs-number">1</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>)) % mod;    <span class="hljs-keyword">return</span> (res + mod) % mod;&#125;</code></pre></div><h3 id="重心拉格朗日插值法">重心拉格朗日插值法</h3><p>考虑一般插值的优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>观察式 <span class="markdown-them-math-inline">$(1.1.1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 :</p><div class="markdown-them-math-block">$$G = \prod _{i = 1} ^n (x - x_i) \tag{1.3.1}$$</div><div class="markdown-them-math-block">$$T_i = \frac{y_i}{\prod \limits_{j \not= i} (x_i - x_j)} \tag{1.3.2}$$</div><p>将式 <span class="markdown-them-math-inline">$(1.3.1)$</span> 和 <span class="markdown-them-math-inline">$(1.3.2)$</span> 带入式 <span class="markdown-them-math-inline">$(1.1.1)$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f(x) = G \sum _{i = 1} ^{n} \frac{T_i}{x - x_i} \tag{1.3.3}$$</div><p>如此一来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>新加入一个点就只需要计算它的 <span class="markdown-them-math-inline">$T$</span> 值了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="还原插值多项式的系数">还原插值多项式的系数</h3><p>考虑对式 <span class="markdown-them-math-inline">$(1.1.1)$</span> 作变形 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f(x) = \sum _{i = 1} ^{n} \frac{y_i}{\prod \limits_{j \not= i}(x_i - x_j)} \prod _{j \not= i} (x - x_j)\tag{1.4.1}$$</div><p>可以 <span class="markdown-them-math-inline">$\Theta(n^2)$</span> 预处理 <span class="markdown-them-math-inline">$\prod_{i = 1}^n (x - x_i)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后在需要求 <span class="markdown-them-math-inline">$\prod _{j \not= i} (x - x_j)$</span> 时将预处理出的多项式除以 <span class="markdown-them-math-inline">$(x - x_i)$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以做到单次 <span class="markdown-them-math-inline">$\Theta(n)$</span> 的时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>还原插值多项式系数的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="自然数幂前缀和">自然数幂前缀和</h3><p>有定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>不大于 <span class="markdown-them-math-inline">$n$</span> 的自然数 <span class="markdown-them-math-inline">$k$</span> 次幂和是一个关于 <span class="markdown-them-math-inline">$n$</span> 的 <span class="markdown-them-math-inline">$k + 1$</span> 次多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\rm Proof :$</span></p><p>设 <span class="markdown-them-math-inline">$f_k(n) = \sum \limits _{i = 1} ^n i ^ k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当 <span class="markdown-them-math-inline">$k = 1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f_k(n) = \sum \limits _{i = 1} ^n i = \frac{1}{2}n ^ 2 + \frac{1}{2} n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是一个 <span class="markdown-them-math-inline">$k + 1$</span> 次多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>假设 <span class="markdown-them-math-inline">$f_{k - 1}(n)$</span> 是一个关于 <span class="markdown-them-math-inline">$n$</span> 的 <span class="markdown-them-math-inline">$k$</span> 次多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>即 <span class="markdown-them-math-inline">$f_{k - 1}(n) = a_0 + a_1 n + a_2 n ^ 2 + \cdots + a_k n ^ k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    f_k(n) &amp;= \sum _{i = 1} ^n i\times i ^ {k - 1}\\    &amp;= \sum _{i = 0} ^{n - 1} f_{k - 1}(n) - f_{k - 1}(i)\\    &amp;= nf_{k - 1}(n) - \sum _{i = 1} ^{n - 1} f_{k - 1}(i)\\    &amp;= a_0 n + a_1 n ^ 2 + \cdots + a_k n ^ {k + 1} - \sum _{i = 1} ^{n - 1} f_{k - 1}(i)\end{aligned}$$</div><p>容易发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于 <span class="markdown-them-math-inline">$f_{k - 1}(i)$</span> 中次数最高的项为 <span class="markdown-them-math-inline">$k$</span> 次项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且 <span class="markdown-them-math-inline">$f_k(n)$</span> 中含有关于 <span class="markdown-them-math-inline">$n$</span> 的 <span class="markdown-them-math-inline">$k + 1$</span> 次项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$f_k(n)$</span> 是关于 <span class="markdown-them-math-inline">$n$</span> 的 <span class="markdown-them-math-inline">$k + 1$</span> 次多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>归纳可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$\forall k\geqslant 1,~f_k(n)$</span> 是关于 <span class="markdown-them-math-inline">$n$</span> 的 <span class="markdown-them-math-inline">$k$</span> 次多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是可以使用点值连续的拉格朗日插值计算 <span class="markdown-them-math-inline">$\sum \limits_{i = 1} ^n i^k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="快速傅里叶变换">快速傅里叶变换</h2><p>快速傅里叶变换 <span class="markdown-them-math-inline">$\rm (Fast~Fourier~Transformation,FFT)$</span> 被用来在 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span> 的时间复杂度下求两个多项式的乘积<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>和卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>若称 <span class="markdown-them-math-inline">$h(x) = f(x) \times g(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则应满足关系式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$h(k) = \sum _{i + j = k} f(i) \times g(j) \tag{2.0.1}$$</div><h3 id="单位根">单位根</h3><p>众所周知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有欧拉公式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$e^{i\theta} = \cos \theta + i\sin \theta \tag{2.1.1}$$</div><p>根据高中课本上所讲的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们知道任意一个复数可以被表示成 <span class="markdown-them-math-inline">$r(\cos \theta + i\sin \theta)$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据式 <span class="markdown-them-math-inline">$(2.1.1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现其等价于 <span class="markdown-them-math-inline">$r \cdot e^{i\theta}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以两个复数相乘<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>模长 <span class="markdown-them-math-inline">$(r)$</span> 相乘<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>幅角 <span class="markdown-them-math-inline">$(\theta)$</span> 相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑方程 <span class="markdown-them-math-inline">$x ^ n = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现它在复数域内有 <span class="markdown-them-math-inline">$n$</span> 个解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解集为 <span class="markdown-them-math-inline">$\{e^{i\theta}~|~\theta = \frac{2k\pi}{n},k = 0,1,2, \cdots, n - 1 \}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将其简记为 <span class="markdown-them-math-inline">$\omega_n^0,\omega_n^1,\cdots,\omega_n^{n - 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进一步观察可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它们是复平面中单位圆上的 <span class="markdown-them-math-inline">$n$</span> 等分点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>之所以会在 <span class="markdown-them-math-inline">$\rm FFT$</span> 中用到单位根<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主要是因为它具有以下性质 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><strong>折半性质 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></li></ul><div class="markdown-them-math-block">$$\omega_{2n} ^ {2k} = \omega _n ^k \tag{2.1.2}$$</div><p><span class="markdown-them-math-inline">$\rm Proof :$</span> 显然有 <span class="markdown-them-math-inline">$\omega_n ^k = (\omega _n ^1) ^k$</span> 和 <span class="markdown-them-math-inline">$\omega _n ^ 1 = \omega _{2n} ^2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li><strong>对称性质 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></li></ul><div class="markdown-them-math-block">$$\omega _{2n} ^ {k + n} = -\omega _{2n} ^{k} \tag{2.1.3}$$</div><p><span class="markdown-them-math-inline">$\rm Proof :$</span> 这里定义 <span class="markdown-them-math-inline">$-z$</span> 为 <span class="markdown-them-math-inline">$z$</span> 关于原点的对称点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有 <span class="markdown-them-math-inline">$\omega _{2n} ^n = -1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\omega _{2n} ^{k + n} = \omega _{2n} ^k\times \omega _{2n} ^n = -\omega _{2n} ^k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li><strong>求和性质</strong> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></li></ul><div class="markdown-them-math-block">$$\sum _{i = 0} ^{n - 1} \left(\omega_{n} ^k\right) ^i = n[k = 0] \tag{2.1.4}$$</div><p><span class="markdown-them-math-inline">$\rm Proof :$</span></p><p>首先使用等比数列求和公式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum _{i = 0} ^{n - 1} \left(\omega_{n} ^k\right) ^i = \frac{1 - \left(\omega_{n} ^k\right)^n}{1 - \omega_n^k} \tag{2.1.5}$$</div><p>考虑分类讨论 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>当 <span class="markdown-them-math-inline">$k = 0$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>原式显然等于 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>当 <span class="markdown-them-math-inline">$k \not = 0$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1 - \omega_n^k \not = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1 - \left(\omega_{n} ^k\right)^n = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故原式等于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><h3 id="离散傅里叶变换">离散傅里叶变换</h3><p>离散傅里叶变换 <span class="markdown-them-math-inline">$\rm (Discrete~Fourier~Transform,DFT)$</span> 被用于求出多项式的 <span class="markdown-them-math-inline">$n$</span> 个点值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$n$</span> 为多项式的项数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\rm DFT$</span> 是 <span class="markdown-them-math-inline">$\rm FFT$</span> 的前半部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于一个多项式 <span class="markdown-them-math-inline">$F(x) = a_0 + a_1 x + a_2 x^2 + \cdots + a_{n - 1} x ^ {n - 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不妨设 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    F_1(x) = a_0 + a_2x + a_4x^2 + \cdots + a_{n - 2}x^{\frac{n}{2} - 1}\\    F_2(x) = a_1 + a_3x + a_5x^2 + \cdots + a_{n - 1}x^{\frac{n}{2} - 1}\end{aligned}$$</div><p>于是有 <span class="markdown-them-math-inline">$F(x) = F_1(x^2) + xF_2(x^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>将 <span class="markdown-them-math-inline">$\omega_n^k$</span> 带入可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(\omega_n^k) = F_1(\omega_n^{2k}) + \omega_n^k F_2(\omega_n^{2k}) \tag{2.2.1}$$</div><p>根据式 <span class="markdown-them-math-inline">$(2.1.2)$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(\omega_n^k) = F_1(\omega_{n/2}^{k}) + \omega_n^k F_2(\omega_{n/2}^{k}) \tag{2.2.2}$$</div><p>考虑分类讨论 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>对于 <span class="markdown-them-math-inline">$k &lt; \frac{n}{2} $</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要直接递归处理 <span class="markdown-them-math-inline">$F_1$</span> 和 <span class="markdown-them-math-inline">$F_2$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>对于 <span class="markdown-them-math-inline">$k \geqslant \frac{n}{2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们不妨它为 <span class="markdown-them-math-inline">$k + \frac{n}{2}~(k &lt; \frac{n}{2})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></li></ul><div class="markdown-them-math-block">$$F(\omega_n^{k + n/2}) = F_1(\omega_n^{2k + n}) + \omega_n^{k + n/2} F_2(\omega_n^{2k + n}) \tag{2.2.3}$$</div><p>根据式 <span class="markdown-them-math-inline">$(2.1.2)$</span> 和 <span class="markdown-them-math-inline">$(2.1.3)$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(\omega _ n ^ k) = F_1(\omega_{n / 2} ^ k) - \omega _ n ^ k F_2(\omega_{n/2}^k) \tag{2.2.4}$$</div><p>观察发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>式 <span class="markdown-them-math-inline">$(2.2.2)$</span> 和 <span class="markdown-them-math-inline">$(2.2.4)$</span> 之间仅相差一个符号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这意味着我们只需要递归求出 <span class="markdown-them-math-inline">$F_1$</span> 和 <span class="markdown-them-math-inline">$F_2$</span> 的 <span class="markdown-them-math-inline">$\frac{n}{2}$</span> 个点值就可以在 <span class="markdown-them-math-inline">$\Theta(n)$</span> 的时间复杂度下求出 <span class="markdown-them-math-inline">$F$</span> 的 <span class="markdown-them-math-inline">$n$</span> 个点值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因为最多递归 <span class="markdown-them-math-inline">$\log n$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每一层的总时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$\rm DFT$</span> 过程的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="离散傅里叶逆变换">离散傅里叶逆变换</h3><p>离散傅里叶逆变换 <span class="markdown-them-math-inline">$\rm (Inverse~Discrete~Fourier~Transform,IDFT)$</span> 被用于将多项式的点值表示还原成系数表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是 <span class="markdown-them-math-inline">$\rm FFT$</span> 的后半部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>在 <span class="markdown-them-math-inline">$\rm DFT$</span> 过程中我们已经将待乘函数 <span class="markdown-them-math-inline">$f(x)$</span> 和 <span class="markdown-them-math-inline">$g(x)$</span> 的点值表示分别求了出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>易知它们卷积的点值序列为它们点值序列各处分别相乘的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$\{G_n\}$</span> 为 <span class="markdown-them-math-inline">$F(x)$</span> 在 <span class="markdown-them-math-inline">$\rm DFT$</span> 过程中求出的点值序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\{F_n\}$</span> 是 <span class="markdown-them-math-inline">$F(x)$</span> 的系数序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则根据定义有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G_k = \sum _{i = 0} ^{n - 1} \left(\omega_{n}^{k}\right) ^ i F_i \tag{2.3.1}$$</div><p>此处有反演结论 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$nF_k = \sum_{i = 0} ^{n - 1} \left(\omega_{n}^{-k}\right) ^ i G_i \tag{2.3.2}$$</div><p><span class="markdown-them-math-inline">$\rm Proof :$</span></p><div class="markdown-them-math-block">$$\begin{aligned}    nF_k &amp;= \sum_{i = 0} ^ {n - 1} \sum _{j = 0} ^ {n - 1} \left(\omega_{n} ^{-k}\right) ^ i \left(\omega_{n} ^{i}\right) ^ j F_j\\    &amp;= \sum_{i = 0} ^ {n - 1} \sum _{j = 0} ^ {n - 1} \omega_{n} ^{i(j - k)} F_j\end{aligned}$$</div><p>将式 <span class="markdown-them-math-inline">$(2.1.4)$</span> 带入 <span class="markdown-them-math-inline">$(2.3.3)$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    nF_k &amp;=  \sum _{j = 0} ^ {n - 1} \sum_{i = 0} ^ {n - 1} \left(\omega_{n} ^{j - k}\right)^i F_j\\    &amp;= \sum_{j = 0} ^ {n - 1} n[j = k] F_j\\    &amp;= nF_k\end{aligned}$$</div><p>故利用式 <span class="markdown-them-math-inline">$(2.3.2)$</span> 将 <span class="markdown-them-math-inline">$\{G_n\}$</span> 带入 <span class="markdown-them-math-inline">$\rm DFT$</span> 过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以 <span class="markdown-them-math-inline">$\omega_n^{-1}$</span> 作为一次单位根得出的点值即为 <span class="markdown-them-math-inline">$F(x)$</span> 的系数序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\rm IDFT$</span> 过程的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>至此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们已经推导出了一个时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以递归实现的 <span class="markdown-them-math-inline">$\rm FFT$</span> 算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于递归时需要两边长度相等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$F(x)$</span> 的长度必须是 <span class="markdown-them-math-inline">$2$</span> 的幂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>少了的部分通过在高次项以 <span class="markdown-them-math-inline">$0$</span> 作为系数来补齐<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="位逆序置换">位逆序置换</h3><p>位逆序置换 <span class="markdown-them-math-inline">$\rm (Bit-Reversal~Permutation)$</span> 是 <span class="markdown-them-math-inline">$\rm FFT$</span> 中一个较大的优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在国内又称蝴蝶变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>它的优化主要在于将原本的递归实现变成了迭代实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>在递归实现中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们每一次都会把整个多项式的奇数次项和偶数次项系数分开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一直分到只剩下一个系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是我们也可以先把这些系数在原数组中拆分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后再倍增地去合并这些算出来的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>以 <span class="markdown-them-math-inline">$8$</span> 项多项式为例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>模拟拆分的过程 :</p><ul><li><p>初始序列为 : <span class="markdown-them-math-inline">$\left\{x_{0}, x_{1}, x_{2}, x_{3}, x_{4}, x_{5}, x_{6}, x_{7}\right\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>一次二分之后 : <span class="markdown-them-math-inline">$\left\{x_{0}, x_{2}, x_{4}, x_{6}\right\},\left\{x_{1}, x_{3}, x_{5}, x_{7}\right\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>两次二分之后 : <span class="markdown-them-math-inline">$\left\{x_{0}, x_{4}\right\}, \left\{x_{2}, x_{6}\right\},\left\{x_{1}, x_{5}\right\},\left\{x_{3}, x_{7}\right\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>三次二分之后 : <span class="markdown-them-math-inline">$\left\{x_{0}\right\}, \left\{x_{4}\right\}, \left\{x_{2}\right\}, \left\{x_{6}\right\}, \left\{x_{1}\right\}, \left\{x_{5}\right\}, \left\{x_{3}\right\}, \left\{x_{7}\right\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要把最后一层每个位置对应的坐标求出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后每次迭代时插空合并相邻两项即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>记 <span class="markdown-them-math-inline">$R(x)$</span> 表示 <span class="markdown-them-math-inline">$x$</span> 在全部分治完后去到的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>观察发现 <span class="markdown-them-math-inline">$R(x)$</span> 是 <span class="markdown-them-math-inline">$x$</span> 在二进制意义下翻转后的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先有 <span class="markdown-them-math-inline">$R(0) = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的考虑从小到大求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$R(x) = \left\lfloor\frac{R\left(\left\lfloor\frac{x}{2}\right\rfloor\right)}{2}\right\rfloor+(x \bmod 2) \times 2^{k - 1} \tag{2.4.1}$$</div><p>求解 <span class="markdown-them-math-inline">$R(x)$</span> 并将每个数换到应该去的位置时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e6</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> Pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Complex</span> &#123;</span> <span class="hljs-keyword">double</span> x, y; &#125; F[N], G[N];Complex <span class="hljs-keyword">operator</span> + (Complex a, Complex b) &#123; <span class="hljs-keyword">return</span> (Complex)&#123;a.x + b.x, a.y + b.y&#125;; &#125;Complex <span class="hljs-keyword">operator</span> - (Complex a, Complex b) &#123; <span class="hljs-keyword">return</span> (Complex)&#123;a.x - b.x, a.y - b.y&#125;; &#125;Complex <span class="hljs-keyword">operator</span> * (Complex a, Complex b) &#123; <span class="hljs-keyword">return</span> (Complex)&#123;a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x&#125;; &#125;<span class="hljs-keyword">int</span> n, m, len, ln, R[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFT</span> <span class="hljs-params">(Complex *F, <span class="hljs-keyword">int</span> type)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (i &lt; R[i]) <span class="hljs-built_in">swap</span>(F[i], F[R[i]]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;        Complex eps = (Complex)&#123;<span class="hljs-built_in">cos</span>(Pi / k), type * <span class="hljs-built_in">sin</span>(Pi / k)&#125;;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>)) &#123;            Complex w = (Complex)&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; i + k; j++, w = w * eps) &#123;                Complex tmp1 = F[j], tmp2 = w * F[j + k];                F[j] = tmp1 + tmp2, F[j + k] = tmp1 - tmp2;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;F[i].x);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;G[i].x);    <span class="hljs-keyword">for</span> (len = <span class="hljs-number">1</span>, ln = <span class="hljs-number">0</span>; len &lt;= n + m; len &lt;&lt;= <span class="hljs-number">1</span>, ln++);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) R[i] = (R[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);    <span class="hljs-built_in">FFT</span>(F, <span class="hljs-number">1</span>), <span class="hljs-built_in">FFT</span>(G, <span class="hljs-number">1</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = F[i] * G[i];    <span class="hljs-built_in">FFT</span>(F, <span class="hljs-number">-1</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n + m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">round</span>(F[i].x / len));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="快速数论变换">快速数论变换</h2><p>由于 <span class="markdown-them-math-inline">$\rm FFT$</span> 对单位根的依赖<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以该算法必须使用浮点数保存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而引发精度问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>糟糕的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数学家已经证明了在复数域内仅有单位根满足所需性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>值得庆幸的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大多数计数问题是在模意义下完成的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们希望为 <span class="markdown-them-math-inline">$\rm FFT$</span> 找一个模意义下的替代品<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终方案为快速数论变换 <span class="markdown-them-math-inline">$\rm (Number~Theoretic~Transform,NTT)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="原根">原根</h3><p>原根的定义如下 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>如果有 <span class="markdown-them-math-inline">$a^n \equiv 1 \pmod p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则称满足此条件最小的 <span class="markdown-them-math-inline">$n$</span> 为 <span class="markdown-them-math-inline">$a$</span> 在模 <span class="markdown-them-math-inline">$p$</span> 意义下的阶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若一个数 <span class="markdown-them-math-inline">$g$</span> 在模 <span class="markdown-them-math-inline">$p$</span> 意义下的原根为 <span class="markdown-them-math-inline">$\varphi(p)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么称 <span class="markdown-them-math-inline">$g$</span> 为 <span class="markdown-them-math-inline">$p$</span> 的原根<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们尝试用原根代替单位根进行运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以需要先证明以下几条性质 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><strong>不重性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></li></ul><div class="markdown-them-math-block">$$\forall 0\leqslant i &lt; j &lt; \varphi (p),g^i \not \equiv g^j \pmod p \tag{3.1.1}$$</div><p><span class="markdown-them-math-inline">$\rm Proof :$</span> 若存在 <span class="markdown-them-math-inline">$0\leqslant i &lt; j &lt; \varphi (p)$</span> 满足 <span class="markdown-them-math-inline">$g^i \equiv g^j \pmod p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$0\leqslant j - i &lt; \varphi (p)$</span> 且 <span class="markdown-them-math-inline">$g^{j - i} \equiv 1 \pmod p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与原根的定义矛盾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故原命题得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li><strong>折半性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></li></ul><p>定义 <span class="markdown-them-math-inline">$g_n^1 = g^{\frac{p - 1}{n}},g_n^k = (g_n^1)^k$</span> 则 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$g_{2n}^{2k} \equiv g_n^k \pmod p \tag{3.1.2}$$</div><p><span class="markdown-them-math-inline">$\rm Proof :$</span> 由式 <span class="markdown-them-math-inline">$(3.1.1)$</span> 可得 <span class="markdown-them-math-inline">$g_n^0,g_n^1,g_n^2,\cdots,g_n^{n - 1}$</span> 互不相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将 <span class="markdown-them-math-inline">$g_n^k$</span> 的定义带入易证式 <span class="markdown-them-math-inline">$(3.1.2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li><strong>对称性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></li></ul><div class="markdown-them-math-block">$$g_{2n}^{k + n} \equiv -g_{2n}^k \pmod p \tag{3.1.3}$$</div><p><span class="markdown-them-math-inline">$\rm Proof :$</span></p><p>参照式 <span class="markdown-them-math-inline">$(2.1.3)$</span> 的证明方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只需要证明 <span class="markdown-them-math-inline">$g_{2n}^n \equiv -1 \pmod p$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$(g_{2n}^n) ^ 2 \equiv (g^{\frac{p - 1}{2}}) ^ 2 \equiv g^{p - 1} \equiv 1 \pmod p \tag{3.1.4}$$</div><p>所以 <span class="markdown-them-math-inline">$g_{2n}^n \equiv 1~or-1 \pmod p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>根据式 <span class="markdown-them-math-inline">$(3.1.1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们知道 <span class="markdown-them-math-inline">$g_{2n}^n \not \equiv g^{p - 1} \pmod p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>又因为 <span class="markdown-them-math-inline">$g^{p - 1} \equiv 1 \pmod p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$g_{2n}^n \equiv -1 \pmod p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li><strong>求和性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></li></ul><div class="markdown-them-math-block">$$\sum _{i = 0} ^{n - 1} \left(g_{n} ^k\right) ^i \equiv n[k = 0] \pmod p \tag{3.1.5}$$</div><p><span class="markdown-them-math-inline">$\rm Proof :$</span> 参照式 <span class="markdown-them-math-inline">$(2.1.4)$</span> 的证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有了以上 <span class="markdown-them-math-inline">$4$</span> 条性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以直接将原根带入 <span class="markdown-them-math-inline">$\rm DFT$</span> 运算了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于 <span class="markdown-them-math-inline">$\rm DFT$</span> 运算中的多项式长度 <span class="markdown-them-math-inline">$n$</span> 均为 <span class="markdown-them-math-inline">$2$</span> 的幂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且我们取的模数 <span class="markdown-them-math-inline">$p$</span> 需要满足 <span class="markdown-them-math-inline">$p - 1$</span> 能整除足够大的 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$p - 1$</span> 要包含一个较大的因子是 <span class="markdown-them-math-inline">$2$</span> 的幂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>比较常用的 <span class="markdown-them-math-inline">$\rm NTT$</span> 模数是 <span class="markdown-them-math-inline">$998244353 = 119 \times 2 ^ {23} + 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的最小原根是 <span class="markdown-them-math-inline">$3$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e6</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, m, len, ln, F[N], G[N], rev[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> ( ; k; a = <span class="hljs-number">1ll</span> * a * a % mod, k &gt;&gt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len) <span class="hljs-keyword">if</span> (i &lt; rev[i]) <span class="hljs-built_in">swap</span>(F[i], F[rev[i]]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> eps = <span class="hljs-built_in">Pow</span>(type ? <span class="hljs-number">3</span> : <span class="hljs-number">332748118</span>, (mod - <span class="hljs-number">1</span>) / (k &lt;&lt; <span class="hljs-number">1</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i, g = <span class="hljs-number">1</span>; j &lt; i + k; j++, g = <span class="hljs-number">1ll</span> * g * eps % mod) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = <span class="hljs-number">1ll</span> * g * F[j + k] % mod;                F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2;                F[j + k] = tmp1 - tmp2 &lt; <span class="hljs-number">0</span> ? tmp1 - tmp2 + mod : tmp1 - tmp2;            &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;F[i]);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;G[i]);    <span class="hljs-keyword">for</span> (len = <span class="hljs-number">1</span>, ln = <span class="hljs-number">0</span>; len &lt;= n + m; len &lt;&lt;= <span class="hljs-number">1</span>, ln++);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);    <span class="hljs-built_in">NTT</span>(F, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(G, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * F[i] * G[i] % mod;    <span class="hljs-built_in">NTT</span>(F, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n + m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, <span class="hljs-number">1ll</span> * F[i] * Inv % mod);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="$\rm-chirp~z$ 变换"><span class="markdown-them-math-inline">$\rm Chirp~Z$</span> 变换</h3><p><span class="markdown-them-math-inline">$\rm Chirp~Z-Transform$</span> 又称 <span class="markdown-them-math-inline">$\rm Bluestein$</span> 算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与 <span class="markdown-them-math-inline">$\rm DFT$</span> 类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它被用于在 <span class="markdown-them-math-inline">$\Theta[(n + m) \log n]$</span> 的时间复杂度内求解如下问题 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>给定 <span class="markdown-them-math-inline">$n$</span> 次多项式 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求出 <span class="markdown-them-math-inline">$F(1),F(c),F(c^2),\cdots,F(c^m)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$c \in \mathbb{C}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑组合恒等式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$ik = \dbinom{i + k}{2} - \dbinom{i}{2} - \dbinom{k}{2} \tag{3.2.1}$$</div><p><span class="markdown-them-math-inline">$\rm Proof :$</span></p><div class="markdown-them-math-block">$$\begin{aligned}    ik &amp;= \frac{2ik}{2}\\    &amp;= \frac{(i ^ 2 + 2ik + k ^ 2 - i - k) - (i ^ 2 - i) - (k ^ 2 - k)}{2}\\    &amp;= \dbinom{i + k}{2} - \dbinom{i}{2} - \dbinom{k}{2}\end{aligned}$$</div><p>于是有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    F(c ^ k) &amp;= \sum _{i = 0} ^ {n - 1} a_i c ^ {ik}\\    &amp;= \sum _{i = 0} ^ {n - 1} a_i c ^ {\binom{i + k}{2} - \binom{i}{2} - \binom{k}{2}}\\    &amp;= c ^ {-\binom{k}{2}} \sum _{i = 0} ^{n - 1} \left[a_i c ^ {-\binom{i}{2}} \right] \left[c ^ {\binom{i + k}{2}} \right]\end{aligned}$$</div><p>设 <span class="markdown-them-math-inline">$f(x) = c ^ {\binom{x}{2}}, g(x) = a_xc^{-\binom{x}{2}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\frac{F(c ^ k)}{c ^ {-\binom{k}{2}}} = \sum _ {i - j = k} f(i) \times g(j) \tag{3.2.4}$$</div><p>可以使用减法卷积来计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta[(n + m) \log n]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算减法卷积时一般将 <span class="markdown-them-math-inline">$g(x)$</span> 翻转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$g'(i) = g(m - i)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    \frac{F(c ^ k)}{c ^ {-\binom{k}{2}}} &amp;= \sum _ {i - j = k} f(i) \times g(j)\\    &amp;= \sum _ {i + j = m + k} f(i) \times g'(j)\end{aligned}$$</div><p>计算式 <span class="markdown-them-math-inline">$(3.2.5)$</span> 时可以先对 <span class="markdown-them-math-inline">$f(x)$</span> 和 <span class="markdown-them-math-inline">$g(x)$</span> 求和卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称得到的多项式为 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>假设 <span class="markdown-them-math-inline">$f(x)$</span> 的次数为 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g(x)$</span> 的次数为 <span class="markdown-them-math-inline">$m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$F(x)$</span> 有 <span class="markdown-them-math-inline">$n + m + 1$</span> 项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在 <span class="markdown-them-math-inline">$F(x)$</span> 的第 <span class="markdown-them-math-inline">$k$</span> 个位置实际上为答案的第 <span class="markdown-them-math-inline">$m + k$</span> 项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以要将多项式向左平移 <span class="markdown-them-math-inline">$m$</span> 位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$F'(k) = F(k + m)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e6</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, m, c, len, ln, inv, tmp, a[N], p[N], R[N], F[N], G[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> ( ; k; a = <span class="hljs-number">1ll</span> * a * a % mod, k &gt;&gt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (i &lt; R[i]) <span class="hljs-built_in">swap</span>(F[i], F[R[i]]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> E = <span class="hljs-built_in">Pow</span>(type ? <span class="hljs-number">3</span> : <span class="hljs-number">332748118</span>, (mod - <span class="hljs-number">1</span>) / (k &lt;&lt; <span class="hljs-number">1</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i, G = <span class="hljs-number">1</span>; j &lt; i + k; j++, G = <span class="hljs-number">1ll</span> * G * E % mod) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = <span class="hljs-number">1ll</span> * G * F[j + k] % mod;                F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2;                F[j + k] = tmp1 - tmp2 &lt; <span class="hljs-number">0</span> ? tmp1 - tmp2 + mod : tmp1 - tmp2;            &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;c, &amp;m), n--, m--;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);    inv = <span class="hljs-built_in">Pow</span>(c, mod - <span class="hljs-number">2</span>);    <span class="hljs-keyword">for</span> (len = <span class="hljs-number">1</span>, ln = <span class="hljs-number">0</span>; len &lt;= n + m; len &lt;&lt;= <span class="hljs-number">1</span>, ln++);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) R[i] = (R[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);    F[<span class="hljs-number">0</span>] = F[<span class="hljs-number">1</span>] = tmp = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, n + m) tmp = <span class="hljs-number">1ll</span> * tmp * c % mod, F[i] = <span class="hljs-number">1ll</span> * F[i - <span class="hljs-number">1</span>] * tmp % mod;    p[<span class="hljs-number">0</span>] = p[<span class="hljs-number">1</span>] = tmp = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, <span class="hljs-built_in">max</span>(n, m)) tmp = <span class="hljs-number">1ll</span> * tmp * inv % mod, p[i] = <span class="hljs-number">1ll</span> * p[i - <span class="hljs-number">1</span>] * tmp % mod;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) G[i] = <span class="hljs-number">1ll</span> * a[i] * p[i] % mod;    <span class="hljs-built_in">reverse</span>(G, G + n + <span class="hljs-number">1</span>);    <span class="hljs-built_in">NTT</span>(F, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(G, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * F[i] * G[i] % mod;    <span class="hljs-built_in">NTT</span>(F, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * F[i] * Inv % mod;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-number">1ll</span> * F[n + i] * p[i] % mod);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="分治多项式乘法">分治多项式乘法</h3><p>有些时候我们知道 <span class="markdown-them-math-inline">$G(x)$</span> 的所有项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要计算 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且它们满足关系 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F_k = \sum _{i = 0} ^ {k - 1} F_iG_{k - i} \tag{3.3.1}$$</div><p>这时候可以考虑采用 <span class="markdown-them-math-inline">$\rm CDQ$</span> 分治的思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先递归计算左边半部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再计算左边对右边的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现贡献是卷积的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是可以用 <span class="markdown-them-math-inline">$\rm FFT/NTT$</span> 以 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span> 的时间复杂度计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>分治多项式乘法的时间复杂度为 <span class="markdown-them-math-inline">$T(n) = 2T(\frac{n}{2}) + \Theta(n \log n) = \Theta(n \log^2 n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, F[N], G[N], rev[N], Ft[N], Gt[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (; k; a = <span class="hljs-number">1ll</span> * a * a % mod, k &gt;&gt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (i &lt; rev[i]) <span class="hljs-built_in">swap</span>(F[i], F[rev[i]]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> eps = <span class="hljs-built_in">Pow</span>(type ? <span class="hljs-number">3</span> : <span class="hljs-number">332748118</span>, (mod - <span class="hljs-number">1</span>) / (k &lt;&lt; <span class="hljs-number">1</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i, g = <span class="hljs-number">1</span>; j &lt; i + k; j++, g = <span class="hljs-number">1ll</span> * g * eps % mod) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = <span class="hljs-number">1ll</span> * g * F[j + k] % mod;                F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2;                F[j + k] = tmp1 - tmp2 &lt; <span class="hljs-number">0</span> ? tmp1 - tmp2 + mod : tmp1 - tmp2;            &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cdq</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt;= <span class="hljs-number">30</span>) &#123;        <span class="hljs-built_in">rep</span>(i, l + <span class="hljs-number">1</span>, r) <span class="hljs-built_in">rep</span>(j, l, i - <span class="hljs-number">1</span>)            F[i] = (F[i] + <span class="hljs-number">1ll</span> * F[j] * G[i - j]) % mod;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">cdq</span>(l, mid);    <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>, ln = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (; len &lt;= r + mid - <span class="hljs-number">2</span> * l; len &lt;&lt;= <span class="hljs-number">1</span>, ln++);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, mid - l) Ft[i] = F[i + l];    <span class="hljs-built_in">rep</span>(i, mid - l + <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>) Ft[i] = <span class="hljs-number">0</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, r - l) Gt[i] = G[i];    <span class="hljs-built_in">NTT</span>(len, Ft, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, Gt, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) Ft[i] = <span class="hljs-number">1ll</span> * Ft[i] * Gt[i] % mod;    <span class="hljs-built_in">NTT</span>(len, Ft, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">rep</span>(i, mid - l + <span class="hljs-number">1</span>, r - l) F[i + l] = (F[i + l] + <span class="hljs-number">1ll</span> * Ft[i] * Inv) % mod;    <span class="hljs-built_in">cdq</span>(mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n), n--;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;G[i]);    F[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, <span class="hljs-built_in">cdq</span>(<span class="hljs-number">0</span>, n);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, F[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="快速沃尔什变换">快速沃尔什变换</h2><p>快速沃尔什变换 <span class="markdown-them-math-inline">$\rm (Fast~Walsh–Hadamard~Transform,FWT)$</span> 被用来在 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span> 的时间复杂度下求两个多项式的位运算卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>若称 <span class="markdown-them-math-inline">$h(x) = f(x) \oplus g(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$\oplus$</span> 是 <span class="markdown-them-math-inline">$\rm or,and$</span> 或 <span class="markdown-them-math-inline">$\rm xor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则应满足关系式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$h(k) = \sum _{i \oplus j = k} f(i) \times g(j) \tag{4.0.1}$$</div><h3 id="构造-$\rm fwt$ 函数">构造 <span class="markdown-them-math-inline">$\rm FWT$</span> 函数</h3><p>在 <span class="markdown-them-math-inline">$\rm FFT$</span> 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们通过将多项式转换成点值表示并进行点积的方法避开了卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们自然也希望将位运算卷积通过某种方式转换成点积运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$F' = FWT(F)$</span> 表示幂级数 <span class="markdown-them-math-inline">$F$</span> 经过 <span class="markdown-them-math-inline">$\rm FWT$</span> 变换后得到的幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>容易发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们构造的 <span class="markdown-them-math-inline">$\rm FWT$</span> 变换需要满足 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$A \times B = C \iff FWT(A) \cdot FWT(B) = FWT(C) \tag{4.1.1}$$</div><p>由于 <span class="markdown-them-math-inline">$\rm DFT$</span> 是线性变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们自然希望 <span class="markdown-them-math-inline">$\rm FWT$</span> 也是线性变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑设 <span class="markdown-them-math-inline">$k_{i, j}$</span> 表示 <span class="markdown-them-math-inline">$F_j$</span> 对 <span class="markdown-them-math-inline">$F'_i$</span> 的贡献系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F'_i = \sum _{j = 0} ^ {n - 1} k_{i, j} F_j \tag{4.1.2}$$</div><p>根据 <span class="markdown-them-math-inline">$FWT(A) \cdot FWT(B) = FWT(C)$</span> 可以得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$A'_i \times B'_i = C'_i \tag{4.1.3}$$</div><div class="markdown-them-math-block">$$\left(\sum _{j = 0} ^ {n - 1} k_{i, j} A_j\right)\left(\sum _{p = 0} ^ {n - 1} k_{i, p} B_p\right) = \sum_{j = 0} ^ {n - 1} k_{i, j} C_j \tag{4.1.4}$$</div><div class="markdown-them-math-block">$$\sum _{j = 0} ^ {n - 1}\sum _{p = 0} ^ {n - 1} k_{i, j} k_{i, p} A_j   B_p = \sum_{j = 0} ^ {n - 1} k_{i, j} C_j \tag{4.1.5}$$</div><p>根据 <span class="markdown-them-math-inline">$A \times B = C$</span> 可以得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$C_p = \sum _{i \oplus j = p} A_i\times B_j \tag{4.1.6}$$</div><div class="markdown-them-math-block">$$\sum_{p = 0} ^ {n - 1} k_{i, p} C_p = \sum_{p = 0} ^ {n - 1} k_{i, p}\sum _{t \oplus j = p} A_t B_j \tag{4.1.7}$$</div><div class="markdown-them-math-block">$$\begin{aligned}    \sum _{j = 0} ^ {n - 1}\sum _{p = 0} ^ {n - 1} k_{i, j} k_{i, p} A_j  B_p &amp;= \sum_{p = 0} ^ {n - 1} k_{i, p}\sum _{t \oplus j = p} A_t B_j \\    &amp;= \sum _{p = 0} ^{n - 1} \sum _{t \oplus j = p} k_{i, t \oplus j} A_t B_j\\    &amp;= \sum _{t = 0} ^ {n - 1} \sum_{j = 0} ^ {n - 1} k_{i, t \oplus j} A_t B_j\end{aligned}$$</div><p>对比式 <span class="markdown-them-math-inline">$(4.1.8)$</span> 中两边系数可以发现只需要满足 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$k_{i, j}k_{i, p} = k_{i, j \oplus p} \tag{4.1.9}$$</div><p>假设我们已经求出了 <span class="markdown-them-math-inline">$k_{0, 0},k_{0,1},k_{1,0},k_{1,1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么可以构造 <span class="markdown-them-math-inline">$k_{i, j} = \prod_t k_{i_t,j_t}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$a_t$</span> 表示 <span class="markdown-them-math-inline">$a$</span> 在二进制下的第 <span class="markdown-them-math-inline">$t$</span> 位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种构造方式导出的变换系数 <span class="markdown-them-math-inline">$k$</span> 推导 <span class="markdown-them-math-inline">$k_{i, j}k_{i, p} = k_{i, j \oplus p}$</span> 的充分性容易证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="求解-$\rm fwt$ 变换">求解 <span class="markdown-them-math-inline">$\rm FWT$</span> 变换</h3><p>现在我们需要快速求解下式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F'_i = \sum _{j = 0} ^{n - 1} k_{i, j} F_j \tag{4.2.1}$$</div><p>我们考虑按位折半计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下面设 <span class="markdown-them-math-inline">$\hat{x}$</span> 表示 <span class="markdown-them-math-inline">$x$</span> 去除二进制首位以后的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    F'_i &amp;= \sum _{j = 0} ^{n / 2 - 1} k_{i, j} F_j + \sum _{j = n / 2} ^{n - 1} k_{i, j} F_j \\    &amp;= \sum _{j = 0} ^{n / 2 - 1} k_{i_0, j_0}k_{\hat{i}, \hat{j}} F_j + \sum _{j = n / 2} ^{n - 1} k_{i_0, j_0}k_{\hat{i}, \hat{j}} F_j \\    &amp;= k_{i_0, 0}\sum _{j = 0} ^{n / 2 - 1} k_{\hat{i}, \hat{j}} F_j + k_{i_0, 1}\sum _{j = n / 2} ^{n - 1} k_{\hat{i}, \hat{j}} F_j\end{aligned}$$</div><p>设 <span class="markdown-them-math-inline">$F^0$</span> 表示幂级数 <span class="markdown-them-math-inline">$F'$</span> 下标的二进制首位为 <span class="markdown-them-math-inline">$0$</span> 的部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>相似地定义 <span class="markdown-them-math-inline">$F^1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li>若 <span class="markdown-them-math-inline">$i_0 = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有 <span class="markdown-them-math-inline">$F'_i = k_{0, 0} F^0_i + k_{0, 1} F^1_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>若 <span class="markdown-them-math-inline">$i_0 = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有 <span class="markdown-them-math-inline">$F'_{i + n/2} = k_{1, 0} F^0_i + k_{1, 1} F^1_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>在该算法中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次迭代会将长度减半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>合并一层的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以总时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>此外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>逆变换 <span class="markdown-them-math-inline">$\rm (IFWT)$</span> 时对变换矩阵 <span class="markdown-them-math-inline">$k$</span> 求个逆即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="构造位矩阵">构造位矩阵</h3><p>针对不同的位运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要构造不同的位矩阵 <span class="markdown-them-math-inline">$k$</span> 以拟合 <span class="markdown-them-math-inline">$\rm FWT$</span> 变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="或卷积">或卷积</h4><p>首先我们知道 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$k_{p, i}\times k_{p, j} = k_{p, i | j} \tag{4.3.1}$$</div><p>首先可以观察到 <span class="markdown-them-math-inline">$k_{p, i} \times k_{p, i} = k_{p, i}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$k_{p, i} \in \{0, 1\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后可以发现 <span class="markdown-them-math-inline">$k_{p, 0} \times k_{p, 1} = k_{p, 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$k_{p, 0} = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 又因为矩阵如果一列都是 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么它没有逆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$k$</span> 仅可能为以下两种之一 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{bmatrix} 1&amp;0\\1&amp;1 \end{bmatrix}~or~\begin{bmatrix} 1&amp;1\\1&amp;0 \end{bmatrix} \tag{4.3.2}$$</div><p>由于右边那种等价于高维前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以我选择右边那种<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>事实上两种都可以<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    F'_i &amp;= F^0_i\\    F'_{i + n/2} &amp;= F^0_i + F^1_i\end{aligned}$$</div><p>对于逆变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将矩阵求个逆就可以得到 <span class="markdown-them-math-inline">$k^{-1} = \begin{bmatrix} 1&amp;0\\-1&amp;1 \end{bmatrix}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    IF_i &amp;= IF^{0}_i\\    IF_{i + n/2} &amp;= -IF^0_i + IF^1_i\end{aligned}$$</div><h4 id="与卷积">与卷积</h4><p>可以发现与卷积同或卷积几乎完全一样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此处不赘述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅给出其位矩阵和逆位矩阵 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$k = \begin{bmatrix} 1&amp;1\\0&amp;1 \end{bmatrix},k^{-1} = \begin{bmatrix} 1&amp;-1\\0&amp;1 \end{bmatrix} \tag{4.3.5}$$</div><h4 id="异或卷积">异或卷积</h4><p>首先我们知道 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$k_{p, i}\times k_{p, j} = k_{p, i~xor~j} \tag{4.3.6}$$</div><p>因为 <span class="markdown-them-math-inline">$k_{0, 0} \times k_{x, y} = k_{x, y}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$k_{0, 0} = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因为 <span class="markdown-them-math-inline">$k_{1, 1} \times k_{1, 1} = k_{1, 0}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时若 <span class="markdown-them-math-inline">$k_{1, 1} = k_{1, 0} = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有一行为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>矩阵无逆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$k_{1, 1},k_{1, 0} \not= 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因为 <span class="markdown-them-math-inline">$k_{1, 0} \times k_{1, 1} = k_{1, 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>又因为 <span class="markdown-them-math-inline">$k_{1, 1} \not = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$k_{1, 0} = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因为 <span class="markdown-them-math-inline">$k_{1, 1} \times k_{1, 1} = k_{1, 0} = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$k_{1, 1} \in \{1, -1\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因为 <span class="markdown-them-math-inline">$k_{0,1} \times k_{0, 1} = k_{0, 0} = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$k_{0, 1} \in \{1, -1\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因为 <span class="markdown-them-math-inline">$k_{0, 1}$</span> 和 <span class="markdown-them-math-inline">$k_{1, 1}$</span> 不能相等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则行列式为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>矩阵无逆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$k$</span> 仅可能为以下两种之一 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{bmatrix} 1&amp;1\\-1&amp;1 \end{bmatrix}~or~\begin{bmatrix} 1&amp;1\\1&amp;-1 \end{bmatrix} \tag{4.3.7}$$</div><p>我们采用第二种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可推知 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    F'_i &amp;= F^0_i + F^1_i\\    F'_{i + n/2} &amp;= F^0_i - F^1_i\end{aligned}$$</div><p>对 <span class="markdown-them-math-inline">$k$</span> 求逆可以得到 <span class="markdown-them-math-inline">$k^{-1} = \begin{bmatrix} \frac{1}{2}&amp;\frac{1}{2}\\\frac{1}{2}&amp;-\frac{1}{2} \end{bmatrix}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    IF_i &amp;= \frac{IF^0_i + IF^1_i}{2}\\    IF_{i + n/2} &amp;= \frac{IF^0_i - IF^1_i}{2}\end{aligned}$$</div><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span>, mod = <span class="hljs-number">998244353</span>, Inv = <span class="hljs-number">499122177</span>;<span class="hljs-keyword">int</span> n, len, a[N], b[N], F[N], G[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OR</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; i + k; j++)                F[j + k] = (F[j + k] + (type ? F[j] : -F[j])) % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AND</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; i + k; j++) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = F[j + k];                F[j] = ((type ? <span class="hljs-number">0</span> : -tmp1) + tmp2) % mod;                F[j + k] = (tmp1 + (type ? tmp2 : <span class="hljs-number">0</span>)) % mod;            &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">XOR</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; i + k; j++) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = F[j + k];                F[j] = (type ? <span class="hljs-number">2ll</span> : <span class="hljs-number">1ll</span>) * Inv * (tmp1 + tmp2) % mod;                F[j + k] = (type ? <span class="hljs-number">2ll</span> : <span class="hljs-number">1ll</span>) * Inv * (tmp1 - tmp2) % mod;            &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n), len = <span class="hljs-number">1</span> &lt;&lt; n;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = a[i], G[i] = b[i];    <span class="hljs-built_in">OR</span>(F, <span class="hljs-literal">true</span>), <span class="hljs-built_in">OR</span>(G, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * F[i] * G[i] % mod;    <span class="hljs-built_in">OR</span>(F, <span class="hljs-literal">false</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, F[i] &lt; <span class="hljs-number">0</span> ? F[i] + mod : F[i]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = a[i], G[i] = b[i];    <span class="hljs-built_in">AND</span>(F, <span class="hljs-literal">true</span>), <span class="hljs-built_in">AND</span>(G, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * F[i] * G[i] % mod;    <span class="hljs-built_in">AND</span>(F, <span class="hljs-literal">false</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, F[i] &lt; <span class="hljs-number">0</span> ? F[i] + mod : F[i]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = a[i], G[i] = b[i];    <span class="hljs-built_in">XOR</span>(F, <span class="hljs-literal">true</span>), <span class="hljs-built_in">XOR</span>(G, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * F[i] * G[i] % mod;    <span class="hljs-built_in">XOR</span>(F, <span class="hljs-literal">false</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, F[i] &lt; <span class="hljs-number">0</span> ? F[i] + mod : F[i]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="多项式基本操作">多项式基本操作</h2><p>多项式之间除了乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还可以做一些其它的基本操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但它们都是基于多项式乘法的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="多项式求逆">多项式求逆</h3><p>若两个多项式 <span class="markdown-them-math-inline">$F(x)$</span> 和 <span class="markdown-them-math-inline">$G(x)$</span> 满足 <span class="markdown-them-math-inline">$F(x)G(x) = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则称它们互为逆元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作 <span class="markdown-them-math-inline">$G(x) = F^{-1}(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>求解多项式乘法逆元的时候考虑使用倍增的思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不断扩大倍增上界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当多项式的界为 <span class="markdown-them-math-inline">$\bmod~x$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接对多项式的常数项求逆元即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$G(x) = F^{-1}(x) \pmod {x^n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们已经求出了 <span class="markdown-them-math-inline">$G'(x) = F^{-1}(x) \pmod {x^{n/2}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G(x) - G'(x) \equiv 0 \pmod {x^{n/2}} \tag{5.1.1}$$</div><p>为了能配出 <span class="markdown-them-math-inline">$x ^ n$</span> 作为模数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑将式子两边同时平方<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G^2(x) - 2G(x)G'(x) + G'^2(x) \equiv 0 \pmod {x ^ n} \tag{5.1.2}$$</div><p>因为 <span class="markdown-them-math-inline">$F(x)G(x) = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以式子两边同时乘 <span class="markdown-them-math-inline">$F(x)$</span> 并整理可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G(x) = 2G'(x) - G'^2(x)F(x) \pmod {x ^ n} \tag{5.1.3}$$</div><p>根据式 <span class="markdown-them-math-inline">$(5.1.3)$</span> 可以倍增求出 <span class="markdown-them-math-inline">$F^{-1}(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度为 <span class="markdown-them-math-inline">$T(n) = T(\frac{n}{2}) + \Theta(n \log n) = \Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, len, ln, F[N], R[N], G[N], g[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> ( ; k; a = <span class="hljs-number">1ll</span> * a * a % mod, k &gt;&gt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (i &lt; R[i]) <span class="hljs-built_in">swap</span>(F[i], F[R[i]]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> eps = <span class="hljs-built_in">Pow</span>(type ? <span class="hljs-number">3</span> : <span class="hljs-number">332748118</span>, (mod - <span class="hljs-number">1</span>) / (k &lt;&lt; <span class="hljs-number">1</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += k &lt;&lt; <span class="hljs-number">1</span>)            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i, g = <span class="hljs-number">1</span>; j &lt; i + k; j++, g = <span class="hljs-number">1ll</span> * g * eps % mod) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = <span class="hljs-number">1ll</span> * g * F[j + k] % mod;                F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2;                F[j + k] = tmp1 - tmp2 &lt; <span class="hljs-number">0</span> ? tmp1 - tmp2 + mod : tmp1 - tmp2;            &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">INV</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *F)</span> </span>&#123;    G[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Pow</span>(F[<span class="hljs-number">0</span>], mod - <span class="hljs-number">2</span>);    <span class="hljs-keyword">for</span> (len = <span class="hljs-number">4</span>, ln = <span class="hljs-number">2</span>; len &lt;= (n &lt;&lt; <span class="hljs-number">2</span>); len &lt;&lt;= <span class="hljs-number">1</span>, ln++) &#123;        <span class="hljs-built_in">rep</span>(i, len &gt;&gt; <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>) G[i] = g[i] = <span class="hljs-number">0</span>;        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) g[i] = F[i];        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) R[i] = (R[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);        <span class="hljs-built_in">NTT</span>(G, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(g, <span class="hljs-literal">true</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) G[i] = <span class="hljs-number">1ll</span> * G[i] * (<span class="hljs-number">2</span> - <span class="hljs-number">1ll</span> * G[i] * g[i] % mod + mod) % mod;        <span class="hljs-built_in">NTT</span>(G, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) G[i] = <span class="hljs-number">1ll</span> * G[i] * Inv % mod;        <span class="hljs-built_in">rep</span>(i, len &gt;&gt; <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>) G[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) F[i] = G[i];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n), n--;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;F[i]);    <span class="hljs-built_in">INV</span>(n, F);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, (F[i] + mod) % mod);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="多项式开方">多项式开方</h3><p>若两个多项式 <span class="markdown-them-math-inline">$F(x)$</span> 和 <span class="markdown-them-math-inline">$G(x)$</span> 满足 <span class="markdown-them-math-inline">$G^2(x) = F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则称 <span class="markdown-them-math-inline">$F(x)$</span> 开根后为 <span class="markdown-them-math-inline">$G(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作 <span class="markdown-them-math-inline">$G(x) = F^{\frac{1}{2}}(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>与多项式求逆一样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>多项式开根也利用了倍增法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当多项式的界为 <span class="markdown-them-math-inline">$\bmod~x$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接对常数项使用二次剩余即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$G(x) = F^{\frac{1}{2}}(x) \pmod {x ^ n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们已经求出了 <span class="markdown-them-math-inline">$G'(x) = F^{\frac{1}{2}}(x) \pmod {x ^ {n / 2}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G'^2 (x) - F(x) \equiv 0 \pmod {x ^ {n / 2}} \tag{5.2.1}$$</div><p>对式 <span class="markdown-them-math-inline">$(5.2.1)$</span> 两边同时平方并作简单变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\left[G'^2(x) + F(x)\right] ^ 2 \equiv 4G'^2(x)F(x) \pmod {x ^ n} \tag{5.2.2}$$</div><p>对式子两边同时除以 <span class="markdown-them-math-inline">$4G'^2(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\left[\frac{G'^2(x) + F(x)}{2G'(x)}\right] ^ 2 \equiv F(x) \pmod {x ^ n} \tag{5.2.3}$$</div><p>结合 <span class="markdown-them-math-inline">$G(x)$</span> 的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G(x) = \frac{1}{2}G'(x) + \frac{1}{2}G'^{-1}(x)F(x) \pmod {x ^ n} \tag{5.2.4}$$</div><p>根据式 <span class="markdown-them-math-inline">$(5.2.4)$</span> 可以倍增求出 <span class="markdown-them-math-inline">$F^{\frac{1}{2}}(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度为 <span class="markdown-them-math-inline">$T(n) = T(\frac{n}{2}) + \Theta(n \log n) = \Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, F[N], rev[N], GI[N], FI[N], iG[N], GS[N], FS[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> ( ; k; a = <span class="hljs-number">1ll</span> * a * a % mod, k &gt;&gt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (i &lt; rev[i]) <span class="hljs-built_in">swap</span>(F[i], F[rev[i]]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> eps = <span class="hljs-built_in">Pow</span>(type ? <span class="hljs-number">3</span> : <span class="hljs-number">332748118</span>, (mod - <span class="hljs-number">1</span>) / (k &lt;&lt; <span class="hljs-number">1</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i, g = <span class="hljs-number">1</span>; j &lt; i + k; j++, g = <span class="hljs-number">1ll</span> * g * eps % mod) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = <span class="hljs-number">1ll</span> * g * F[j + k] % mod;                F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2;                F[j + k] = tmp1 - tmp2 &lt; <span class="hljs-number">0</span> ? tmp1 - tmp2 + mod : tmp1 - tmp2;            &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">INV</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *F)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n &lt;&lt; <span class="hljs-number">2</span>) FI[i] = GI[i] = <span class="hljs-number">0</span>;    GI[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Pow</span>(F[<span class="hljs-number">0</span>], mod - <span class="hljs-number">2</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">4</span>, ln = <span class="hljs-number">2</span>; len &lt;= n &lt;&lt; <span class="hljs-number">2</span>; len &lt;&lt;= <span class="hljs-number">1</span>, ln++) &#123;        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) FI[i] = F[i];        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);        <span class="hljs-built_in">NTT</span>(len, GI, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, FI, <span class="hljs-literal">true</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">1ll</span> * GI[i] * (<span class="hljs-number">2</span> - <span class="hljs-number">1ll</span> * GI[i] * FI[i] % mod + mod) % mod;        <span class="hljs-built_in">NTT</span>(len, GI, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">1ll</span> * GI[i] * Inv % mod;        <span class="hljs-built_in">rep</span>(i, len &gt;&gt; <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) iG[i] = GI[i];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SQR</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *F)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n &lt;&lt; <span class="hljs-number">2</span>) FS[i] = GS[i] = <span class="hljs-number">0</span>;    GS[<span class="hljs-number">0</span>] = <span class="hljs-built_in">sqrt</span>(F[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">4</span>, ln = <span class="hljs-number">2</span>; len &lt;= n &lt;&lt; <span class="hljs-number">2</span>; len &lt;&lt;= <span class="hljs-number">1</span>, ln++) &#123;        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) FS[i] = F[i];        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);        <span class="hljs-built_in">INV</span>((len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>, GS);        <span class="hljs-built_in">NTT</span>(len, GS, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, FS, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, iG, <span class="hljs-literal">true</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) GS[i] = <span class="hljs-number">499122177ll</span> * (GS[i] + <span class="hljs-number">1ll</span> * FS[i] * iG[i] % mod) % mod;        <span class="hljs-built_in">NTT</span>(len, GS, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) GS[i] = <span class="hljs-number">1ll</span> * GS[i] * Inv % mod;        <span class="hljs-built_in">rep</span>(i, len &gt;&gt; <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>) GS[i] = <span class="hljs-number">0</span>;     &#125;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) F[i] = GS[i];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n), n--;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;F[i]);    <span class="hljs-built_in">SQR</span>(n, F);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, F[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="多项式带余除法">多项式带余除法</h3><p>给定多项式 <span class="markdown-them-math-inline">$F(x)$</span> 和 <span class="markdown-them-math-inline">$G(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若满足关系式 <span class="markdown-them-math-inline">$Q(x)G(x) + R(x) = F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则称 <span class="markdown-them-math-inline">$Q(x)$</span> 和 <span class="markdown-them-math-inline">$R(x)$</span> 分别是 <span class="markdown-them-math-inline">$F(x)$</span> 除以 <span class="markdown-them-math-inline">$G(x)$</span> 的商和余数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现如果能消除 <span class="markdown-them-math-inline">$R(x)$</span> 的影响则可以直接使用多项式求逆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑构造变换 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F' = x ^ {\deg F} F\left(\frac{1}{x}\right) \tag{5.3.1}$$</div><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其本质就是翻转多项式系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$n = \deg F,m = \deg G$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将多项式带余除法定义式中的 <span class="markdown-them-math-inline">$x$</span> 替换成 <span class="markdown-them-math-inline">$\frac{1}{x}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将两边同时乘 <span class="markdown-them-math-inline">$x ^ n$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$x ^ n F\left(\frac{1}{x}\right) = x ^ {n - m} Q\left(\frac{1}{x}\right) x ^ m G\left(\frac{1}{x}\right) + x ^ {n - m + 1} x ^ {m - 1} R\left(\frac{1}{x}\right) \tag{5.3.2}$$</div><p>将式 <span class="markdown-them-math-inline">$(5.3.1)$</span> 带入可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F'(x) = Q'(x) G'(x) + x ^ {n - m + 1} R'(x) \tag{5.3.3}$$</div><p>注意到式 <span class="markdown-them-math-inline">$(5.3.3)$</span> 中 <span class="markdown-them-math-inline">$R'(x)$</span> 带了一个 <span class="markdown-them-math-inline">$x ^ {n - m + 1}$</span> 作为系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是将上式放在 <span class="markdown-them-math-inline">$\bmod~x ^ {n - m + 1}$</span> 意义下计算即可将这一项消去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>又因为 <span class="markdown-them-math-inline">$\deg Q' = n - m &lt; n - m + 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$Q'(x)$</span> 的计算不会受到影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F'(x) = Q'(x)G'(x) \pmod {x ^ {n - m + 1}} \tag{5.3.4}$$</div><p>使用多项式求逆即可计算 <span class="markdown-them-math-inline">$Q(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将其带入定义式可以得到 <span class="markdown-them-math-inline">$R(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, m, len, ln, F[N], G[N], rev[N], FR[N], GR[N], Q[N], R[N], FI[N], GI[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> ( ; k; a = <span class="hljs-number">1ll</span> * a * a % mod, k &gt;&gt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (i &lt; rev[i]) <span class="hljs-built_in">swap</span>(F[i], F[rev[i]]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> eps = <span class="hljs-built_in">Pow</span>(type ? <span class="hljs-number">3</span> : <span class="hljs-number">332748118</span>, (mod - <span class="hljs-number">1</span>) / (k &lt;&lt; <span class="hljs-number">1</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i, g = <span class="hljs-number">1</span>; j &lt; i + k; j++, g = <span class="hljs-number">1ll</span> * g * eps % mod) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = <span class="hljs-number">1ll</span> * g * F[j + k] % mod;                F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2;                F[j + k] = tmp1 - tmp2 &lt; <span class="hljs-number">0</span> ? tmp1 - tmp2 + mod : tmp1 - tmp2;            &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">INV</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *F)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n &lt;&lt; <span class="hljs-number">2</span>) FI[i] = GI[i] = <span class="hljs-number">0</span>;    GI[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Pow</span>(F[<span class="hljs-number">0</span>], mod - <span class="hljs-number">2</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">4</span>, ln = <span class="hljs-number">2</span>; len &lt;= n &lt;&lt; <span class="hljs-number">2</span>; len &lt;&lt;= <span class="hljs-number">1</span>, ln++) &#123;        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) FI[i] = F[i];        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);        <span class="hljs-built_in">NTT</span>(len, GI, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, FI, <span class="hljs-literal">true</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">1ll</span> * GI[i] * (<span class="hljs-number">2</span> - <span class="hljs-number">1ll</span> * GI[i] * FI[i] % mod + mod) % mod;        <span class="hljs-built_in">NTT</span>(len, GI, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">1ll</span> * GI[i] * Inv % mod;        <span class="hljs-built_in">rep</span>(i, len &gt;&gt; <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) F[i] = GI[i];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DIV</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">int</span> *G)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) FR[i] = F[n - i];    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m) GR[i] = G[m - i];    <span class="hljs-built_in">rep</span>(i, n - m + <span class="hljs-number">1</span>, m) GR[i] = <span class="hljs-number">0</span>;    <span class="hljs-built_in">INV</span>(n - m, GR);    <span class="hljs-keyword">for</span> (len = <span class="hljs-number">1</span>, ln = <span class="hljs-number">0</span>; len &lt;= <span class="hljs-number">2</span> * n - m; len &lt;&lt;= <span class="hljs-number">1</span>, ln++);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);    <span class="hljs-built_in">NTT</span>(len, FR, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, GR, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) FR[i] = <span class="hljs-number">1ll</span> * FR[i] * GR[i] % mod;    <span class="hljs-built_in">NTT</span>(len, FR, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n - m) Q[i] = <span class="hljs-number">1ll</span> * FR[n - m - i] * Inv % mod;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n - m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, Q[i]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-keyword">for</span> (len = <span class="hljs-number">1</span>, ln = <span class="hljs-number">0</span>; len &lt;= n; len &lt;&lt;= <span class="hljs-number">1</span>, ln++);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);    <span class="hljs-built_in">NTT</span>(len, G, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, Q, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) G[i] = <span class="hljs-number">1ll</span> * G[i] * Q[i] % mod;    <span class="hljs-built_in">NTT</span>(len, G, <span class="hljs-literal">false</span>);    Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>) R[i] = (F[i] - <span class="hljs-number">1ll</span> * G[i] * Inv % mod + mod) % mod;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, R[i]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;F[i]);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;G[i]);    <span class="hljs-built_in">DIV</span>(n, m, F, G);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="多项式指对函数">多项式指对函数</h3><p>两者均由麦克劳林级数定义 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}    \ln F(x) &amp;= -\sum_{i \geqslant 1} \frac{[1 - F(x)] ^ i}{i}\\    \exp F(x) &amp;= \sum _{i \geqslant 0} \frac{F^i(x)}{i!}\end{aligned}$$</div><p>之所以用麦克劳林级数这么复杂的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是因为这样就可以只用加法和乘法定义多项式指对函数了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>众所周知有多项式的求导 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F'(x) = \sum _{i \geqslant 1} iF_i\cdot x ^ {i - 1} \tag{5.4.2}$$</div><p>还有多项式的积分 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = C + \sum _{i \geqslant 0} \frac{F'_i}{i} \cdot x ^ {i + 1} \tag{5.4.3}$$</div><h4 id="多项式对数函数">多项式对数函数</h4><p>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于多项式 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\ln F(x)$</span> 存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则按照其定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>必须满足 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$[x ^ 0]F(x) = 1 \tag{5.4.4}$$</div><p>先对 <span class="markdown-them-math-inline">$\ln F(x)$</span> 求导 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\frac{\mathrm{d}\ln F(x)}{\mathrm{d} x} \equiv \frac{F'(x)}{F(x)} \pmod {x ^ n} \tag{5.4.5}$$</div><p>再对其积分 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\ln F(x) \equiv \int \mathrm{d}\ln F(x) \equiv \int \frac{F'(x)}{F(x)}\mathrm{d} x \pmod {x ^ n} \tag{5.4.6}$$</div><p>多项式的求导和积分时间复杂度均为 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>多项式求逆和乘法的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以求解多项式对数函数的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">4e5</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, m, f[N], F[N], rev[N], FI[N], GI[N], iF[N], lnF[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (; k; a = <span class="hljs-number">1ll</span> * a * a % mod, k &gt;&gt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (i &lt; rev[i]) <span class="hljs-built_in">swap</span>(F[i], F[rev[i]]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> eps = <span class="hljs-built_in">Pow</span>(type ? <span class="hljs-number">3</span> : <span class="hljs-number">332748118</span>, (mod - <span class="hljs-number">1</span>) / (k &lt;&lt; <span class="hljs-number">1</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i, g = <span class="hljs-number">1</span>; j &lt; i + k; j++, g = <span class="hljs-number">1ll</span> * g * eps % mod) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = <span class="hljs-number">1ll</span> * g * F[j + k] % mod;                F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2;                F[j + k] = tmp1 - tmp2 &lt; <span class="hljs-number">0</span> ? tmp1 - tmp2 + mod : tmp1 - tmp2;            &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">INV</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">int</span> *iF)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n &lt;&lt; <span class="hljs-number">2</span>) GI[i] = FI[i] = <span class="hljs-number">0</span>;    GI[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Pow</span>(F[<span class="hljs-number">0</span>], mod - <span class="hljs-number">2</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">4</span>, ln = <span class="hljs-number">2</span>; len &lt;= n &lt;&lt; <span class="hljs-number">2</span>; len &lt;&lt;= <span class="hljs-number">1</span>, ln++) &#123;        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) FI[i] = F[i];        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);        <span class="hljs-built_in">NTT</span>(len, GI, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, FI, <span class="hljs-literal">true</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">1ll</span> * GI[i] * (<span class="hljs-number">2</span> - <span class="hljs-number">1ll</span> * GI[i] * FI[i] % mod + mod) % mod;        <span class="hljs-built_in">NTT</span>(len, GI, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">1ll</span> * GI[i] * Inv % mod;        <span class="hljs-built_in">rep</span>(i, len &gt;&gt; <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) iF[i] = GI[i];    <span class="hljs-built_in">rep</span>(i, n + <span class="hljs-number">1</span>, n &lt;&lt; <span class="hljs-number">2</span>) iF[i] = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LN</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">int</span> *lnF)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) lnF[i] = <span class="hljs-number">1ll</span> * (i + <span class="hljs-number">1</span>) * F[i + <span class="hljs-number">1</span>] % mod;    <span class="hljs-built_in">rep</span>(i, n, n &lt;&lt; <span class="hljs-number">2</span>) lnF[i] = <span class="hljs-number">0</span>;    <span class="hljs-built_in">INV</span>(n, F, iF);    <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>, ln = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (len &lt; n &lt;&lt; <span class="hljs-number">1</span>) len &lt;&lt;= <span class="hljs-number">1</span>, ln++;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);    <span class="hljs-built_in">NTT</span>(len, lnF, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, iF, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) lnF[i] = <span class="hljs-number">1ll</span> * lnF[i] * iF[i] % mod;    <span class="hljs-built_in">NTT</span>(len, lnF, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) lnF[i] = <span class="hljs-number">1ll</span> * lnF[i] * Inv % mod;    <span class="hljs-built_in">rep</span>(i, n, n &lt;&lt; <span class="hljs-number">2</span>) lnF[i] = <span class="hljs-number">0</span>;    <span class="hljs-built_in">dep</span>(i, n, <span class="hljs-number">1</span>) lnF[i] = <span class="hljs-number">1ll</span> * <span class="hljs-built_in">Pow</span>(i, mod - <span class="hljs-number">2</span>) * lnF[i - <span class="hljs-number">1</span>] % mod;    lnF[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n, n--;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) cin &gt;&gt; F[i];    <span class="hljs-built_in">LN</span>(n, F, lnF);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) cout &lt;&lt; lnF[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="多项式指数函数">多项式指数函数</h4><p>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于多项式 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\exp F(x)$</span> 存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则按照其定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>必须满足 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$[x ^ 0] F(x) = 1 \tag{5.4.7}$$</div><p>否则 <span class="markdown-them-math-inline">$\exp F(x)$</span> 的常数项不收敛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对 <span class="markdown-them-math-inline">$\exp F(x)$</span> 求导可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\frac{\mathrm{d} \exp F(x)}{\mathrm{d}x} \equiv F'(x) \exp F(x) \pmod {x ^ n} \tag{5.4.8}$$</div><p>若记 <span class="markdown-them-math-inline">$\exp F(x)$</span> 为 <span class="markdown-them-math-inline">$G(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可以得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G'(x) \equiv F'(x)G(x) \pmod {x ^ n} \tag{5.4.9}$$</div><p>用系数关系表示为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G'_n = \sum _{i = 0} ^ n F'_i G_{n - i} \tag{5.4.10}$$</div><p>将导函数积回来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以得到 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G_{n + 1} = \frac{1}{n + 1}\sum _{i = 0} ^ n (i + 1)F_{i + 1}G_{n - i} \tag{5.4.11}$$</div><p>上式的递推可以用分治多项式乘法优化至 <span class="markdown-them-math-inline">$\Theta(n \log ^ 2 n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="多项式牛顿迭代">多项式牛顿迭代</h3><p>定义多项式的复合 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F \circ G (x) = \sum _{i\geqslant 0} F_i G^i(x) \tag{5.5.1}$$</div><p>已知函数 <span class="markdown-them-math-inline">$G(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求多项式 <span class="markdown-them-math-inline">$F(x) \pmod {x ^ n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="markdown-them-math-inline">$G \circ F(x) = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先当多项式的界为 <span class="markdown-them-math-inline">$\bmod~x$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以手算出 <span class="markdown-them-math-inline">$F(x) \pmod x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>假设现在已经求得 <span class="markdown-them-math-inline">$\bmod~x ^ {n / 2}$</span> 意义下的解 <span class="markdown-them-math-inline">$F_0(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要进一步求出 <span class="markdown-them-math-inline">$\bmod~x ^ n$</span> 意义下的解 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>众所周知有泰勒公式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f(x) = \sum _{i = 0} ^ {\infty} \frac{f^{(i)}(x_0)}{i!}(x - x_0) ^ i \tag{5.5.2}$$</div><p>将 <span class="markdown-them-math-inline">$G[F(x)]$</span> 在 <span class="markdown-them-math-inline">$F_0(x)$</span> 处进行泰勒展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum _{i = 0} ^ {\infty} \frac{G^{(i)}[F_0(x)]}{i!}[F(x) - F_0(x)] ^ i \equiv 0 \pmod {x ^ n} \tag{5.5.3}$$</div><p>由于当 <span class="markdown-them-math-inline">$i$</span> 取大于 <span class="markdown-them-math-inline">$1$</span> 的值时 <span class="markdown-them-math-inline">$[F(x) - F_0(x)] ^ i$</span> 的最低次项都会超过 <span class="markdown-them-math-inline">$x ^ n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G[F_0(x)] + G'[F_0(x)][F(x) - F_0(x)] \equiv 0 \pmod {x ^ n} \tag{5.5.4}$$</div><p>化简得到牛顿迭代的经典公式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) = F_0(x) - \frac{G[F_0(x)]}{G'[F_0(x)]} \pmod {x ^ n} \tag{5.5.5}$$</div><p>使用多项式牛顿迭代也可以解决一些其它的多项式基本操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="多项式求逆-1">多项式求逆</h4><p>设需要求逆的函数为 <span class="markdown-them-math-inline">$H(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F(x) = H^{-1}(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G \circ F(x) \equiv \frac{1}{F(x)} - H(x) \equiv 0 \pmod {x ^ n} \tag{5.5.6}$$</div><p>运用式 <span class="markdown-them-math-inline">$(5.5.5)$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) \equiv F_0(x) - \frac{\frac{1}{F_0(x)} - H(x)}{-\frac{1}{F_0^{2}(x)}} \equiv 2F_0(x) - F_0^2(x)H(x) \pmod {x ^ n} \tag{5.5.7}$$</div><p>时间复杂度 <span class="markdown-them-math-inline">$T(n) = T\left(\frac{n}{2}\right) + \Theta(n \log n) = \Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="多项式开方-1">多项式开方</h4><p>设需要开方的函数为 <span class="markdown-them-math-inline">$H(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F(x) = H^{\frac{1}{2}}(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G \circ F(x) \equiv F^2(x) - H(x) \equiv 0 \pmod {x ^ n} \tag{5.5.8}$$</div><p>运用式 <span class="markdown-them-math-inline">$(5.5.5)$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) \equiv F_0(x) - \frac{F_0^2(x) - H(x)}{2F_0(x)} \equiv 2F_0^{-1}(x)[F_0^2(x) + H(x)] \pmod {x ^ n} \tag{5.5.9}$$</div><p>时间复杂度 <span class="markdown-them-math-inline">$T(n) = T\left(\frac{n}{2}\right) + \Theta(n \log n) = \Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="多项式指数函数-1">多项式指数函数</h4><p>设需要求 <span class="markdown-them-math-inline">$\exp$</span> 的函数为 <span class="markdown-them-math-inline">$H(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F(x) = \exp H(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$G \circ F(x) \equiv \ln F(x) - H(x) \equiv 0 \pmod {x ^ n} \tag{5.5.10}$$</div><p>运用式 <span class="markdown-them-math-inline">$(5.5.5)$</span> 可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F(x) \equiv F_0(x) - \frac{\ln F_0(x) - H(x)}{\frac{1}{F_0(x)}} \equiv F_0(x)[1 - \ln F_0(x) + H(x)] \pmod {x ^ n} \tag{5.5.11}$$</div><p>时间复杂度 <span class="markdown-them-math-inline">$T(n) = T\left(\frac{n}{2}\right) + \Theta(n \log n) = \Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span>, mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">int</span> n, k, F[N], rev[N], FI[N], GI[N], iF[N], FE[N], GE[N], lnF[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (; k; a = <span class="hljs-number">1ll</span> * a * a % mod, k &gt;&gt;= <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * a % mod;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> *F, <span class="hljs-keyword">bool</span> type)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (i &lt; rev[i]) <span class="hljs-built_in">swap</span>(F[i], F[rev[i]]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> eps = <span class="hljs-built_in">Pow</span>(type ? <span class="hljs-number">3</span> : <span class="hljs-number">332748118</span>, (mod - <span class="hljs-number">1</span>) / (k &lt;&lt; <span class="hljs-number">1</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += (k &lt;&lt; <span class="hljs-number">1</span>))            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i, g = <span class="hljs-number">1</span>; j &lt; i + k; j++, g = <span class="hljs-number">1ll</span> * g * eps % mod) &#123;                <span class="hljs-keyword">int</span> tmp1 = F[j], tmp2 = <span class="hljs-number">1ll</span> * g * F[j + k] % mod;                F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2;                F[j + k] = tmp1 - tmp2 &lt; <span class="hljs-number">0</span> ? tmp1 - tmp2 + mod : tmp1 - tmp2;            &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">INV</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *F)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n &lt;&lt; <span class="hljs-number">2</span>) FI[i] = GI[i] = <span class="hljs-number">0</span>;    GI[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Pow</span>(F[<span class="hljs-number">0</span>], mod - <span class="hljs-number">2</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">4</span>, ln = <span class="hljs-number">2</span>; len &lt;= n &lt;&lt; <span class="hljs-number">2</span>; len &lt;&lt;= <span class="hljs-number">1</span>, ln++) &#123;        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) FI[i] = F[i];        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);        <span class="hljs-built_in">NTT</span>(len, GI, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, FI, <span class="hljs-literal">true</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">1ll</span> * GI[i] * (<span class="hljs-number">2</span> - <span class="hljs-number">1ll</span> * GI[i] * FI[i] % mod + mod) % mod;        <span class="hljs-built_in">NTT</span>(len, GI, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">1ll</span> * GI[i] * Inv % mod;        <span class="hljs-built_in">rep</span>(i, len &gt;&gt; <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>) GI[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) iF[i] = GI[i];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LN</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *F)</span> </span>&#123;    <span class="hljs-built_in">INV</span>(n, F);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * (i + <span class="hljs-number">1</span>) * F[i + <span class="hljs-number">1</span>] % mod;    F[n] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>, ln = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (; len &lt; n &lt;&lt; <span class="hljs-number">1</span>; len &lt;&lt;= <span class="hljs-number">1</span>, ln++);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);    <span class="hljs-built_in">NTT</span>(len, F, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, iF, <span class="hljs-literal">true</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * F[i] * iF[i] % mod;    <span class="hljs-built_in">NTT</span>(len, F, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * F[i] * Inv % mod;    <span class="hljs-built_in">rep</span>(i, n, len - <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">0</span>;    <span class="hljs-built_in">dep</span>(i, n, <span class="hljs-number">1</span>) F[i] = <span class="hljs-number">1ll</span> * <span class="hljs-built_in">Pow</span>(i, mod - <span class="hljs-number">2</span>) * F[i - <span class="hljs-number">1</span>] % mod;    F[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EXP</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *F)</span> </span>&#123;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (n &lt;&lt; <span class="hljs-number">2</span>)) FE[i] = GE[i] = <span class="hljs-number">0</span>;    GE[<span class="hljs-number">0</span>] = <span class="hljs-built_in">exp</span>(F[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>, ln = <span class="hljs-number">1</span>; len &lt;= n &lt;&lt; <span class="hljs-number">2</span>; len &lt;&lt;= <span class="hljs-number">1</span>, ln++) &#123;        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, (len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) FE[i] = F[i], lnF[i] = GE[i];        <span class="hljs-built_in">LN</span>((len &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>, lnF);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> &lt;&lt; ln - <span class="hljs-number">1</span>);        <span class="hljs-built_in">NTT</span>(len, GE, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, FE, <span class="hljs-literal">true</span>), <span class="hljs-built_in">NTT</span>(len, lnF, <span class="hljs-literal">true</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) GE[i] = <span class="hljs-number">1ll</span> * GE[i] * (<span class="hljs-number">1</span> - lnF[i] + FE[i] + mod) % mod;        <span class="hljs-built_in">NTT</span>(len, GE, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">int</span> Inv = <span class="hljs-built_in">Pow</span>(len, mod - <span class="hljs-number">2</span>);        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>) GE[i] = <span class="hljs-number">1ll</span> * GE[i] * Inv % mod;    &#125;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) F[i] = GE[i];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span> </span>&#123;    x = <span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)        x = (<span class="hljs-number">10ll</span> * x + (c ^ <span class="hljs-number">48</span>)) % mod, c = <span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">read</span>(n), n--;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">read</span>(F[i]);    <span class="hljs-built_in">EXP</span>(n, F);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, F[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="多项式三角函数">多项式三角函数</h3><h4 id="三角函数">三角函数</h4><p>给定多项式 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求模 <span class="markdown-them-math-inline">$x^{n}$</span> 意义下的 <span class="markdown-them-math-inline">$\sin F(x), \cos F(x)$</span> 与 <span class="markdown-them-math-inline">$\tan F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先由欧拉公式 <span class="markdown-them-math-inline">$\left(e^{i x}=\cos x+i \sin x\right)$</span> 可以得到三角函数的另一个表达式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}&amp;\sin x=\frac{e^{i x}-e^{-i x}}{2 i} \\&amp;\cos x=\frac{e^{i x}+e^{-i x}}{2}\end{aligned}$$</div><p>那么代入 <span class="markdown-them-math-inline">$F(x)$</span> 就有 :</p><div class="markdown-them-math-block">$$\begin{aligned}\sin F(x) &amp;=\frac{\exp [iF(x)] - \exp [-iF(x)]}{2i} \\\cos F(x) &amp;=\frac{\exp [iF(x)] + \exp [-iF(x)]}{2}\end{aligned}$$</div><p>直接按上述表达式编写程序即可得到模 <span class="markdown-them-math-inline">$x^{n}$</span> 意义下的 <span class="markdown-them-math-inline">$\sin F(x)$</span> 与 <span class="markdown-them-math-inline">$\cos F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>再由 <span class="markdown-them-math-inline">$\tan F(x)=\frac{\sin F(x)}{\cos F(x)}$</span> 可求得 <span class="markdown-them-math-inline">$\tan F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="反三角函数">反三角函数</h4><p>仿照求多项式对数函数的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对反三角函数求导再积分可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}\frac{\mathrm{d}}{\mathrm{d} x} \arcsin x &amp;=\frac{1}{\sqrt{1-x^{2}}} \\\arcsin x &amp;=\int \frac{1}{\sqrt{1-x^{2}}} \mathrm{~d} x \\\frac{\mathrm{d}}{\mathrm{d} x} \arccos x &amp;=-\frac{1}{\sqrt{1-x^{2}}} \\\arccos x &amp;=-\int \frac{1}{\sqrt{1-x^{2}}} \mathrm{~d} x \\\frac{\mathrm{d}}{\mathrm{d} x} \arctan x &amp;=\frac  \arctan x &amp;=\int \frac{1}{1+x^{2}} \mathrm{~d} x\end{aligned}$$</div><p>那么代入 <span class="markdown-them-math-inline">$F(x)$</span> 就有:</p><div class="markdown-them-math-block">$$\begin{aligned}\frac{\mathrm{d}}{\mathrm{d} x} \arcsin F(x) &amp;=\frac{F^{\prime}(x)}{\sqrt{1-F^{2}(x)}} \\\arcsin F(x) &amp;=\int \frac{F^{\prime}(x)}{\sqrt{1-F^{2}(x)}} \mathrm{d} x \\\frac{\mathrm{d}}{\mathrm{d} x} \arccos F(x) &amp;=-\frac{F^{\prime}(x)}{\sqrt{1-F^{2}(x)}} \\\arccos F(x) &amp;=-\int \frac{F^{\prime}(x)}{\sqrt{1-F^{2}(x)}} \mathrm{d} x \\\frac{\mathrm{d}}{\mathrm{d} x} \arctan F(x) &amp;=\frac{F^{\prime}(x)}{1+F^{2}(x)} \\\arctan F(x) &amp;=\int \frac{F^{\prime}(x)}{1+F^{2}(x)} \mathrm{d} x\end{aligned}$$</div><p>直接按式子求就可以了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度均为 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」十二类基本组合问题</title>
      <link href="/2023/06/24/shu-xue-shi-er-lei-ji-ben-zu-he-wen-ti/"/>
      <url>/2023/06/24/shu-xue-shi-er-lei-ji-ben-zu-he-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了组合数学中最基本的 <span class="markdown-them-math-inline">$12$</span> 类小球入盒问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定要熟练掌握<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><p>小球入盒问题是所有组合问题的基础<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它计算的是形如 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span><span class="markdown-them-math-inline">$n$</span> 个球放进 <span class="markdown-them-math-inline">$m$</span> 个盒子的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> 的一类问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在这类问题中一般存在三种限制 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>小球是否有编号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>盒子是否有编号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>盒子中球的数量是无限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>至少一个还是至多一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>记有编号为 <span class="markdown-them-math-inline">$L\rm (labelled)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无编号为 <span class="markdown-them-math-inline">$U\rm (unlabelled)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>盒子中球的数量限制分别为 <span class="markdown-them-math-inline">$A,B,C$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样我们就可以将一个问题用三个字母简记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如 <span class="markdown-them-math-inline">$\rm LUB$</span> 表示将 <span class="markdown-them-math-inline">$n$</span> 个有标号小球放进 <span class="markdown-them-math-inline">$m$</span> 个无标号盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中至少有一个球的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现问题共有 <span class="markdown-them-math-inline">$12$</span> 类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在我们来一个个分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="part1-lla">Part1 LLA</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个有标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个有标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量没有限制的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以看作每次从 <span class="markdown-them-math-inline">$m$</span> 个盒子里任选一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一共要放 <span class="markdown-them-math-inline">$n$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有其他限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故方案数为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{m^n}$$</div><h3 id="part2-ula">Part2 ULA</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个无标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个有标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量没有限制的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>在这个问题中我们只关心对每个盒子里面球的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以这个问题的方案数等于方程 <span class="markdown-them-math-inline">$x_1+x_2+\cdots +x_m=n$</span> <strong>非负整数解</strong>的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用隔板法可以求得其为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{\dbinom{n+m-1}{m-1}}$$</div><h3 id="part3-ulb">Part3 ULB</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个无标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个有标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量至少为 <span class="markdown-them-math-inline">$1$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这个问题与上个问题相似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方案数等于方程 <span class="markdown-them-math-inline">$x_1+x_2+\cdots +x_m=n$</span> <strong>正整数解</strong>的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用隔板法可以求得其为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{\dbinom{n-1}{m-1}}$$</div><h3 id="part4-llc">Part4 LLC</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个有标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个有标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量至多为 <span class="markdown-them-math-inline">$1$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现这个问题等价于依次为每个球选择一个盒子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故答案为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{m^{\underline{n}}}$$</div><h3 id="part5-ulc">Part5 ULC</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个无标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个有标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量至多为 <span class="markdown-them-math-inline">$1$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>相当于是为每一个盒子选择数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等价于从 <span class="markdown-them-math-inline">$m$</span> 个盒子中选出 <span class="markdown-them-math-inline">$n$</span> 个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>让它的数量为 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故方案数为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{\dbinom{m}{n}}$$</div><h3 id="part6-luc">Part6 LUC</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个有标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个无标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量至多为 <span class="markdown-them-math-inline">$1$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>盒子顺序可以任意交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以任意一种方案都等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现当球数超过盒子数时无解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故方案数为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{[n\leqslant m]}$$</div><h3 id="part7-uuc">Part7 UUC</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个无标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个无标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量至多为 <span class="markdown-them-math-inline">$1$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>理由同上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方案数为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{[n\leqslant m]}$$</div><h3 id="part8-llb">Part8 LLB</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个有标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个有标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量至少为 <span class="markdown-them-math-inline">$1$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑使用容斥原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举有多少个盒子为空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的盒子随便填<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故方案数为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{\sum_{i=0}^m(-1)^i\dbinom{m}{i}(m-i)^n}$$</div><p>利用 <span class="markdown-them-math-inline">$\rm Part9$</span> 中讲到的第二类斯特林数也可以 <span class="markdown-them-math-inline">$\rm LLB$</span> 问题的方案数表示为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{\begin{Bmatrix}n\\m\end{Bmatrix}m!}$$</div><h3 id="part9-lub">Part9 LUB</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个有标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个无标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量至少为 <span class="markdown-them-math-inline">$1$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>只需要将 <span class="markdown-them-math-inline">$m$</span> 个盒子排序产生的方案去除即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故方案数为 :</p><div class="markdown-them-math-block">$$\boxed{\sum_{i=0}^m\frac{(-1)^i(m-i)^n}{i!(m-i)!}}$$</div><p><span class="markdown-them-math-inline">$\rm LUB$</span> 问题的答案被定义为 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>第二类斯特林数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>递推式如下 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{\begin{Bmatrix}n\\m\end{Bmatrix}=m\begin{Bmatrix}n-1\\m\end{Bmatrix}+\begin{Bmatrix}n-1\\m-1\end{Bmatrix}}$$</div><p>其含义为考虑新加入一个有标号小球<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以将其加入之前的任意一个盒子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以为它单独开一个盒子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方案数相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="part10-lua">Part10 LUA</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个有标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个无标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量无限制的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>记 <span class="markdown-them-math-inline">$\rm LUA$</span> 问题的方案数为 <span class="markdown-them-math-inline">$B_n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>读作贝尔数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为若某个盒子为空可以看作没有这个盒子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$B_n$</span> 表示将 <span class="markdown-them-math-inline">$n$</span> 个数划分成任意个集合的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{B_n=\sum_{i=1}^n\begin{Bmatrix}n\\i\end{Bmatrix}}$$</div><p>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现它也可以递推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有递推式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\boxed{B_{n+1}=\sum_{i=0}^n\dbinom{n}{i}B_i}$$</div><p>其含义为第 <span class="markdown-them-math-inline">$n+1$</span> 个数若和之前的 <span class="markdown-them-math-inline">$i$</span> 个数放在一起<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方案数为 <span class="markdown-them-math-inline">$\tbinom{n}{i}B_{n-i}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="part11-uua">Part11 UUA</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个无标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个无标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量无限制的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现其实这就是划分数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求法如下 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>记 <span class="markdown-them-math-inline">$f_{i,j}$</span> 表示将 <span class="markdown-them-math-inline">$i$</span> 划分成不超过 <span class="markdown-them-math-inline">$j$</span> 的数的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当计算 <span class="markdown-them-math-inline">$f_{i,j}$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其方案数可以从 <span class="markdown-them-math-inline">$f_{i-j,j}$</span> 继承<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示分出去一个大小为 <span class="markdown-them-math-inline">$j$</span> 的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其方案数也可以从 <span class="markdown-them-math-inline">$f_{i,j-1}$</span> 继承<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示不选大小为 <span class="markdown-them-math-inline">$j$</span> 的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>故有转移方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i,j}=f_{i-j,j}+f_{i,j-1}$$</div><p>我们发现 <span class="markdown-them-math-inline">$f$</span> 的转移就是一个完全背包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以考虑将其改写为一维形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_j=\sum_{i=1}^nf_{j-i}$$</div><p>记 <span class="markdown-them-math-inline">$g_{i,j}$</span> 表示将 <span class="markdown-them-math-inline">$i$</span> 划分成 <span class="markdown-them-math-inline">$j$</span> 个数的方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当计算 <span class="markdown-them-math-inline">$g_{i,j}$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其方案数可以从 <span class="markdown-them-math-inline">$g_{i-j,j}$</span> 继承<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示将所有数 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其方案数也可以从 <span class="markdown-them-math-inline">$g_{i-1,j-1}$</span> 继承<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示新增一个大小为 <span class="markdown-them-math-inline">$1$</span> 的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现后增加的数一定比前增加的数小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不重<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样一定能遍历到所有合法的划分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不漏<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故有转移方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$g_{i,j}=g_{i-j,j}+g_{i-1,j-1}$$</div><p>这两种方式都可以做到 <span class="markdown-them-math-inline">$\Theta(n^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们分析两种方式的优劣<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现第一种算法主要依赖于划分成的数大小的上界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第二种算法主要依赖于划分成数的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑根号分治<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将问题看成一个完全背包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>物品按照占用空间小于等于 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 和大于 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 分类即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于 <span class="markdown-them-math-inline">$g$</span> 计算的只有物品占用空间大于 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以转移方程要改写成 :</p><div class="markdown-them-math-block">$$g_{i,j}=g_{i-j,j}+g_{i-\sqrt{n},j-1}$$</div><p>每次加入一个 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 就可以保证所有数都大于 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最后统计答案的时候直接枚举 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将 <span class="markdown-them-math-inline">$f_i$</span> 和 <span class="markdown-them-math-inline">$g_{n-i,k}$</span> 乘起来即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="part12-uub">Part12 UUB</h3><p>将 <span class="markdown-them-math-inline">$n$</span> 个无标号的球放进 <span class="markdown-them-math-inline">$m$</span> 个无标号的盒子里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个盒子中球的数量 至少为 <span class="markdown-them-math-inline">$1$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现只需要先在每个盒子中放 <span class="markdown-them-math-inline">$1$</span> 个球就可以了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等价于 <span class="markdown-them-math-inline">$\rm UUA$</span> 问题中 <span class="markdown-them-math-inline">$n-m$</span> 个球<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$m$</span> 个盒子的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」原根和阶</title>
      <link href="/2023/06/24/shu-xue-yuan-gen-he-jie/"/>
      <url>/2023/06/24/shu-xue-yuan-gen-he-jie/</url>
      
        <content type="html"><![CDATA[<p>原根和阶的定义及求法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="阶的定义及求法">阶的定义及求法</h2><p>称使得 <span class="markdown-them-math-inline">$a^t\equiv 1\pmod p$</span> 成立的最小正整数 <span class="markdown-them-math-inline">$t_{min}$</span> 为 <span class="markdown-them-math-inline">$a$</span> 对模数 <span class="markdown-them-math-inline">$p$</span> 的阶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记为 <span class="markdown-them-math-inline">$\delta_p(a)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有如下定理 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$\delta_p(a)~|~n\Longleftrightarrow a^n\equiv 1\pmod p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>又有 <span class="markdown-them-math-inline">$a^{\varphi(p)}\equiv 1\pmod p\Longrightarrow \delta_p(a)~|~\varphi(p)$</span> 可得一个 <span class="markdown-them-math-inline">$\Theta(\sqrt{p}+\log^2p)$</span> 求阶的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>首先将 <span class="markdown-them-math-inline">$\varphi(p)$</span> 分解成 <span class="markdown-them-math-inline">$\varphi(p)=k_1^{q_1}\times k_2^{q_2}\times \cdots \times k_r^{q_r}$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$\delta_p(a)=\varphi(p)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后试着用每一个质因子去除 <span class="markdown-them-math-inline">$\delta_p(a)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果除了之后 <span class="markdown-them-math-inline">$a^{\frac{\delta_p(a)}{k_i}}\equiv 1\pmod p$</span> 那么 <span class="markdown-them-math-inline">$\frac{\delta_p(a)}{k_i}$</span> 就作为新的阶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到不能再除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时的 <span class="markdown-them-math-inline">$\delta_p(a)$</span> 就为 <span class="markdown-them-math-inline">$a$</span> 在模 <span class="markdown-them-math-inline">$p$</span> 意义下真正的阶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="原根的定义及求法">原根的定义及求法</h2><p>原根 <span class="markdown-them-math-inline">$g$</span> 是使得 <span class="markdown-them-math-inline">$g^{1\sim p-1}$</span> 在模 <span class="markdown-them-math-inline">$p$</span> 意义下的值与 <span class="markdown-them-math-inline">$[1,p-1]$</span> 形成一一对应关系的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有如下定理 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$g$</span> 为 <span class="markdown-them-math-inline">$p$</span> 的原根当且仅当 <span class="markdown-them-math-inline">$\delta_p(g)=\varphi(p)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是可以导出一个计算 <span class="markdown-them-math-inline">$g_{min}$</span> 的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从小到大枚举 <span class="markdown-them-math-inline">$g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\delta_p(g)=\varphi(p)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$g$</span> 为 <span class="markdown-them-math-inline">$p$</span> 的最小原根<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有如下定理 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$g_{min}&lt;p^{\frac{1}{4}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>所以以上算法时间复杂度为 <span class="markdown-them-math-inline">$\Theta(\sqrt{p}+p^{\frac{1}{4}}\omega(p))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「字符串」Z 算法</title>
      <link href="/2023/06/24/zi-fu-chuan-z-suan-fa/"/>
      <url>/2023/06/24/zi-fu-chuan-z-suan-fa/</url>
      
        <content type="html"><![CDATA[<p><span class="markdown-them-math-inline">$Z$</span> 算法学习笔记及经典例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="算法简介">算法简介</h2><p><span class="markdown-them-math-inline">$Z$</span> 算法在国内也被某些人称为 <span class="markdown-them-math-inline">$\rm ExKMP$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>虽然我不知道它跟 <span class="markdown-them-math-inline">$\rm KMP$</span> 算法有什么关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$Z$</span> 算法用于求字符串 <span class="markdown-them-math-inline">$S$</span> 的 <span class="markdown-them-math-inline">$Z$</span> 函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其定义为 <span class="markdown-them-math-inline">$z_i=\rm LCP(S,S_{i\sim n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这个算法的核心在于利用之前的信息来减少计算量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>具体来说我们可以从左往右依次求每个位置的 <span class="markdown-them-math-inline">$z$</span> 函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$[i, i + z_i - 1]$</span> 为 <span class="markdown-them-math-inline">$i$</span> 的匹配段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时维护出右端点最靠右的匹配段 <span class="markdown-them-math-inline">$[l, r]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>那么我们知道有 <span class="markdown-them-math-inline">$S_{1 \sim r - l + 1} = S_{l \sim r}, S_{i \sim r} = S_{i - l + 1, r - l + 1}(i \leqslant r), z_i \geqslant \min(r - i + 1, z_{i - l + 1})$</span></p><p>在计算 <span class="markdown-them-math-inline">$z_i$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分以下三种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>若 <span class="markdown-them-math-inline">$i \leqslant r, z_{i - l + 1} &lt; r - i + 1$</span> 那么显然有 <span class="markdown-them-math-inline">$z_i = z_{i - l + 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>若 <span class="markdown-them-math-inline">$i \leqslant r, z_{i - l + 1} \geqslant r - i + 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么我们就从 <span class="markdown-them-math-inline">$r + 1$</span> 开始暴力匹配前缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>若 <span class="markdown-them-math-inline">$i &gt; r$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么直接从 <span class="markdown-them-math-inline">$i$</span> 开始暴力匹配前缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>不难发现复杂度来源在于 <span class="markdown-them-math-inline">$2, 3$</span> 情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但可以发现右端点最靠右的匹配段的右端点总是在这两种情况下向右移动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而总移动量不超过 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此复杂度是 <span class="markdown-them-math-inline">$\Theta(n)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>如果要求 <span class="markdown-them-math-inline">$z_i = \rm LCP(T, S_{i \sim n})$</span> 话<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就类似于 <span class="markdown-them-math-inline">$\rm KMP$</span> 的做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>构造一个 <span class="markdown-them-math-inline">$T \# S$</span> 的串去求 <span class="markdown-them-math-inline">$z$</span> 函数即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="经典例题">经典例题</h2><h3 id="[noi2014]-动物园">[NOI2014] 动物园</h3><p>对于每个 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算后缀 <span class="markdown-them-math-inline">$S_{i\sim n}$</span> 与 <span class="markdown-them-math-inline">$S$</span> 的 <span class="markdown-them-math-inline">$\rm LCP$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑在后一个 border 的左端点 <span class="markdown-them-math-inline">$i$</span> 处统计答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>令最长公共前缀的四个端点分别为 <span class="markdown-them-math-inline">$L,R,L',R'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分两种情况讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>当 <span class="markdown-them-math-inline">$R&lt;L'$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>区间 <span class="markdown-them-math-inline">$[L',R']$</span> 答案 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>当 <span class="markdown-them-math-inline">$R\geqslant L'$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>区间 <span class="markdown-them-math-inline">$[L',R]$</span> 答案 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>区间 <span class="markdown-them-math-inline">$+1$</span> 可以使用差分实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[cf1051e]-vasya and big integers">[CF1051E] Vasya and Big Integers</h3><p>记 <span class="markdown-them-math-inline">$f_i$</span> 表示 <span class="markdown-them-math-inline">$a_{1\sim i}$</span> 有多少种合法的划分方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有一个 <span class="markdown-them-math-inline">$\Theta(n^2)$</span> 的暴力 <span class="markdown-them-math-inline">$\rm DP$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即往前枚举转移点 <span class="markdown-them-math-inline">$j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>判断转移是否合法后累加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>观察到合法的转移点是一段连续的区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若令 <span class="markdown-them-math-inline">$len_l$</span> 和 <span class="markdown-them-math-inline">$len_r$</span> 分别表示两限制字符串的长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然对于满足 <span class="markdown-them-math-inline">$len_l&lt;i-j&lt;len_r$</span> 的转移点 <span class="markdown-them-math-inline">$j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个转移都是合法的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在的问题在于判断当 <span class="markdown-them-math-inline">$j=i-len_l$</span> 或 <span class="markdown-them-math-inline">$j=i-len_r$</span> 的时候转移是否合法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑用 <span class="markdown-them-math-inline">$\rm ExKMP$</span> 对任意一个 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求 <span class="markdown-them-math-inline">$\rm LCP(s_{i\sim n},l)$</span> 和 <span class="markdown-them-math-inline">$\rm LCP(s_{i\sim n},r)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样就可以快速求出 <span class="markdown-them-math-inline">$s_{i-len_l+1\sim i}$</span> 与 <span class="markdown-them-math-inline">$l$</span> 的最长公共前缀 <span class="markdown-them-math-inline">$zl_{i-len_l+1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并通过比较 <span class="markdown-them-math-inline">$s_{i-len_l+1+z_{i-len_l+1}}$</span> 与 <span class="markdown-them-math-inline">$l_{z_{i-len_l+1}+1}$</span> 的大小判断当 <span class="markdown-them-math-inline">$j=i-len_l$</span> 时转移是否合法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$j=i-len_r$</span> 时转移是否合法也可以通过相同方式判断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>合法转移点的区间就在 <span class="markdown-them-math-inline">$\Theta(1)$</span> 的时间内求出来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的用前缀和记录一下即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于不能出现前导零<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以当转移点的后一位为 ‘<span class="markdown-them-math-inline">$0$</span>’ 时不能将其加入前缀和数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「字符串」Manacher 算法</title>
      <link href="/2023/06/24/zi-fu-chuan-manacher-suan-fa/"/>
      <url>/2023/06/24/zi-fu-chuan-manacher-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>Manacher 算法学习笔记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><p><span class="markdown-them-math-inline">$\rm Manacher$</span> 是用于求解一个字符串中所有回文子串的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>回文子串的数量级是 <span class="markdown-them-math-inline">$n^2$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以要考虑如何将所有回文子串快速地表达出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现如下性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><p>如果存在一个以 <span class="markdown-them-math-inline">$p$</span> 为中心<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>半径为 <span class="markdown-them-math-inline">$d$</span> 的回文子串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那所有以 <span class="markdown-them-math-inline">$p$</span> 为中心<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>半径小于 <span class="markdown-them-math-inline">$d$</span> 的子串都是回文子串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>证明显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>于是我们记 <span class="markdown-them-math-inline">$d_i$</span> 表示以 <span class="markdown-them-math-inline">$i$</span> 为中心的最大回文子串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 <span class="markdown-them-math-inline">$\rm Manacher$</span> 算法的用处就是在线性复杂度下求出这个序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>具体过程跟 <span class="markdown-them-math-inline">$Z$</span> 算法类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$L,R$</span> 表示在之前的回文子串中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>右端点最靠右的子串的左右端点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移分三种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>若 <span class="markdown-them-math-inline">$i&gt;R$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$L=i-1,R=i+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>暴力更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>若 <span class="markdown-them-math-inline">$i\leqslant R~\&amp;~d_{L+R-i}&lt;R-i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$d_i=d_{L+R-i}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>若 <span class="markdown-them-math-inline">$i\leqslant R~\&amp;~d_{L+R-i}\geqslant R-i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$L=2i-R$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>暴力更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>由于 <span class="markdown-them-math-inline">$R$</span> 只会往右移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且每次暴力更新必定右移一位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>但是我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上面这种方法只处理了回文子串长度为奇数的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而偶数的情况只需要分开考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>奇偶性稍微改变一下即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但还有一种更加巧妙的方式可以规避分奇偶讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑给所有字符之间加入一个不可能出现的相同字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如字符串 <span class="markdown-them-math-inline">$abaca$</span> 变成 <span class="markdown-them-math-inline">$\#a\#b\#a\#c\#a\#$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样在奇数位上统计的就是字串长度为偶数的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在偶数位上统计的就是字串长度为奇数的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样统计出来的半径 <span class="markdown-them-math-inline">$d$</span> 就是以当前点为中心的最长回文子串的长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「字符串」KMP 算法 &amp; KMP 自动机</title>
      <link href="/2023/06/24/zi-fu-chuan-kmp-suan-fa-kmp-zi-dong-ji/"/>
      <url>/2023/06/24/zi-fu-chuan-kmp-suan-fa-kmp-zi-dong-ji/</url>
      
        <content type="html"><![CDATA[<p><span class="markdown-them-math-inline">$\rm KMP$</span> 算法和 <span class="markdown-them-math-inline">$\rm KMP$</span> 自动机学习笔记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>其中 <span class="markdown-them-math-inline">$\rm KMP$</span> 算法是算法竞赛中最基础的字符串算法之一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>必须熟练掌握<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="border-& $\pi$ 函数">Border &amp; <span class="markdown-them-math-inline">$\pi$</span> 函数</h2><h3 id="一些定义">一些定义</h3><ul><li><p>字符串 <span class="markdown-them-math-inline">$S$</span> 的真前/后缀为非自身的前/后缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>字符串 <span class="markdown-them-math-inline">$S$</span> 的 border为 <span class="markdown-them-math-inline">$S$</span> 的公共真前/后缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>字符串 <span class="markdown-them-math-inline">$S$</span> 的最长 border 为 <span class="markdown-them-math-inline">$\pi$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于 <span class="markdown-them-math-inline">$S$</span> 的每个前缀 <span class="markdown-them-math-inline">$S_{1 \sim i}$</span> 令 <span class="markdown-them-math-inline">$\pi_i$</span> 为其最长 border<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\pi$</span> 函数就是所谓的前缀函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><h3 id="$\pi$-函数的性质"><span class="markdown-them-math-inline">$\pi$</span> 函数的性质</h3><ul><li><span class="markdown-them-math-inline">$\forall i,\pi_{i+1}\leqslant \pi_i+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><blockquote><p>由反证法易知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><ul><li>字符串 <span class="markdown-them-math-inline">$S$</span> 的所有 border 可以由 <span class="markdown-them-math-inline">$\pi_{|S|}$</span> 开始不断跳 <span class="markdown-them-math-inline">$\pi$</span> 由长度从大到小遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><blockquote><p>只需证明 <span class="markdown-them-math-inline">$S_{1 \sim \pi_{\pi_n}}$</span> 是 <span class="markdown-them-math-inline">$S$</span> 的次长 border 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由 <span class="markdown-them-math-inline">$\pi$</span> 的定义易知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><ul><li>相邻前缀函数满足 <span class="markdown-them-math-inline">$\pi_{i + 1} = \max\limits_{T ~ is ~ the ~ border ~ of ~ S_{1 \sim i}, S_{i + 1} = S_{|T| + 1}} |T| + 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><blockquote><p>使用反证法易知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><h3 id="$\pi$-函数的线性求法"><span class="markdown-them-math-inline">$\pi$</span> 函数的线性求法</h3><p>有了上述几条性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以得到一个求解 <span class="markdown-them-math-inline">$\pi$</span> 函数的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code>pi[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = pi[i - <span class="hljs-number">1</span>]; j &gt;= <span class="hljs-number">0</span>; j = pi[j])        <span class="hljs-keyword">if</span> (s[j + <span class="hljs-number">1</span>] == s[i]) &#123; pi[i] = j + <span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>; &#125;</code></pre></div><p>直观感受上这个做法是 <span class="markdown-them-math-inline">$\Theta(n ^ 2)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但实际上它是线性的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度证明如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><p>不难发现复杂度来源在于跳 <span class="markdown-them-math-inline">$\pi$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下面我们将证明跳 <span class="markdown-them-math-inline">$\pi$</span> 的总次数是线性的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>注意 <span class="markdown-them-math-inline">$\pi_i$</span> 的位置变化情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不难发现 <span class="markdown-them-math-inline">$\pi_i$</span> 只会每次 <span class="markdown-them-math-inline">$+1$</span> 或往前跳若干次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但往前跳的的总距离不能超过当前 <span class="markdown-them-math-inline">$+1$</span> 的次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故总路程也是线性的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><h3 id="$\pi$-函数的基本应用"><span class="markdown-them-math-inline">$\pi$</span> 函数的基本应用</h3><h4 id="字符串匹配">字符串匹配</h4><p>求解模式串 <span class="markdown-them-math-inline">$T$</span> 在匹配串 <span class="markdown-them-math-inline">$S$</span> 中的出现位置的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>构造一个新的字符串 <span class="markdown-them-math-inline">$T\circ S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$\circ\not\in S\cup T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它仅作为一个分隔符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对这个新的字符串求其 <span class="markdown-them-math-inline">$\pi$</span> 函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不难发现由于分隔符的出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\forall i, \pi_i \leqslant |T|$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是找到 <span class="markdown-them-math-inline">$\pi_i = |T|$</span> 的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$i - |T| + 1 \sim i$</span> 就是一个匹配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>以上即为 <span class="markdown-them-math-inline">$\rm KMP$</span> 算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="统计每个前缀的出现次数">统计每个前缀的出现次数</h4><p>考虑到如果某个前缀在之后的位置里出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么一定是某个前缀的 border<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们考虑在每个数的最大 border 处统计答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其为更小 border 的重复次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且更小的 border 一定可以通过跳 <span class="markdown-them-math-inline">$\pi$</span> 遍历到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样只需要从后往前扫一遍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ans[i] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) ans[pi[i]] += ans[i];</code></pre></div><p>至于这个问题的加强版<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>统计 <span class="markdown-them-math-inline">$S$</span> 中的每个前缀在 <span class="markdown-them-math-inline">$T$</span> 中的出现次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以构造 <span class="markdown-them-math-inline">$S\#T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>赋初值的时候只需要将 <span class="markdown-them-math-inline">$T$</span> 中的位置初始化为 <span class="markdown-them-math-inline">$1$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h4 id="统计本质不同子串的数目">统计本质不同子串的数目</h4><p>考虑迭代计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>问题转化成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在当前字符串的末尾加入一个新的字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以这个字符结尾的后缀中有多少个是前面没有出现过的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>如果一个子串 <span class="markdown-them-math-inline">$S_{i\sim n}$</span> 在前面出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$\forall j\geqslant i,S_{j\sim n}$</span> 都在前面出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><blockquote><p>由反证法易知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>于是就只需求出加入新字符后的串的反串中的 <span class="markdown-them-math-inline">$\max\pi$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这个字符的贡献就是 <span class="markdown-them-math-inline">$|S|+1-\max\pi$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="字符串周期相关性质">字符串周期相关性质</h2><p>称 <span class="markdown-them-math-inline">$k$</span> 为 <span class="markdown-them-math-inline">$S$</span> 的一个周期且仅当 <span class="markdown-them-math-inline">$\forall i\leqslant |S|-k, S_i = S_{i + k}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特别地若 <span class="markdown-them-math-inline">$k \nmid S$</span> 则称 <span class="markdown-them-math-inline">$k$</span> 为 <span class="markdown-them-math-inline">$S$</span> 的弱周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li>若字符串 <span class="markdown-them-math-inline">$S$</span> 存在一个 border <span class="markdown-them-math-inline">$T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当 <span class="markdown-them-math-inline">$S$</span> 存在一个长度为 <span class="markdown-them-math-inline">$|S| - |T|$</span> 的<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><blockquote><p>必要性显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>充分性递归论证即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><ul><li>字符串 <span class="markdown-them-math-inline">$S$</span> 的最短<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>周期长度为 <span class="markdown-them-math-inline">$n - \pi_n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><blockquote><p>由 <span class="markdown-them-math-inline">$\pi$</span> 函数的定义易知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><ul><li>若长度不小于 <span class="markdown-them-math-inline">$p + q$</span> 的字符串 <span class="markdown-them-math-inline">$S$</span> 存在长度分别为 <span class="markdown-them-math-inline">$p, q$</span> 的<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$\gcd(p, q)$</span> 也是 <span class="markdown-them-math-inline">$S$</span> 的一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><blockquote><p>下面首先证明 <span class="markdown-them-math-inline">$p - q(p &gt; q)$</span> 也是 <span class="markdown-them-math-inline">$S$</span> 的一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>分两种情况讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ol><li><p>若 <span class="markdown-them-math-inline">$i \leqslant q$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$S_i = S_{i + p} = S_{i + p - q}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可知 <span class="markdown-them-math-inline">$\forall i \leqslant q, p - q$</span> 是其一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>若 <span class="markdown-them-math-inline">$i &gt; q$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$S_i = S_{i - q} = S_{i + p - q}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可知 <span class="markdown-them-math-inline">$\forall i &gt; q, p - q$</span> 是其一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ol><p>证明 <span class="markdown-them-math-inline">$p - q$</span> 是 <span class="markdown-them-math-inline">$S$</span> 的一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>周期后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据更相减损术的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终可以迭代至 <span class="markdown-them-math-inline">$\gcd(p, q)$</span> 是 <span class="markdown-them-math-inline">$S$</span> 的一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><ul><li>所有强周期的长度均为最短强周期长度的倍数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><blockquote><p>若存在一个强周期 <span class="markdown-them-math-inline">$x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有 <span class="markdown-them-math-inline">$x\mid n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$n-\pi_n\nmid x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$\gcd(n-\pi_n,x)&lt;n-\pi_n$</span> 也为一个强周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与 <span class="markdown-them-math-inline">$n-\pi_n$</span> 是最小强周期矛盾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><ul><li>字符串 <span class="markdown-them-math-inline">$S$</span> 存在周期当且仅当 <span class="markdown-them-math-inline">$n - \pi_n$</span> 为一个周期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><blockquote><p>必要性显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若存在强周期 <span class="markdown-them-math-inline">$x\mid n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>又因为 <span class="markdown-them-math-inline">$n-\pi_n\mid x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$n-\pi_n\mid n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>充分性得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><h2 id="kmp-自动机">KMP 自动机</h2><p>在求 <span class="markdown-them-math-inline">$\pi$</span> 函数的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现这个做法是支持在线插入一个字符在末尾并计算函数值的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>并且在做 <span class="markdown-them-math-inline">$\rm KMP$</span> 的过程中我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在匹配串每一位求 <span class="markdown-them-math-inline">$\pi$</span> 函数时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并不关心之前匹配串的字符是什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只关心之前的 <span class="markdown-them-math-inline">$\pi$</span> 函数值和当前位的字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这意味着可以对一个模式串建立一个自动机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结点 <span class="markdown-them-math-inline">$i$</span>  表示当前节点的 <span class="markdown-them-math-inline">$\pi$</span> 值为 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>新加入一个节点的出边 <span class="markdown-them-math-inline">$c$</span> 指向跳 <span class="markdown-them-math-inline">$\pi$</span> 时第一个能够匹配的结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>暴力建这个自动机的复杂度为 <span class="markdown-them-math-inline">$\Theta(n^2|\Sigma|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为出边需要遍历 <span class="markdown-them-math-inline">$\Sigma$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不存在求 <span class="markdown-them-math-inline">$\pi$</span> 函数时指针单方向移动的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>但是实际上之前已经计算了从所有节点开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以任意一个字符为出边会到哪个节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故可以直接调用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体规则为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$f_{i,c}$</span> 表示从 <span class="markdown-them-math-inline">$i$</span> 号节点开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>字符 <span class="markdown-them-math-inline">$c$</span> 会到达的节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果当前到达了节点 <span class="markdown-them-math-inline">$i$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>字符为 <span class="markdown-them-math-inline">$c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则如果 <span class="markdown-them-math-inline">$c=s_{i+1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么当前节点指向 <span class="markdown-them-math-inline">$i+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则指向 <span class="markdown-them-math-inline">$f_{\pi_i,c}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n|\Sigma|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>同 <span class="markdown-them-math-inline">$\rm KMP$</span> 算法一样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\rm KMP$</span> 自动机也可以用来实现若干文本串和模式串的匹配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>文本串从节点 <span class="markdown-them-math-inline">$0$</span> 开始走<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次走到 <span class="markdown-them-math-inline">$|S|$</span> 都完成了一次匹配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若模式串长度为 <span class="markdown-them-math-inline">$m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>文本串长度为 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数量为 <span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则时间复杂度为 <span class="markdown-them-math-inline">$\Theta(m+tn|\Sigma|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>另一方面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\rm KMP$</span> 自动机在完成普通字符串匹配时表现并不优秀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但它可以求解一些特殊的字符串匹配问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>定义 <span class="markdown-them-math-inline">$g_1=&quot;a&quot;$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g_2=&quot;aba&quot;$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g_3=&quot;abacaba&quot;\cdots \forall i,g_i=g_{i-1}+(char)i+g_{i-1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 给定另一字符串 <span class="markdown-them-math-inline">$S$</span> 和整数 <span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求 <span class="markdown-them-math-inline">$S$</span> 在 <span class="markdown-them-math-inline">$g_k$</span> 中的匹配次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>保证 <span class="markdown-them-math-inline">$|S|\times k\leqslant 10^6$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>显然题目是要求从 <span class="markdown-them-math-inline">$0$</span> 号节点开始对 <span class="markdown-them-math-inline">$g_k$</span> 进行匹配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>经过 <span class="markdown-them-math-inline">$|S|$</span> 号节点的次数是多少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先对 <span class="markdown-them-math-inline">$S$</span> 建立 <span class="markdown-them-math-inline">$\rm KMP$</span> 自动机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$f_{i,j}$</span> 表示从 <span class="markdown-them-math-inline">$i$</span> 号节点开始对 <span class="markdown-them-math-inline">$g_j$</span> 进行匹配后经过 <span class="markdown-them-math-inline">$|S|$</span> 号节点的次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$k_{i,S}$</span> 表示从 <span class="markdown-them-math-inline">$i$</span> 号节点开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>匹配完字符串 <span class="markdown-them-math-inline">$S=g_i+(char)i$</span> 后停下来的结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i,j}=f_{i,j-1}+[k_{i,g_{j-1}+(char)(j-1)}=|S|]+f_{k_{i,g_{j-1}+(char)(j-1)},j-1}$$</div><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(|S|\times k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于单次添加结点的复杂度是严格 <span class="markdown-them-math-inline">$\Theta(|\Sigma|)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以对 <span class="markdown-them-math-inline">$\rm KMP$</span> 自动机进行可持久化处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n|\Sigma|\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://codeforces.com/problemset/problem/808/G">[CF808G] Anthem of Berland</a></p><p>考虑对模式串建立 <span class="markdown-them-math-inline">$\rm KMP$</span> 自动机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>令 <span class="markdown-them-math-inline">$f_{i,j}$</span> 表示对字符串匹配到第 <span class="markdown-them-math-inline">$i$</span> 位时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳到自动机的 <span class="markdown-them-math-inline">$j$</span> 号点匹配的次数最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i,to}=\begin{cases}\max\{f_{i-1,j}+[to=m]\}(s_i\not =~'?')\\\max\limits_{k=0}^{25}\{f_{i-1,j}+[to=m]\}(s_i=~'?')\end{cases}$$</div><p>由于 <span class="markdown-them-math-inline">$\rm DP$</span> 空间开不下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要使用滚动数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(|S||T||\Sigma|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「字符串」AC 自动机</title>
      <link href="/2023/06/24/zi-fu-chuan-ac-zi-dong-ji/"/>
      <url>/2023/06/24/zi-fu-chuan-ac-zi-dong-ji/</url>
      
        <content type="html"><![CDATA[<p>AC 自动机学习笔记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h3 id="失配指针">失配指针</h3><p>定义 fail 为广义的 <span class="markdown-them-math-inline">$\pi$</span> 函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即对于 <span class="markdown-them-math-inline">$n$</span> 个字符串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$fail_{i,j}=\max\limits_{k=1}^n \pi(S_k\#S_{i,1\sim j})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>上面那个是一种定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但事实上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$\rm AC$</span> 自动机中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>fail 是具有指向性的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它指向的是所有模式串中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前缀与当前字符串某个前缀的后缀匹配可以产生最大匹配的那个串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它与当前串匹配的最后一个结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="构建-ac 自动机">构建 AC 自动机</h3><p>首先对所有模式串建立 Trie 树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然 Trie 树上的每一个结点都对应某个模式串的某个前缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后将每个 fail 都指向匹配的结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显而易见<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所有的 fail 都指向一个祖先节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个性质后面要用到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最后构建转移边 Auto<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Auto 指向跳 fail 过程中存在字符 <span class="markdown-them-math-inline">$c$</span> 的结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以以 <span class="markdown-them-math-inline">$\rm BFS$</span> 序遍历 Trie 树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在遍历的同时更新答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移式如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{cases}fail_u=Auto_{fail_{fa_u},c}\\Auto_{u,c}=Auto_{fail_u,c}\end{cases}$$</div><p>建 <span class="markdown-them-math-inline">$\rm AC$</span> 自动机复杂度为 <span class="markdown-them-math-inline">$\Theta(|\Sigma|n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="文本串匹配">文本串匹配</h3><p>遍历文本串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接按照转移边走即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果要统计每个模式串出现的次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就将所有经过的点权值 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再在 fail 树上差分即可计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>令模式串为 <span class="markdown-them-math-inline">$S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>文本串为 <span class="markdown-them-math-inline">$T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总时间复杂度为 <span class="markdown-them-math-inline">$\Theta(|\Sigma||S|+|T|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://www.luogu.com.cn/problem/P2292">[HNOI2004]L语言</a></p><p>首先有一个显然的 <span class="markdown-them-math-inline">$\Theta(|s|\sum|t|)$</span> 暴力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举文本串的转移点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然其不能超过最大串长<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移式为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_i=\bigvee_{j=i-|s|}^{i-1}\{f_j\wedge[t_{j+1\sim i}\in s]\}$$</div><p>这个式子的核心在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f_i=true$</span> 当且仅当它存在一个后缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个后缀是某个模式串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且删去这个后缀以后的文本串仍合法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是考虑建立 <span class="markdown-them-math-inline">$\rm AC$</span> 自动机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将文本串放在自动机上跑的时候记 <span class="markdown-them-math-inline">$f_i$</span> 表示当前前缀是否合法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><blockquote><p>存在如下 <span class="markdown-them-math-inline">$\rm AC$</span> 自动机性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果 <span class="markdown-them-math-inline">$v$</span> 可以从 <span class="markdown-them-math-inline">$u$</span> 开始由跳 fail 得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 fail 树上 <span class="markdown-them-math-inline">$v$</span> 是 <span class="markdown-them-math-inline">$u$</span> 的祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$v$</span> 代表的字符串是 <span class="markdown-them-math-inline">$u$</span> 代表的字符串的一个后缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>所以从 <span class="markdown-them-math-inline">$u$</span> 开始遍历跳 fail 经过的结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果它代表的字符串长度为 <span class="markdown-them-math-inline">$l$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且为某个模式串的结尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将 <span class="markdown-them-math-inline">$g_{u,l}$</span> 记为 true<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 由于 <span class="markdown-them-math-inline">$|s|\leqslant 10$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以只有当 <span class="markdown-them-math-inline">$l\leqslant 10$</span> 的时候 <span class="markdown-them-math-inline">$g_{u,l}$</span> 可能为 true<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故直接状压成 <span class="markdown-them-math-inline">$g_u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其二进制下第 <span class="markdown-them-math-inline">$l$</span> 位表示之前 <span class="markdown-them-math-inline">$g_{u,l}$</span> 的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最后直接将文本串放在 <span class="markdown-them-math-inline">$\rm AC$</span> 自动机上跑即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$now_i$</span> 表示文本串中当前点前 <span class="markdown-them-math-inline">$i$</span> 位的 <span class="markdown-them-math-inline">$f$</span> 值为多少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>易知 <span class="markdown-them-math-inline">$i\leqslant 10$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故也可以状压成一个数 <span class="markdown-them-math-inline">$now$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 易知 <span class="markdown-them-math-inline">$f_i=true$</span> 当且仅当 <span class="markdown-them-math-inline">$[now~or~g_u]=true$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(|\Sigma|n|s|^2+m|t|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「字符串」(可持久化) Trie 树</title>
      <link href="/2023/06/24/zi-fu-chuan-ke-chi-jiu-hua-trie-shu/"/>
      <url>/2023/06/24/zi-fu-chuan-ke-chi-jiu-hua-trie-shu/</url>
      
        <content type="html"><![CDATA[<p>(可持久化) Trie 树学习笔记及经典例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="字典树">字典树</h2><p>顾名思义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>字典树就是支持像字典一样加入和查询字符串的树形数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">namespace</span> Trie &#123;    <span class="hljs-keyword">int</span> Next[N][K], cnt, tag[N];    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span> <span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>), now = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-keyword">int</span> c = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;            <span class="hljs-keyword">if</span> (!Next[now][c]) Next[now][c] = ++cnt;            now = Next[now][c];        &#125;        tag[now]++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>), now = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-keyword">int</span> c = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;            <span class="hljs-keyword">if</span> (!Next[now][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            now = Next[now][c];        &#125;        <span class="hljs-keyword">return</span> tag[now];    &#125;&#125;</code></pre></div><h2 id="0/1-trie">0/1 Trie</h2><p>在很多问题中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>字符串仅由 <span class="markdown-them-math-inline">$0$</span> 和 <span class="markdown-them-math-inline">$1$</span> 构成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些问题存在一定的共性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="维护异或极值">维护异或极值</h3><p>考虑如下问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给定一颗带边权的树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求 <span class="markdown-them-math-inline">$\max\limits_{i,j\in[1,n]} \oplus Path(i,j)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由异或的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可知 <span class="markdown-them-math-inline">$\oplus Path(i,j)=\oplus Path(root,i)\oplus Path(root,j)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>所以可以把所有从根开始的路径的异或和表示成一个数字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样就将问题转化成了求任意两个数字的异或的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以用 <span class="markdown-them-math-inline">$\rm 0/1~Trie$</span> 解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="维护异或和">维护异或和</h3><p>考虑如下问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给一些数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护它们的异或和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>支持插入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删除和全局 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于异或和的维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现 <span class="markdown-them-math-inline">$sum=\sum_{i=0}^k2^i\times [num_i\equiv 1\pmod 2]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>其中 <span class="markdown-them-math-inline">$sum$</span> 表示异或和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$num_i$</span> 表示所有数中二进制的第 <span class="markdown-them-math-inline">$i$</span> 位为 <span class="markdown-them-math-inline">$1$</span> 的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个式子体现在 <span class="markdown-them-math-inline">$\rm 0/1~Trie$</span> 上就是对于所有以父亲边为 <span class="markdown-them-math-inline">$1$</span> 的结点为根的子树中有多少个 <span class="markdown-them-math-inline">$\rm Tag$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$\rm Tag$</span> 的数量为 <span class="markdown-them-math-inline">$num$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些结点的深度为 <span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它们对答案的贡献即为 <span class="markdown-them-math-inline">$num\%2\times 2^k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于实现全局 <span class="markdown-them-math-inline">$+1$</span> 操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从低位到高维建 <span class="markdown-them-math-inline">$\rm 0/1~Trie$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑将一个二进制数 <span class="markdown-them-math-inline">$+1$</span> 的一般操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即找到从低位到高位的第一个 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将它变成 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数位比它低的 <span class="markdown-them-math-inline">$1$</span> 全部变成 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 而这个做法体现在 <span class="markdown-them-math-inline">$\rm 0/1~Trie$</span> 上可以将一个结点的两条指向儿子的出边交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再递归向交换后的 <span class="markdown-them-math-inline">$0$</span> 边迭代操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="$0/1$-trie 合并"><span class="markdown-them-math-inline">$0/1$</span> Trie 合并</h3><p>与线段树合并类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!p || !k) &#123; p = p + k; <span class="hljs-keyword">return</span>; &#125;    tag[p] += tag[k];    <span class="hljs-built_in">Merge</span>(l[p], l[k]), <span class="hljs-built_in">Merge</span>(r[p], r[k]);    <span class="hljs-built_in">Push_up</span>();&#125;</code></pre></div><p>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Trie 树合并和线段树合并一样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只有当每次合并的集合没有交集的时候复杂度才是 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="可持久化-trie 树">可持久化 Trie 树</h2><p>可持久化 Trie 的实现方式和可持久化线段树的方式是相似的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即每次只修改被添加或值被修改的节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而保留没有被改动的节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在上一个版本的基础上连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使最后每个版本的 Trie 树的根遍历所能分离出的 Trie 树都是完整且包含全部信息的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实现如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">namespace</span> Trie &#123;    <span class="hljs-keyword">int</span> rt[N &lt;&lt; <span class="hljs-number">5</span>], Next[N &lt;&lt; <span class="hljs-number">5</span>][<span class="hljs-number">2</span>], cnt, tag[N &lt;&lt; <span class="hljs-number">5</span>];    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Build</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;    <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        x = ++cnt;        <span class="hljs-keyword">if</span> (!pos) tag[x]++;        tag[x] += tag[y];        <span class="hljs-keyword">int</span> d = (k &amp; (<span class="hljs-number">1</span> &lt;&lt; pos)) != <span class="hljs-number">0</span>;        Next[x][d ^ <span class="hljs-number">1</span>] = Next[y][d ^ <span class="hljs-number">1</span>];        <span class="hljs-built_in">Build</span>(Next[x][d], Next[y][d], k, pos - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Query</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> d = (k &amp; (<span class="hljs-number">1</span> &lt;&lt; pos)) != <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> tag[x] - tag[y] + <span class="hljs-built_in">Query</span>(Next[x][d], Next[y][d], k, pos - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><h2 id="经典例题">经典例题</h2><h3 id="[lg4735]-最大异或和">[LG4735] 最大异或和</h3><p>可持久化 <span class="markdown-them-math-inline">$0/1$</span> Trie 模板题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑记所有的前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案变为统计 <span class="markdown-them-math-inline">$x\oplus sum_n$</span> 在 <span class="markdown-them-math-inline">$[l-1,r-1]$</span> 这个区间的 <span class="markdown-them-math-inline">$0/1$</span> Trie 中的最大异或值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[cf455b]-a lot of games">[CF455B] A Lot of Games</h3><p>显然直接建立 Trie 树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次相当于向 Trie 树的子树内走一步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不能走者为负<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑设 <span class="markdown-them-math-inline">$f$</span> 表示是否存在必胜策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g$</span> 表示是否存在必败策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对 <span class="markdown-them-math-inline">$f_{root}$</span> 和 <span class="markdown-them-math-inline">$g_{root}$</span> 分四种情况讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每种情况下的答案易得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果先手既存在必胜策略又存在必败策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那他可以故意输以获得下一局的先手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后在最后一局获得胜利<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[cf888g]-xor-mst">[CF888G] Xor-MST</h3><p><span class="markdown-them-math-inline">$\rm Trie+Boruvka$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑将所有树插入一个 Trie 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举到某个连通块时将其中所有点从 Tire 中删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再用连通块中每个结点从 Trie 中查找出最小边权<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>完成后再将连通块中的点权加回去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>发现一个性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次合并的连通块都是 Trie 中某个节点的左右子树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再由 Trie 的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们甚至不需要把 Trie 建出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要将 A 排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>二分 Trie 的左右儿子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再将其中一个儿子的所有结点建 Trie<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用另一个儿子中的所有结点在其中查找连通块之间的最小边权即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由于每个结点最多被加进 Trie 树 <span class="markdown-them-math-inline">$\log n$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次复杂度为 <span class="markdown-them-math-inline">$\log W$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以总时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n\log n\log W)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「图论」虚树</title>
      <link href="/2023/06/24/tu-lun-xu-shu/"/>
      <url>/2023/06/24/tu-lun-xu-shu/</url>
      
        <content type="html"><![CDATA[<p>虚树学习笔记及经典例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="虚树">虚树</h2><p>在一些问题中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只关心关键点的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时我们需要维护他们之间的树形结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是可以想到将它们和它们之间的 <span class="markdown-them-math-inline">$\rm LCA$</span> 拉出来建一颗树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这棵树就被称作虚树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有一个朴素的想法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是对它们两两求 <span class="markdown-them-math-inline">$\rm LCA$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且对求出的 <span class="markdown-them-math-inline">$\rm LCA$</span> 再求 <span class="markdown-them-math-inline">$\rm LCA$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>中途判重<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后按照祖先关系连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>经过观察可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只需要按照 <span class="markdown-them-math-inline">$\rm dfs$</span> 虚从小到大的顺序枚举每个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将相邻两点求 <span class="markdown-them-math-inline">$\rm LCA$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以维护一个栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个栈中存的是当前点在虚树上的所有祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设当前栈顶为 <span class="markdown-them-math-inline">$v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于新加入的结点 <span class="markdown-them-math-inline">$u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们对它进行分类讨论 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>若 <span class="markdown-them-math-inline">$\rm LCA(u,v)=v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么直接将 <span class="markdown-them-math-inline">$u$</span> 入栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>若 <span class="markdown-them-math-inline">$\rm LCA(u,v)$</span> 是栈中某个不为 <span class="markdown-them-math-inline">$v$</span> 的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则弹栈直到 <span class="markdown-them-math-inline">$\rm LCA(u,v)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每弹一个就向栈中比它深度多 <span class="markdown-them-math-inline">$1$</span> 的结点连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后并把 <span class="markdown-them-math-inline">$u$</span> 入栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>若 <span class="markdown-them-math-inline">$\rm LCA(u,v)$</span> 不在栈中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么弹栈直到栈顶的 <span class="markdown-them-math-inline">$\rm dfs$</span> 序小于 <span class="markdown-them-math-inline">$\rm LCA(u,v)$</span> 的 <span class="markdown-them-math-inline">$\rm dfs$</span> 序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每弹一个就向栈中比它深度多 <span class="markdown-them-math-inline">$1$</span> 的结点连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并把最后一个弹出的结点向 <span class="markdown-them-math-inline">$\rm LCA(u,v)$</span> 连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后把 <span class="markdown-them-math-inline">$\rm LCA(u,v)$</span> 和 <span class="markdown-them-math-inline">$u$</span> 入栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>不难发现这样一定是对的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且设关键点数量为 <span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则虚树内点数不超过 <span class="markdown-them-math-inline">$2k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>在一棵有 <span class="markdown-them-math-inline">$n$</span> 个点的树上建立一颗有 <span class="markdown-them-math-inline">$k$</span> 个点的虚树的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(k\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="经典例题">经典例题</h2><h3 id="[sdoi2011]-消耗战">[SDOI2011] 消耗战</h3><p>首先有一个暴力 <span class="markdown-them-math-inline">$\rm DP$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$dp_u$</span> 表示将 <span class="markdown-them-math-inline">$u$</span> 的子树内所有关键点与 <span class="markdown-them-math-inline">$u$</span> 的联系断开所需要的最小代价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>转移时枚举 <span class="markdown-them-math-inline">$u$</span> 的所有子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分类讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>若 <span class="markdown-them-math-inline">$v$</span> 为关键点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么必须切断这条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$dp_u=dp_u+w_{u,v}$</span></li><li>若 <span class="markdown-them-math-inline">$v$</span> 不为关键点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么可以切断这条边也可以从 <span class="markdown-them-math-inline">$dp_v$</span> 转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故有 <span class="markdown-them-math-inline">$dp_u=dp_u+min\{dp_v,w_{u,v}\}$</span></li></ul><p>最终答案就是 <span class="markdown-them-math-inline">$dp_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个暴力的时间复杂度是 <span class="markdown-them-math-inline">$\Theta(qn)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>观察到 <span class="markdown-them-math-inline">$\sum k\leqslant 5e5$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以考虑对每次询问建虚树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>建虚树之前需要记 <span class="markdown-them-math-inline">$M_u$</span> 表示从 <span class="markdown-them-math-inline">$1$</span> 到 <span class="markdown-them-math-inline">$u$</span> 的路径上最短的边权<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为只需要切掉最短的边权就可以让点 <span class="markdown-them-math-inline">$u$</span> 与 <span class="markdown-them-math-inline">$1$</span> 不连通<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而切上面的边是更优的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以用 <span class="markdown-them-math-inline">$M_u$</span> 直接替换转移方程中的 <span class="markdown-them-math-inline">$w_{u,v}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(\sum k\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[heoi2014]-大工程">[HEOI2014] 大工程</h3><p>首先建虚树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li>对于两两之间距离之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以计算每条边的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>对于最大<span class="markdown-them-math-inline">$/$</span>最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以树形 <span class="markdown-them-math-inline">$\rm DP$</span> 或点分治<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(\sum k\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[sdoi2015]-寻宝游戏">[SDOI2015] 寻宝游戏</h3><p>我们发现如果将虚树建出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么答案就是虚树上所有边权之和的两倍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是我们考虑动态维护虚树的边权之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>先把所有点的 <span class="markdown-them-math-inline">$\rm dfs$</span> 序求出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后我们发现边权之和等于 <span class="markdown-them-math-inline">$\rm dfs$</span> 序相邻两点的距离之和加上最左边和最右边两点的距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们可以使用 <span class="markdown-them-math-inline">$\rm set$</span> 维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>树剖求 <span class="markdown-them-math-inline">$\rm LCA$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\rm \Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「图论」长链剖分</title>
      <link href="/2023/06/24/tu-lun-chang-lian-pou-fen/"/>
      <url>/2023/06/24/tu-lun-chang-lian-pou-fen/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了长链剖分及其应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h3 id="长链剖分">长链剖分</h3><p>考虑将重儿子设为链最长的那一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剖分是简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以做到 <span class="markdown-them-math-inline">$\Theta(n).$</span></p><p>这样剖分有一些性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>链长和是 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为每个点都在且仅在一条链中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>任意点 <span class="markdown-them-math-inline">$x$</span> 的 <span class="markdown-them-math-inline">$k$</span> 级祖先 <span class="markdown-them-math-inline">$y$</span> 到它所在的长链底端距离不小于 <span class="markdown-them-math-inline">$k$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为如果 <span class="markdown-them-math-inline">$x$</span> 和 <span class="markdown-them-math-inline">$y$</span> 在同一条长链上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$y$</span> 所在的长链长度不小于 <span class="markdown-them-math-inline">$k$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果它们不在同一条的长链上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$y$</span> 到另一条长链底端的距离一定大于 <span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则的话 <span class="markdown-them-math-inline">$x$</span> 所在的链就可以接在 <span class="markdown-them-math-inline">$y$</span> 上成为更长的链<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>从任意一个点开始跳重链的次数最多是 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 级别的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为容易知道每次跳到的长链长度一定大于当前链<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是最坏情况是分别经过了长度为 <span class="markdown-them-math-inline">$1, 2, 3, \cdots, \sqrt{n}$</span> 的长链<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最多跳 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><h3 id="$\theta(n-\log n) - \theta(1)$ 算 $k$ 级祖先"><span class="markdown-them-math-inline">$\Theta(n \log n) - \Theta(1)$</span> 算 <span class="markdown-them-math-inline">$k$</span> 级祖先</h3><p>考虑预处理每个点的 <span class="markdown-them-math-inline">$2$</span> 的幂次级祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于一次询问 <span class="markdown-them-math-inline">$(u, k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>首先跳到 <span class="markdown-them-math-inline">$u$</span> 的 <span class="markdown-them-math-inline">$highbit(k)$</span> 级祖先 <span class="markdown-them-math-inline">$v$</span> 上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由长链剖分的性质可知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$v$</span> 到其所在长链底端的距离不小于 <span class="markdown-them-math-inline">$highbit(k).$</span></p><p>由于长链长度之和为 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以我们可以预处理每条链顶端节点的 <span class="markdown-them-math-inline">$l$</span> 级祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$l$</span> 取遍不大于链长的所有整数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>并且我们还可以存下每条链的所有节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>挂在链顶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于一次询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设 <span class="markdown-them-math-inline">$v$</span> 的 <span class="markdown-them-math-inline">$k - higtbit(k)$</span> 级祖先不超过链顶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么可以直接查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则也可以从链顶跳若干步得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于 <span class="markdown-them-math-inline">$k - highbit(k) &lt; hightbit(k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故其一定小于链长<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要查询的祖先是预处理过的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span> 预处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单次查询 <span class="markdown-them-math-inline">$\Theta(1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「图论」缩点 &amp; 割点 &amp; 割边</title>
      <link href="/2023/06/24/tu-lun-suo-dian-ge-dian-ge-bian/"/>
      <url>/2023/06/24/tu-lun-suo-dian-ge-dian-ge-bian/</url>
      
        <content type="html"><![CDATA[<p>Tarjan 缩点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求割点/割边学习笔记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="tarjan-算法">Tarjan 算法</h2><h3 id="强连通分量">强连通分量</h3><p>若图 <span class="markdown-them-math-inline">$G$</span> 中存在一个子图 <span class="markdown-them-math-inline">$G'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$G'$</span> 中任意两点均可互相到达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则称 <span class="markdown-them-math-inline">$G'$</span> 为 <span class="markdown-them-math-inline">$G$</span> 的一个<strong>强连通分量</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$G'$</span> 不存在一个严格子图为强连通分量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$G'$</span> 为 <span class="markdown-them-math-inline">$G$</span> 的<strong>极大</strong>强连通分量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>图的强连通分量可以考虑使用 <span class="markdown-them-math-inline">$\rm Tarjan$</span> 算法求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$\rm Tarjan$</span> 算法的思想是这样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果一个点的 <span class="markdown-them-math-inline">$\rm dfs$</span> 序等于他能访问到的最小的 <span class="markdown-them-math-inline">$\rm dfs$</span> 序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么在 <span class="markdown-them-math-inline">$\rm dfs$</span> 树中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的下方会出现一个强连通分量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且所有最小能访问到的 <span class="markdown-them-math-inline">$\rm dfs$</span> 序等于它的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>属于这个强连通分量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n+m)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>参考代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tarjan</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;    dfn[u] = low[u] = ++tix, Sta[++top] = u;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = last[u]; i; i = Next[i])        <span class="hljs-keyword">if</span> (!dfn[to[i]]) <span class="hljs-built_in">Tarjan</span>(to[i]), low[u] = <span class="hljs-built_in">min</span>(low[u], low[to[i]]);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!SCC[to[i]]) low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[to[i]]);    <span class="hljs-keyword">if</span> (dfn[u] == low[u]) &#123;        SCC[u] = ++id;        <span class="hljs-keyword">while</span> (Sta[top] != u) SCC[Sta[top--]] = id;        top--;    &#125;&#125;</code></pre></div><h3 id="点/边双连通分量">点/边双连通分量</h3><p>如果在 <span class="markdown-them-math-inline">$\rm dfs$</span> 树上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>某个结点 <span class="markdown-them-math-inline">$u$</span> 存在一个子节点 <span class="markdown-them-math-inline">$v$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="markdown-them-math-inline">$low_v\geqslant dfn_u$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则说明 <span class="markdown-them-math-inline">$v$</span>  想到达 <span class="markdown-them-math-inline">$u$</span> 的祖先结点必须经过 <span class="markdown-them-math-inline">$u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$u$</span> 是一个割点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根节点不能通过这种方式来判断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应该看它的子节点数是否大于等于 <span class="markdown-them-math-inline">$2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则它为割点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>遍历的时候要记得判掉父子边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>和判断割点的方法几乎一模一样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>唯一的区别是判断 <span class="markdown-them-math-inline">$dfn_u&lt;low_v$</span> 而不是 <span class="markdown-them-math-inline">$dfn_u\leqslant low_v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如果从 <span class="markdown-them-math-inline">$v$</span> 出发连 <span class="markdown-them-math-inline">$u$</span> 都无法到达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$(u, v)$</span> 就是一条割边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>判断割边的时候根节点不需要特殊考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n+m)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>参考代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tarjan</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;    dfn[u] = low[u] = ++tix;    <span class="hljs-keyword">int</span> son = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = last[u]; i; i = Next[i]) &#123;        <span class="hljs-keyword">if</span> (!dfn[to[i]]) &#123;            son++, <span class="hljs-built_in">Tarjan</span>(to[i], rt);            low[u] = <span class="hljs-built_in">min</span>(low[u], low[to[i]]);            <span class="hljs-keyword">if</span> (low[to[i]] &gt;= dfn[u] &amp;&amp; u != rt) cut[u] = <span class="hljs-literal">true</span>;        &#125;        low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[to[i]]);    &#125;    <span class="hljs-keyword">if</span> (u == rt &amp;&amp; son &gt; <span class="hljs-number">1</span>) cut[u] = <span class="hljs-literal">true</span>;&#125;</code></pre></div><h2 id="经典例题">经典例题</h2><h3 id="[国家集训队]-稳定婚姻">[国家集训队] 稳定婚姻</h3><p>首先在夫妻之间连有向边 <span class="markdown-them-math-inline">$B_i\to G_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后在情人之间连有向边 <span class="markdown-them-math-inline">$G_i\to B_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$G_i$</span> 和 <span class="markdown-them-math-inline">$B_i$</span> 的婚姻情况发生了改变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么一定存在一个从 <span class="markdown-them-math-inline">$G_i$</span> 开始 <span class="markdown-them-math-inline">$B_i$</span> 结束的环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是我们使用 <span class="markdown-them-math-inline">$\rm Tarjan$</span> 算法求强连通分量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$B_i$</span> 与 <span class="markdown-them-math-inline">$G_i$</span> 属于同一个强连通分量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那他们一定属于一个环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则他们是不安全的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则就是安全的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n+m)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[zjoi2007]-最大半连通子图">[ZJOI2007] 最大半连通子图</h3><p>首先缩点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现强连通分量内的点一定属于同一个极大半连通子图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后将 <span class="markdown-them-math-inline">$\rm DAG$</span> 画出来发现最大半连通子图一定是某条从无入度结点到无出度结点的链<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>长度和方案数直接 <span class="markdown-them-math-inline">$\rm DAG$</span> 上 <span class="markdown-them-math-inline">$\rm DP$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在这题中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于求的是导出子图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不能有重边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n+m)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[hnoi2012]-矿场搭建">[HNOI2012] 矿场搭建</h3><p>先把个点和点双连通分量处理出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每个点双分开处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>若该点双无割点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则需要建两个出口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>若该点双有一个割点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则需要在这个点双内建一个出口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且不能建在割点上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>若该点有两个以上割点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则不需要建出口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为一定可以从某个割点跑出去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>方案数直接乘法原理计算即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n+m)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[haoi2010]-软件安装">[HAOI2010] 软件安装</h3><p>可以发现这是一棵基环外向树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>依题意环中结点必须选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的构成一棵树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接树上背包即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(nm)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「图论」欧拉回路</title>
      <link href="/2023/06/24/tu-lun-ou-la-hui-lu/"/>
      <url>/2023/06/24/tu-lun-ou-la-hui-lu/</url>
      
        <content type="html"><![CDATA[<p>欧拉回路学习笔记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h3 id="定义">定义</h3><ul><li><p><strong>欧拉路径</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果图中的一个路径包括每个边恰好一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则该路径称为欧拉路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p><strong>欧拉回路</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>首尾相接的欧拉路径被称为欧拉回路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><h3 id="判定">判定</h3><p>由于每一条边都要经过<strong>恰好一次</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此对于除了起点和终点之外的任意一个节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要进来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定要出去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故有如下结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>一个<strong>无向图</strong>存在欧拉<strong>回路</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当该图所有顶点<strong>度数都为偶数</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且该图只有一个存在边的连通块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>一个<strong>无向图</strong>存在欧拉<strong>路径</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当该图中<strong>奇点的数量为</strong> <span class="markdown-them-math-inline">$0$</span> <strong>或</strong> <span class="markdown-them-math-inline">$2$</span> 且该图只有一个存在边的连通块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>一个<strong>有向图</strong>存在欧拉<strong>回路</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当<strong>所有点的入度等于出度</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>一个<strong>混合图</strong>存在欧拉<strong>回路</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当<strong>存在一个对所有无向边定向的方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得所有点的入度等于出度</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求解需要用到网络流相关算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><h3 id="求解">求解</h3><p>一般使用 <span class="markdown-them-math-inline">$\rm dfs$</span> 算法求出一张图的欧拉回路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>给每一条边记一个 <span class="markdown-them-math-inline">$\rm vis$</span> 数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示其是否被访问过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后从一个点出发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历所有的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>直接 <span class="markdown-them-math-inline">$\rm dfs$</span> 的话可能会有一些点无法被遍历到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是在记录答案的时候可以倒着记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即当通过 <span class="markdown-them-math-inline">$u\to v$</span> 这条边的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以先将点 <span class="markdown-them-math-inline">$v~\rm dfs$</span> 完<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再加入 <span class="markdown-them-math-inline">$u\to v$</span> 这条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样做相当于如果碰到两个相邻的环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但只遍历了其中一个就走到头了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们需要走完另一个环后将两个环拼起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由于只需要将图遍历一遍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以时间复杂度是 <span class="markdown-them-math-inline">$\Theta(n + m)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="参考代码">参考代码</h3><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = last[u]; i; i = Next[i]) &#123;        <span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span>;        vis[i] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">int</span> record = i;        <span class="hljs-built_in">dfs</span>(to[i]);        Sta[++top] = record;    &#125;&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「图论」最短路</title>
      <link href="/2023/06/24/tu-lun-zui-duan-lu/"/>
      <url>/2023/06/24/tu-lun-zui-duan-lu/</url>
      
        <content type="html"><![CDATA[<p>三种常用的最短路算法 Floyd, Dijkstra 和 SPFA 就不赘述了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里讲一些最短路的拓展技巧和经典例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="最短路算法拓展技巧">最短路算法拓展技巧</h2><h3 id="floyd-传递闭包">Floyd 传递闭包</h3><p>有时候我们需要维护一些具有传递性的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如相等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>连通等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>初始条件往往是给定几组关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要把所有的关系求出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以把 Floyd 算法做一些调整<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$dis_{i,j}=dis_{i,j}~|~(dis_{i,k}~\&amp;~dis_{k,j})$$</div><p>时间复杂度还是 <span class="markdown-them-math-inline">$\Theta(n ^ 3)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但由于位运算的特殊性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有些时候可以使用 <code>bitset</code> 优化到 <span class="markdown-them-math-inline">$\Theta\left(\frac{n ^ 3}{\omega}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="johnson-重赋权">Johnson 重赋权</h3><p>对于多源最短路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们枚举一个点然后跑堆优化的 Dijkstra<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么复杂度是 <span class="markdown-them-math-inline">$\Theta(nm \log n)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在图比较稀疏的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个复杂度要优于 Floyd 算法的 <span class="markdown-them-math-inline">$\Theta(n ^ 3)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>但是 Dijkstra 算法要求所有边权均非负<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是就有了重赋权的技巧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们新建一个 <span class="markdown-them-math-inline">$0$</span> 号点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且从这个点出发向所有点连一条边权为 <span class="markdown-them-math-inline">$0$</span> 的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后跑单源最短路(SPFA 或者 Bellman-Ford)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设距离数组为 <span class="markdown-them-math-inline">$h$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> 接下来对于每条边 <span class="markdown-them-math-inline">$(u, v)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> 令</p><div class="markdown-them-math-block">$$w^{\prime}(u, v)=w(u, v)+h(u)-h(v)$$</div><p>这样所有的边权都变成非负的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以跑 Dijkstra 算法了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>接下来证明这样做为什么是对的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>首先由于 <span class="markdown-them-math-inline">$h(v) \leqslant h(u)+w(u, v),$</span> 所以新图的边权一定非负<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设新图上的最短路径为 <span class="markdown-them-math-inline">$d^{\prime}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>原图上的最短路径为 <span class="markdown-them-math-inline">$d$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}d^{\prime}(u, v) &amp;= \min _{a_{1}, a_{2}, \ldots, a_{k}} w^{\prime}\left(u, a_{1}\right)+w^{\prime}\left(a_{1}, a_{2}\right)+\cdots+w^{\prime}\left(a_{k}, v\right) \\\\&amp;= \min _{a_{1}, a_{2}, \ldots, a_{k}} w\left(u, a_{1}\right)+\left(h(u)-h\left(a_{1}\right)\right)+w\left(a_{1}, a_{2}\right)+\left(h\left(a_{2}\right)-h\left(a_{1}\right)\right)+\cdots+w\left(a_{k}, v\right)+\left(h(v)-h\left(a_{k}\right)\right) \\\\&amp;= h(u)-h(v)+\min _{a_{1}, a_{2}, \ldots, a_{k}} w\left(u, a_{1}\right)+\cdots+w\left(a_{k}, v\right) \\\\&amp;= h(u)-h(v)+d(u, v)\end{aligned}$$</div><p>这个证明用到了势能分析的思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果想进一步了解话可以参考本站<span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char><h-char class="bd bd-end"><h-inner>「</h-inner></h-char></span>杂项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>」</h-inner></h-char></span>复杂度分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char></span>一文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="最短路图">最短路图</h3><p>所谓最短路图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是在求完从 <span class="markdown-them-math-inline">$S$</span> 出发的单源最短路之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只保留最短路上的边形成的有向图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>只需要在求的过程中维护一个 <span class="markdown-them-math-inline">$pre_u$</span> 数组表示点 <span class="markdown-them-math-inline">$u$</span> 的前驱即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>很多最短路的变种都需要用这个算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有时候考虑最短路图也有利于发现一些隐藏的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="经典例题">经典例题</h2><h3 id="[lg1266]-速度限制">[LG1266] 速度限制</h3><p>记 <span class="markdown-them-math-inline">$dis_{i,j}$</span> 表示当前已经到 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上一个点是 <span class="markdown-them-math-inline">$j$</span> 的时间最短路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>本质上是个分层图最短路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接跑 Dijkstra 就好了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(nm\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[icpc-bj2006]-狼抓兔子">[ICPC-BJ2006] 狼抓兔子</h3><p>首先有定义 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><ul><li>平面图是指的存在某种方式使得图上所有边平铺在平面上无交<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>对偶图是指的将平面图上的每个区域看作一个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两点连边当且仅当两区域相邻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边权为将两区域分隔开的边的权值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul></blockquote><p>有定理 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><p>平面图两点间最小割等于对偶图两点间最短路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>于是在这道题中我们就可以将每个三角形区域看作一个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>相邻区域连边后跑从左下角到右上角的最短路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n^2\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[gxoi/gzoi2019]-旅行者">[GXOI/GZOI2019] 旅行者</h3><p>我们发现可以对 <span class="markdown-them-math-inline">$k$</span> 个点二进制分组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次将 <span class="markdown-them-math-inline">$k$</span> 个点分成两个集合 <span class="markdown-them-math-inline">$S_1$</span> 和 <span class="markdown-them-math-inline">$S_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建一个源点 <span class="markdown-them-math-inline">$s$</span> 向所有 <span class="markdown-them-math-inline">$S_1$</span> 中的结点连长度为 <span class="markdown-them-math-inline">$0$</span> 的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建一个汇点 <span class="markdown-them-math-inline">$t$</span> 从所有 <span class="markdown-them-math-inline">$S_2$</span> 中的结点开始向它连长度为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求从 <span class="markdown-them-math-inline">$s$</span> 到 <span class="markdown-them-math-inline">$t$</span> 的最短路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若答案为两点 <span class="markdown-them-math-inline">$x$</span> 和 <span class="markdown-them-math-inline">$y$</span> 之间的最短路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么一定有 <span class="markdown-them-math-inline">$x\not= y$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这意味着它们至少在某一次二进制分组中被分到了不同的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以这样一定可以找到两点间的最短路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(Tn\log n\log k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「图论」最小生成树</title>
      <link href="/2023/06/24/tu-lun-zui-xiao-sheng-cheng-shu/"/>
      <url>/2023/06/24/tu-lun-zui-xiao-sheng-cheng-shu/</url>
      
        <content type="html"><![CDATA[<p>介绍了几种常用的最小生成树算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="kruskal">Kruskal</h2><p>最常用且大部分情况下效率最高的最小生成树算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>将边按长度从小到大排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次贪心选择最短的一条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若这条边连接的两个点还为连通<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将两个点所在的连通块用这条边连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>连通块用并查集维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><blockquote><p>证明: 使用归纳法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>证明任何时候 Kruskal 算法选择的边集都被某棵 MST 所包含<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>基础: 对于算法刚开始时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然成立<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>最小生成树存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>归纳: 假设某时刻成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前边集为 <span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$T$</span> 为这棵 MST<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑下一条加入的边 <span class="markdown-them-math-inline">$e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>如果 <span class="markdown-them-math-inline">$e$</span> 属于 <span class="markdown-them-math-inline">$T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>否则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$T+e$</span> 一定存在一个环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑这个环上不属于 <span class="markdown-them-math-inline">$F$</span> 的另一条边 <span class="markdown-them-math-inline">$f$</span> ( 一定只有一条<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f$</span> 的权值一定不会比 <span class="markdown-them-math-inline">$e$</span> 小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不然 <span class="markdown-them-math-inline">$f$</span> 会在 <span class="markdown-them-math-inline">$e$</span> 之前被选取<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>然后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> <span class="markdown-them-math-inline">$f$</span> 的权值一定不会比 <span class="markdown-them-math-inline">$e$</span> 大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不然 <span class="markdown-them-math-inline">$T+e-f$</span> 就是一棵比 <span class="markdown-them-math-inline">$T$</span> 还优的生成树了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>所以<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> <span class="markdown-them-math-inline">$T+e-f$</span> 包含了 <span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且也是一棵最小生成树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>归纳成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(m\log m)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="kruskal-重构树">Kruskal 重构树</h3><p>这是 Kruskal 算法除了求最小生成树以外的一个重要应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>在使用 <span class="markdown-them-math-inline">$\rm kruskal$</span> 最小生成树算法的时候会从小到大加入 <span class="markdown-them-math-inline">$n-1$</span> 条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在仍按照这个顺序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次加入一条边时将其变成一个点权等于边权的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后把它作为所连接两个连通块的父亲节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>不难发现两个结点在 MST 上的最短路径上的边权最大值为它们在 <span class="markdown-them-math-inline">$\rm kruskal$</span> 重构树上 <span class="markdown-them-math-inline">$\rm LCA$</span> 的点权<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且从一个点 <span class="markdown-them-math-inline">$u$</span> 出发只经过边权小于某值的边能够到达的点集为 <span class="markdown-them-math-inline">$\rm Kruskal$</span> 重构树上某点的子树内所有的叶子结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="prim">Prim</h2><p>在稠密图上复杂度最优的最小生成树算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>与 Dijkstra 算法类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择一个点作为起点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次选择到<strong>当前已选的点集中任意一个点</strong>距离最短的未选择的点并向其连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再递归操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><blockquote><p>证明: 还是说明在每一步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都存在一棵最小生成树包含已选边集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>基础: 只有一个结点的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>归纳: 如果某一步成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前边集为 <span class="markdown-them-math-inline">$F$</span>, 属于 <span class="markdown-them-math-inline">$T$</span> 这棵 MST<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>接下来要加入边 <span class="markdown-them-math-inline">$e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>如果 <span class="markdown-them-math-inline">$e$</span> 属于 <span class="markdown-them-math-inline">$T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>否则考虑 <span class="markdown-them-math-inline">$T+e$</span> 中环上另一条可以加入当前边集的边 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f$</span> 的权值一定不小于 <span class="markdown-them-math-inline">$e$</span> 的权值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则就会选择 <span class="markdown-them-math-inline">$f$</span> 而不是 <span class="markdown-them-math-inline">$e$</span> 了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>然后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f$</span> 的权值一定不大于 <span class="markdown-them-math-inline">$e$</span> 的权值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则 <span class="markdown-them-math-inline">$T+e-f$</span> 就是一棵更小的生成树了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>因此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$e$</span> 和 <span class="markdown-them-math-inline">$f$</span> 的权值相等, <span class="markdown-them-math-inline">$T+e-f$</span> 也是一棵最小生成树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且包含了 <span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta[(n+m)\log n]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="boruvka">Boruvka</h2><p>在大多数完全图上求最小生成树所使用的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li><p>每次遍历所有的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求出它当前属于哪个连通块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>遍历所有的边 <span class="markdown-them-math-inline">$u-v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$v$</span> 不在同一个连通块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就分别用 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$v$</span> 去更新它们所在连通块的最小出边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>将每个连通块的最小出边加入 MST 的边集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>由于每次连通块数量减半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以时间复杂度 <span class="markdown-them-math-inline">$\Theta(m\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「图论」差分约束</title>
      <link href="/2023/06/24/tu-lun-chai-fen-yue-shu/"/>
      <url>/2023/06/24/tu-lun-chai-fen-yue-shu/</url>
      
        <content type="html"><![CDATA[<p>差分约束学习笔记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><p>差分约束是用来解形如 <span class="markdown-them-math-inline">$x_1-x_2\leqslant k$</span> 的若干个方程的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现可以将方程移项成 <span class="markdown-them-math-inline">$x_1\leqslant x_2+k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解方程的时候考虑建图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从 <span class="markdown-them-math-inline">$x_2$</span> 向 <span class="markdown-them-math-inline">$x_1$</span> 连一条长度为 <span class="markdown-them-math-inline">$k$</span> 的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后对这张图建一个超级源点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>向所有点连一条长度为 <span class="markdown-them-math-inline">$0$</span> 的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后跑最短/最长路得出的 <span class="markdown-them-math-inline">$dis$</span> 就是每个变量的一个取值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>为什么这样做是对的呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>因为如果有一条 <span class="markdown-them-math-inline">$u$</span> 到 <span class="markdown-them-math-inline">$v$</span> 的长度为 <span class="markdown-them-math-inline">$w$</span> 的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么跑完最短路以后 <span class="markdown-them-math-inline">$dis_v$</span> 一定不大于 <span class="markdown-them-math-inline">$dis_u + w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>恰好满足一个方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么将所有边连上以后再跑最短路就可以满足所有方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最长路同理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果有负环则无解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(\rm SPFA)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最短路求的是以起始点为基准的最大解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而最长路求的是以起始点为基准的最小解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「图论」Prufer 序列</title>
      <link href="/2023/06/24/tu-lun-prufer-xu-lie/"/>
      <url>/2023/06/24/tu-lun-prufer-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了 Prufer 序列及其应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="prufer-序列的定义">Prufer 序列的定义</h2><p><span class="markdown-them-math-inline">$\rm Prufer$</span> 序列可以将一颗结点数为 <span class="markdown-them-math-inline">$n$</span> 的有标号无根树用一个长度为 <span class="markdown-them-math-inline">$n-2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>值域为 <span class="markdown-them-math-inline">$[1,n]$</span> 的数列唯一表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即有标号无根树和 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列呈双射关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有标号无根树的构建方式如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>选择一个编号最小的叶子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将其删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>将这个叶子节点所连接的点的编号加入 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>重复以上步骤 <span class="markdown-them-math-inline">$n-2$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到树上只剩下 <span class="markdown-them-math-inline">$2$</span> 个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>这是某一颗点数为 <span class="markdown-them-math-inline">$n$</span> 的有标号无根树的 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列的构造过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><img src="https://oiwiki.org/graph/images/prufer1.png" alt="Prufer"></p><h2 id="快速求解-prufer 序列">快速求解 Prufer 序列</h2><p>由其过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有一个使用堆优化的 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span> 做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列其实可以线性构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>记录所有点的度数和一个指针 <span class="markdown-them-math-inline">$p$</span> 指向编号最小的叶子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进行以下操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>将 <span class="markdown-them-math-inline">$p$</span> 指向的结点删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>检查是否出现了新的叶结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>如果产生了新的叶结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记其编号为 <span class="markdown-them-math-inline">$x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 若 <span class="markdown-them-math-inline">$x&gt;p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则不做任何操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则将其删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并检查删除 <span class="markdown-them-math-inline">$x$</span> 以后是否出现了新的叶结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重复这一步操作直到没有产生新的叶结点或新产生的结点编号大于 <span class="markdown-them-math-inline">$p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>让 <span class="markdown-them-math-inline">$p$</span> 自增直到遇见下一个叶结点为止<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>重复以上操作直到结点数为 <span class="markdown-them-math-inline">$2$</span> 可以得到这棵树的 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在算法流程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每条边只在其连接的外层结点被删除时被遍历过一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且 <span class="markdown-them-math-inline">$p$</span> 单调递增<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>树中的节点数单调递减<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以每个点也只被遍历过一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="快速还原-prufer 序列">快速还原 Prufer 序列</h2><p>显然还是有一个堆优化的 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span> 做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>从前到后枚举 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列中的每一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护不在序列中的结点编号的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然不在序列中的是叶子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且其最小值为最后一个加入的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是将其与当前枚举的序列中的数连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>连边后若序列中已没有枚举的这个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么将其踢出序列作为新的叶子结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑以与之前构造 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列相同的方法构造线性做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>记一个指针 <span class="markdown-them-math-inline">$p$</span> 指向不在序列中的最小结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果将其连向序列中枚举的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将枚举的位置删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>序列中没有这个结点了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么如果被删除的结点比 <span class="markdown-them-math-inline">$p$</span> 小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接将其与现在序列中枚举的数连边后将其删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重复操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果这个结点的值大于 <span class="markdown-them-math-inline">$p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么不用管它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在后面它一定会被枚举到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种算法的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="prufer-序列的应用">Prufer 序列的应用</h2><h3 id="cayley-公式">Cayley 公式</h3><blockquote><p>完全图 <span class="markdown-them-math-inline">$K_n$</span> 有 <span class="markdown-them-math-inline">$n^{n-2}$</span> 颗生成树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>证明方法很多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中最简单的应该是利用 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑到任何一个长度为 <span class="markdown-them-math-inline">$n-2$</span> 的 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列唯一对应一颗大小为 <span class="markdown-them-math-inline">$n$</span> 的有标号无根树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑计算长度为 <span class="markdown-them-math-inline">$n-2$</span> 的 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>又因为其值域为 <span class="markdown-them-math-inline">$[1,n]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故总方案数为 <span class="markdown-them-math-inline">$n^{n-2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="限定度数的有标号无根树计数">限定度数的有标号无根树计数</h3><p>求有 <span class="markdown-them-math-inline">$n$</span> 个结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且第 <span class="markdown-them-math-inline">$i$</span> 个结点的度数为 <span class="markdown-them-math-inline">$d_i$</span> 的有标号无根树的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑到一个点的度数为其在 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列中出现次数 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是对于一个度数为 <span class="markdown-them-math-inline">$d_i$</span> 的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其在 <span class="markdown-them-math-inline">$\rm Prufer$</span> 序列中的出现次数应为 <span class="markdown-them-math-inline">$d_i-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故存在这样的有标号无根树当且仅当 <span class="markdown-them-math-inline">$\sum_{i=1}^n d_i-1=n-2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且这样的树的数量为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\dbinom{n-2}{d_1-1,d_2-1,\cdots ,d_n-1}=\frac{(n-2)!}{(d_1-1)!(d_2-1)!\cdots (d_n-1)!}$$</div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「图论」2-SAT 学习笔记</title>
      <link href="/2023/06/24/tu-lun-2-sat/"/>
      <url>/2023/06/24/tu-lun-2-sat/</url>
      
        <content type="html"><![CDATA[<p>2-SAT 学习笔记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="求解-2-sat 问题">求解 2-SAT 问题</h2><p><span class="markdown-them-math-inline">$2-\rm Sat$</span> 问题是求解某个 <span class="markdown-them-math-inline">$\rm bool$</span> 方程组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方程组中的每个方程被描述为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$x_i$</span> 为真<span class="markdown-them-math-inline">$/$</span>假 或 <span class="markdown-them-math-inline">$x_j$</span> 为真<span class="markdown-them-math-inline">$/$</span>假<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们可以对每个 <span class="markdown-them-math-inline">$x_i$</span> 和 <span class="markdown-them-math-inline">$\lnot x_i$</span> 分别建点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$x_i$</span> 为假看作 <span class="markdown-them-math-inline">$\lnot x_i$</span> 为真<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样方程就仅有一种类型了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即若 <span class="markdown-them-math-inline">$p$</span> 为真则 <span class="markdown-them-math-inline">$q$</span> 为真<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建一些边 <span class="markdown-them-math-inline">$u\to v$</span> 表示当 <span class="markdown-them-math-inline">$u$</span> 为真的时候 <span class="markdown-them-math-inline">$v$</span> 一定为真<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如有方程 <span class="markdown-them-math-inline">$p$</span> 为真或 <span class="markdown-them-math-inline">$q$</span> 为真时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建两条边 <span class="markdown-them-math-inline">$p\to \lnot q$</span> 和 <span class="markdown-them-math-inline">$q\to \lnot {p}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>建完图后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然同一个强连通分量中的点取值必然相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么如果 <span class="markdown-them-math-inline">$a$</span> 和 <span class="markdown-them-math-inline">$\lnot a$</span> 在同一个强连通分量里则该 <span class="markdown-them-math-inline">$\rm bool$</span> 方程组无解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>易知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存在 <span class="markdown-them-math-inline">$a$</span> 和 <span class="markdown-them-math-inline">$\lnot a$</span> 在同一个强连通分量中为该 <span class="markdown-them-math-inline">$\rm bool$</span> 方程组无解的充要条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对于其它的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每对 <span class="markdown-them-math-inline">$a$</span> 和 <span class="markdown-them-math-inline">$\lnot a$</span> 中有且仅有一个为真<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们令拓扑序大的那个为真<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以分情况证明其最优性 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>若 <span class="markdown-them-math-inline">$a$</span> 和 <span class="markdown-them-math-inline">$\lnot a$</span> 在 <span class="markdown-them-math-inline">$\rm DAG$</span> 的同一条链上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么拓扑序大的必然为真<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则两个都为真与题意相悖<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>若 <span class="markdown-them-math-inline">$a$</span> 和 <span class="markdown-them-math-inline">$\lnot a$</span> 在不同链上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么两个点的取值其实无所谓<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但一定要跟拓扑序相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为每条链上拓扑序的大小关系时严格的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用拓扑序规定某个点取值是否为真可以使为真的点在同一条链上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尽可能降低对其他点的影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了保证跟上一种情况的统一性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仍选择令拓扑序大的点为真<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>另一方面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现 <span class="markdown-them-math-inline">$\rm Tarjan$</span> 缩点所求出的 <span class="markdown-them-math-inline">$\rm SCC$</span> 强连通分量数组的值负相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以理解为拓扑序更小的点更后入栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也更先出栈编号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>故最后对比 <span class="markdown-them-math-inline">$a$</span> 和 <span class="markdown-them-math-inline">$\lnot a$</span> 的 <span class="markdown-them-math-inline">$\rm SCC$</span> 值即可判断它们谁为真谁为假<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="经典例题">经典例题</h2><h3 id="[lg6378]-riddle">[LG6378] Riddle</h3><p>对树上每个点建立一个 <span class="markdown-them-math-inline">$\rm bool$</span> 变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取值为 <span class="markdown-them-math-inline">$1$</span> 表示这个点选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>使用 <span class="markdown-them-math-inline">$\rm 2-Sat$</span> 的通用做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建立为每个点的状态建立两个点 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$\lnot u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别对每个限制考虑 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>每条边至少有一个关键点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则对于一条边 <span class="markdown-them-math-inline">$u-v$</span> 若 <span class="markdown-them-math-inline">$\lnot u$</span> 则 <span class="markdown-them-math-inline">$v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\lnot v$</span> 则 <span class="markdown-them-math-inline">$u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故连接 <span class="markdown-them-math-inline">$\lnot u\to v$</span> 和 <span class="markdown-them-math-inline">$\lnot v\to u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>每个部分最多有一个关键点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则如果 <span class="markdown-them-math-inline">$u$</span> 被选了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么同一个块中所有点都不能选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>连接 <span class="markdown-them-math-inline">$u\to \lnot v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 但是我们发现这样连边是 <span class="markdown-them-math-inline">$\Theta(n^2)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以前缀和优化连边即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>建好图以后直接跑 <span class="markdown-them-math-inline">$\rm 2-Sat$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[poi2011]-kon-conspiracy">[POI2011] KON-Conspiracy</h3><p>首先转化题意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这道题要求的是将一张无向图划分成一个团和一个独立集的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先找出一种合法的方案是很容易的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是一个裸的 <span class="markdown-them-math-inline">$\rm 2-Sat$</span> 问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑找出一种方案后统计方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先有如下性质 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><ul><li>一个团中不可能取出一个以上的点加入独立集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为两点之间必有连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>一个独立集中不可能取出一个以上的点加入团<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为两点之间必无连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul></blockquote><p>所以可以直接分别枚举团和独立集中的每个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>交换它们即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\rm \Theta(n^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[北京省选集训-2019] 完美塔防">[北京省选集训 2019] 完美塔防</h3><p>首先预处理哪些炮台会互相打到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则输出 <code>IMPOSSIBLE</code>.</p><p>然后发现有如下结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><p>每个空地最多可以被两个炮台打到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>因为每个空地最多在纵横两个方向上被打到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若还存在一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则必定会打到其中一个炮台<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>于是对每个炮台<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的纵横情况设为 <span class="markdown-them-math-inline">$0/1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个空地会加入一个形如 <span class="markdown-them-math-inline">$a~or~b$</span> 的条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就变成了经典的 <span class="markdown-them-math-inline">$\rm 2-Sat$</span> 问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(Tn^3)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="[hnoi2010]-平面图判定">[HNOI2010] 平面图判定</h3><p>首先有平面图中的欧拉定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设一张无向连通图点数为 <span class="markdown-them-math-inline">$v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边数为 <span class="markdown-them-math-inline">$e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>面数为 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$v-e+f=2$$</div><p>考虑通过对 <span class="markdown-them-math-inline">$e$</span> 进行归纳证明该式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当 <span class="markdown-them-math-inline">$e=0$</span> 时显然成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>若当 <span class="markdown-them-math-inline">$e'=e-1$</span> 时该式成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们要证 <span class="markdown-them-math-inline">$v-e+f=1$</span> 成立只需证添加一条边会使得面数恰好增加 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 而对于这个问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以分类讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若这条边加在某个面的中间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么其必将这个面分成两半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若这条边加在图形外面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么会围出一块新的区域<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也会使面数恰好增加 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>故该式成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们进一步探究平面图的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>定义面的度数为与其相邻的面的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然对于每条边都会有恰好两个面与其相邻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故所有面的度数之和为 <span class="markdown-them-math-inline">$2e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 又因为每个面至少三条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以度数不小于 <span class="markdown-them-math-inline">$3$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而有 <span class="markdown-them-math-inline">$3f$</span> 不大于所有面的度数之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故有 <span class="markdown-them-math-inline">$3f\leqslant 2e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将其带入平面图中的欧拉定理可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$e\leqslant 3v-6$$</div><p>于是不满足该式的无向连通图均不为平面图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而可以将 <span class="markdown-them-math-inline">$m$</span> 限制到与 <span class="markdown-them-math-inline">$n$</span> 同数量级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现题目给定了哈密顿回路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑以这个环作为中心考虑问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我么发现对于任意一条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它要么从环内连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么从环外连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且如果有两条边 <span class="markdown-them-math-inline">$u-v$</span> 和 <span class="markdown-them-math-inline">$u'-v'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且满足 <span class="markdown-them-math-inline">$u&lt;u'&lt;v&lt;v'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么它们不能连在同一面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是可以通过这种关系构建 <span class="markdown-them-math-inline">$\rm 2-Sat$</span> 模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(Tn)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「动态规划」决策单调性</title>
      <link href="/2023/06/24/dong-tai-gui-hua-jue-ce-dan-diao-xing/"/>
      <url>/2023/06/24/dong-tai-gui-hua-jue-ce-dan-diao-xing/</url>
      
        <content type="html"><![CDATA[<p>记录了一些有趣的满足决策单调性情况下的 <span class="markdown-them-math-inline">$\rm DP$</span> 转移技巧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="四边形不等式优化">四边形不等式优化</h2><h3 id="定义">定义</h3><p>假设有 <span class="markdown-them-math-inline">$p_1\leqslant p_2\leqslant p_3\leqslant p_4.$</span></p><p>则 <span class="markdown-them-math-inline">$c_{p_1,p_3}+c_{p_2,p_4}\leqslant c_{p_1,p_4}+c_{p_2,p_3}$</span> 被称为四边形不等式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>假设一个问题满足四边形不等式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么它的决策点有单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>Proof:</strong></p><p>假设有如下问题 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>现在有一个序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们要将其分割开来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分割一段 <span class="markdown-them-math-inline">$[l,r]$</span> 的代价是 <span class="markdown-them-math-inline">$c_{l,r}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求最小代价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$F_i$</span> 表示将前 <span class="markdown-them-math-inline">$i$</span> 个位置分割完毕的最小代价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有暴力转移 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F_i=\min\limits_{j&lt;i}\{F_j+c_{j,i}\}$$</div><p>设 <span class="markdown-them-math-inline">$F_i$</span> 的决策点为 <span class="markdown-them-math-inline">$p_i.$</span> 假设存在 <span class="markdown-them-math-inline">$x&gt;y,p_x&lt;p_y.$</span></p><p>根据最优决策的定义写出这个位置的转移式 :</p><div class="markdown-them-math-block">$$F_x=F_{p_x}+c_{p_x,x}\leqslant F_{p_y}+c_{p_y, x}$$</div><p>有 <span class="markdown-them-math-inline">$p_x&lt;p_y&lt;y&lt;x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据四边形不等式得到 :</p><div class="markdown-them-math-block">$$c_{p_x,y}+c_{p_y,x}\leqslant c_{p_y,y}+c_{p_x,x}$$</div><p>两不等式相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 :</p><div class="markdown-them-math-block">$$F_{p_x}+c_{p_x,y}\leqslant F_{p_y}+c_{p_y,y}$$</div><p>与前文矛盾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故不存在 <span class="markdown-them-math-inline">$x&gt;y,p_x&lt;p_y$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即满足决策单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只有最小化问题才能通过四边形不等式判定决策单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="区间形式">区间形式</h3><p>在实际做题中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们经常遇到这样的 <span class="markdown-them-math-inline">$\rm DP$</span> 方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$dp_{i,j}=\min\limits_{i\leqslant k&lt;j}\{dp_{i,k}+dp_{k+1,j}+w_{i,j}\}$$</div><p>我们考虑将四边形不等式推广到二维形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>定理 <span class="markdown-them-math-inline">$1$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$w$</span> 满足四边形不等式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且对于任意 <span class="markdown-them-math-inline">$a\leqslant b\leqslant b\leqslant c\leqslant d$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$w_{a,d}\geqslant w_{b,c}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$f$</span> 也满足四边形不等式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>定理 <span class="markdown-them-math-inline">$2$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$p_{i,j}$</span> 表示 <span class="markdown-them-math-inline">$f_{i,j}$</span> 的决策点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$f$</span> 满足四边形不等式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则对于任意 <span class="markdown-them-math-inline">$i&lt;j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$p_{i,j-1}\leqslant p_{i,j}\leqslant p_{i+1,j}.$</span></p><p>例题 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://www.luogu.com.cn/problem/P1880"><span class="markdown-them-math-inline">$\rm [NOI1995] 石子合并$</span></a></p><hr><h2 id="转移技巧">转移技巧</h2><h3 id="有单峰性">有单峰性</h3><p>这个性质结合决策单调性有均摊转移复杂度 <span class="markdown-them-math-inline">$\Theta(1)$</span> 的做法 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>记录一个指针表示当前的决策点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于决策单调性所以它不会往回跳<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>进入每一层之后如果后面的决策点更优就跳到后面的决策点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据单峰性这样一定不会漏掉解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>跳的次数是状态级别的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故转移均摊 <span class="markdown-them-math-inline">$\Theta(1).$</span></p><h3 id="仅有相邻层之间转移">仅有相邻层之间转移</h3><p>这是一类特殊的二维 <span class="markdown-them-math-inline">$\rm DP$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仅有相邻层之间的转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有同层之间的转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时满足决策单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>一般这种 <span class="markdown-them-math-inline">$\rm DP$</span> 的时间复杂度是 <span class="markdown-them-math-inline">$\Theta(n^3)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次转移需要枚举前一层的所有点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现一个性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在同一层中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先枚举哪一个是无关紧要的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为同一层之间不会发生转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是可以考虑分治<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先转移 <span class="markdown-them-math-inline">$mid$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到其最优决策为 <span class="markdown-them-math-inline">$p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后就可以将区间划分开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$[l,mid)$</span> 和 <span class="markdown-them-math-inline">$(mid,r]$</span> 分别对应 <span class="markdown-them-math-inline">$[tl,p]$</span> 和 <span class="markdown-them-math-inline">$[p,tr].$</span></p><p>这样分治时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n).$</span></p><p>例题 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://www.luogu.com.cn/problem/P4072"><span class="markdown-them-math-inline">$\rm [SDOI2016]征途$</span></a></p><h3 id="贡献难算">贡献难算</h3><p>首先有例题 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>存在一个长度为 <span class="markdown-them-math-inline">$n$</span> 的序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要将它划分成 <span class="markdown-them-math-inline">$k$</span> 段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每段的价值被定义为不同的元素个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求最大化贡价值和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>数据范围<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$n\leqslant 3.5\times 10^4,k\leqslant 50.$</span></p><p>首先有一个 <span class="markdown-them-math-inline">$\Theta(n^3k)$</span> 的暴力 <span class="markdown-them-math-inline">$\rm DP$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$dp_{i,j}$</span> 表示当分到 <span class="markdown-them-math-inline">$i$</span> 时已经分了 <span class="markdown-them-math-inline">$j$</span> 段的最大价值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有转移式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$dp_{i,j}=\max\limits_{k&lt;i}\{dp_{k,j-1}+cnt_{k+1,i}\}$$</div><p>其中 <span class="markdown-them-math-inline">$cnt_{l,r}$</span> 表示从 <span class="markdown-them-math-inline">$[l,r]$</span> 中不同颜色的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单次计算需要 <span class="markdown-them-math-inline">$\Theta(n).$</span></p><p>我们发现只在相邻层之间发生转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且满足决策单调性<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>直观理解就是分得越多越容易亏<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是可以使用之前提到的分治法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这样看起来是优化到 <span class="markdown-them-math-inline">$\Theta(n^2k\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我们考虑计算贡献的具体过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们每次只会计算 <span class="markdown-them-math-inline">$dp_{mid}$</span> 的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次询问一个区间 <span class="markdown-them-math-inline">$[i,mid]$</span> 的不同元素个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以考虑固定右端点移动左端点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现移动次数是当前的分治区间长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是总移动次数不会超过 <span class="markdown-them-math-inline">$n\log n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故时间复杂度实际上为 <span class="markdown-them-math-inline">$\Theta(nk\log n).$</span></p><p>例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://www.luogu.com.cn/problem/P5574"><span class="markdown-them-math-inline">$\rm [P5574]任务分配问题$</span></a></p><hr><h2 id="常用算法">常用算法</h2><h3 id="斜率优化">斜率优化</h3><p>假设 <span class="markdown-them-math-inline">$\rm DP$</span> 方程长成这种形式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$dp_i=\max\limits_{j&lt;i}\{dp_j+(i)'+(i)(j)+(j)'+C\}$$</div><p>即贡献为一个仅与 <span class="markdown-them-math-inline">$i$</span> 有关的式子加上一个仅与 <span class="markdown-them-math-inline">$j$</span> 有关的式子加上一个与两者都有关的乘积形式再加上一个常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么可以使用斜率优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现 <span class="markdown-them-math-inline">$dp_i,(i)',C$</span> 都与决策点的选择无关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是可以把它们看作常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将仅与 <span class="markdown-them-math-inline">$j$</span> 有关的式子放在一边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以得到方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$dp_j+(j)'=-(i)(j)+dp_i-(i)'-C$$</div><p>我们发现这是一次函数的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑构造平面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>平面上有一些点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>形如 <span class="markdown-them-math-inline">$((j),dp_j+(j)').$</span> 我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果用一条斜率为 <span class="markdown-them-math-inline">$-(i)$</span> 的直线经过某个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么截距为 <span class="markdown-them-math-inline">$dp_i-(i)'-C.$</span> 由于我们要最大化 <span class="markdown-them-math-inline">$dp_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等价于最大化这个截距<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以用这根斜率为 <span class="markdown-them-math-inline">$-(i)$</span> 的直线从上到下平移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第一个碰到的点就是决策点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是现在问题就变成了维护一个凸包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现有三种情况 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>当加入点按照横坐标单调递增的顺序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且询问点单调递增时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以直接维护单调队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>加入点对比队尾斜率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取答案从队首即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>当加入点按照横坐标单调的顺序时可以维护一个单调队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次加入时对比斜率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取答案二分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>当加入点无序时直接用平衡树 <code>(std :: set)</code> 维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用 <code>lower_bound</code> 查找插入点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后向左右两边依次弹出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取答案也使用 <code>lower_bound</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>例题 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://www.luogu.com.cn/problem/P4072"><span class="markdown-them-math-inline">$\rm [SDOI2016]征途$</span></a></p><h3 id="二分队列">二分队列</h3><p>若 <span class="markdown-them-math-inline">$\rm DP$</span> 方程形如 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$dp_i=\min\limits_{j&lt;i}\{dp_j+w_{j+1,i}\}$$</div><p>根据决策单调性的推论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任何两个点 <span class="markdown-them-math-inline">$i,j(i&lt;j)$</span> 之间都存在一个点 <span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$k$</span> 之前一段转移点为 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$k$</span> 之后某一段转移点为 <span class="markdown-them-math-inline">$j.$</span></p><p>我们发现如果能快速计算 <span class="markdown-them-math-inline">$w_{i,j}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就能 <span class="markdown-them-math-inline">$\Theta(\log n)$</span> 计算两个点 <span class="markdown-them-math-inline">$i,j$</span> 之间的决策分界点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现所有相邻决策点的分界点可以用单调队列维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体来说 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><p>求当前的最优决策时判断一下队首和队次首谁更优<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若队首最优则决策点为队首<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则决策点为队次首<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且将当前队首弹出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>加入一个点时判断它是否能比队尾更快地替换掉队次尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则弹出队尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重复操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>这样就可以快速地维护相邻点的决策分界点了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n).$</span></p><p>例题 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://www.luogu.com.cn/problem/P1912"><span class="markdown-them-math-inline">$\rm [NOI2009]诗人小G$</span></a></p><h3 id="二分栈">二分栈</h3><p>有些题可能会有这样的奇怪性质 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每个决策点只会被自己前面的点反超<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们发现某个决策点会经历这样的过程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一开始就比前面的优<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>否则就相当于一开始就被别人反超了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后在最优决策的地方呆一会儿<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后被某个点反超<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>严格来说这根本不算决策单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是仍然可以用二分栈来维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为两点的优劣仍旧可以 <span class="markdown-them-math-inline">$\Theta(\log n)$</span> 对比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>加入一个点时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若其比堆顶劣<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则直接扔掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若其比堆顶优<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则留下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>每一轮判断一下堆次顶是否比堆顶优<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>优则将堆顶弹出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>这样堆顶就一直是当前转移的决策点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>例题 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>[<span class="markdown-them-math-inline">$\rm [POI2011]Lightning Conductor$</span></p><hr><h2 id="习题">习题</h2><h3 id="[noi1995]-石子合并">[NOI1995] 石子合并</h3><p>首先有暴力转移 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$dp_{l,r}=\min\limits_{i\leqslant k&lt;j}\{dp_{i,k}+dp_{k+1,j}+w_{i,j}\}$$</div><p>记录前缀和 <span class="markdown-them-math-inline">$sum$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里 <span class="markdown-them-math-inline">$w_{i,j}=sum_j-sum_{i-1}.$</span></p><p><span class="markdown-them-math-inline">$w$</span> 显然满足四边形不等式和包含单调<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑四边形不等式优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后就直接设 <span class="markdown-them-math-inline">$p_{i,j}$</span> 表示 <span class="markdown-them-math-inline">$dp_{i,j}$</span> 的转移点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>成功转移的时候更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举 <span class="markdown-them-math-inline">$dp_{i,j}$</span> 断点的时候只需要枚举 <span class="markdown-them-math-inline">$[p_{i,j-1},p_{i+1,j}]$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n^2).$</span></p><h3 id="[sdoi2016]征途">[SDOI2016]征途</h3><p>首先易知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设每一天走的长度为 <span class="markdown-them-math-inline">$d$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则答案为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$m\sum_{i=1}^m(d_i-ave)^2=m\sum_{i=1}^md_i^2-\left(\sum_{i=1}^md_i\right)^2$$</div><p>容易观察到此题本质上是在求 <span class="markdown-them-math-inline">$\left(\sum_{i=1}^md_i\right)^2_{\min}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是设 <span class="markdown-them-math-inline">$f_{i,j}$</span> 表示当前已经考虑到第 <span class="markdown-them-math-inline">$i$</span> 段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前已经分成了 <span class="markdown-them-math-inline">$j$</span> 段的最小 <span class="markdown-them-math-inline">$\sum_{p=1}^jd_p.$</span> 枚举转移点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易得到转移方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i,j}=\min\limits_{k&lt;i}\{f_{k,j-1}+(s_i-s_k)^2\}$$</div><p>易证 <span class="markdown-them-math-inline">$w_{i,j}=(s_j-s_i)^2$</span> 满足四边形不等式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以该转移方程满足决策单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们还发现转移方程只在相邻层之间转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以使用分治转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n^2\log n).$</span></p><p>还有斜率优化的做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意到转移方程是可以变形的 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i,j}=f_{k,j-1}+(s_i-s_k)^2$$</div><div class="markdown-them-math-block">$$\iff f_{i,j}=f_{k,j-1}+s_i^2-2s_is_k+s_k^2$$</div><div class="markdown-them-math-block">$$\iff f_{k,j-1}+s_k^2=2s_i\cdot s_k+f_{i,j}-s_i^2$$</div><p>易知插入点横坐标有序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>询问斜率也有序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以直接使用单调队列维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每一层分开转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n^2).$</span></p><h3 id="[p5574]任务分配问题">[P5574]任务分配问题</h3><p>非常套路的分治 <span class="markdown-them-math-inline">$+$</span> 决策单调性优化 <span class="markdown-them-math-inline">$\rm DP.$</span></p><p>首先定义 <span class="markdown-them-math-inline">$w_{i,j}$</span> 表示 <span class="markdown-them-math-inline">$i\sim j$</span> 的顺序对个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$f_{i,j}$</span> 表示当前已经考虑到第 <span class="markdown-them-math-inline">$i$</span> 个任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将他们分成 <span class="markdown-them-math-inline">$j$</span> 段的最小顺序对数量之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>易得转移方程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i,j}=\min\limits_{k&lt;i}\{f_{k,j-1}+w_{k+1,i}\}$$</div><p>对于任意 <span class="markdown-them-math-inline">$a\leqslant b\leqslant c\leqslant d$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用容斥易证 <span class="markdown-them-math-inline">$w_{a,c}+w_{b,d}-w_{b,c}\leqslant w_{a,d}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$w$</span> 满足四边形不不等式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>进一步的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f$</span> 的转移满足决策单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有了决策单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以分治转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时令人惊喜的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移时需要遍历一段连续的区间并计算每一个位置的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是用莫队和 <span class="markdown-them-math-inline">$\rm BIT$</span> 维护一下就好了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(nk\log^2n).$</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」常见函数图像</title>
      <link href="/2023/06/24/shu-xue-chang-jian-han-shu-tu-xiang/"/>
      <url>/2023/06/24/shu-xue-chang-jian-han-shu-tu-xiang/</url>
      
        <content type="html"><![CDATA[<p>注意需要从定义域<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>奇偶性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特殊点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>趋势等方面分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="$y-= xe ^ x$"><span class="markdown-them-math-inline">$y = xe ^ x$</span></h2><img src = "https://s1.ax1x.com/2022/05/16/Ofx8qU.png" width="bottom" height="300" align="bottom" /><p>首先容易知道 <span class="markdown-them-math-inline">$y = xe ^ x$</span> 的定义域为 <span class="markdown-them-math-inline">$\mathbb{R}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后考虑对其求导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="markdown-them-math-inline">$y' = e ^ x(x + 1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现 <span class="markdown-them-math-inline">$e ^ x$</span> 恒大于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$x + 1$</span> 在 <span class="markdown-them-math-inline">$x$</span> 小于 <span class="markdown-them-math-inline">$-1$</span> 时小于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$x$</span> 不小于 <span class="markdown-them-math-inline">$-1$</span> 时不小于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是我们可以初步以 <span class="markdown-them-math-inline">$(1, -\frac{1}{e})$</span> 作为分界点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>继续分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li><p>当 <span class="markdown-them-math-inline">$x &lt; -1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现 <span class="markdown-them-math-inline">$e ^ x$</span> 变小得越来越慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且导数为负<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以函数从 <span class="markdown-them-math-inline">$(1, -\frac{1}{e})$</span> 开始向左以 <span class="markdown-them-math-inline">$x$</span> 轴为渐近线递增<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>当 <span class="markdown-them-math-inline">$x &gt; -1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现 <span class="markdown-them-math-inline">$e ^ x$</span> 增长得很快<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与 <span class="markdown-them-math-inline">$x + 1$</span> 完全不是一个量级的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是函数图像主要由 <span class="markdown-them-math-inline">$e ^ x$</span> 产生影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>画出的图像与指数函数类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要稍微陡一点点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li></ul><p>另外一个需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>函数过点 <span class="markdown-them-math-inline">$(0, 0)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="$y-= \frac{e ^ x}{x}$"><span class="markdown-them-math-inline">$y = \frac{e ^ x}{x}$</span></h2><img src = "https://s1.ax1x.com/2022/05/16/Ohp5sx.png" width="bottom" height="400" align="bottom" /><p>首先容易知道 <span class="markdown-them-math-inline">$y = \frac{e ^ x}{x}$</span> 的定义域为 <span class="markdown-them-math-inline">$\mathbb{R}\backslash\{0\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后考虑对其求导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="markdown-them-math-inline">$y' = \frac{e ^ x(x - 1)}{x ^ 2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现需要以 <span class="markdown-them-math-inline">$x = 0, 1$</span> 作为分界点进行分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>当 <span class="markdown-them-math-inline">$x &lt; 0$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在靠左边的地方 <span class="markdown-them-math-inline">$e ^ x$</span> 的影响非常大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是往左的函数图像与 <span class="markdown-them-math-inline">$y = xe ^ x$</span> 类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是在接近 <span class="markdown-them-math-inline">$x = 0$</span> 的地方 <span class="markdown-them-math-inline">$e ^ x$</span> 的影响较小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下部分的结构与 <span class="markdown-them-math-inline">$\frac{1}{x}$</span> 类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是函数图像也是类似的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>当 <span class="markdown-them-math-inline">$0 &lt; x &lt; 1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在接近 <span class="markdown-them-math-inline">$x = 0$</span> 的地方 <span class="markdown-them-math-inline">$e ^ x$</span> 的影响较小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下部分的结构与 <span class="markdown-them-math-inline">$\frac{1}{x}$</span> 类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是函数图像也是类似的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>当 <span class="markdown-them-math-inline">$x &gt; 1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> <span class="markdown-them-math-inline">$e ^ x$</span> 的影响逐渐变大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是函数图像类似于指数函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要稍微缓一点点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><h2 id="$y-= \frac{x}{e ^ x}$"><span class="markdown-them-math-inline">$y = \frac{x}{e ^ x}$</span></h2><img src = "https://s1.ax1x.com/2022/05/16/OhPeaT.png" width="bottom" height="330" align="bottom" /><p>首先容易知道 <span class="markdown-them-math-inline">$y = \frac{x}{e ^ x}$</span> 的定义域为 <span class="markdown-them-math-inline">$\mathbb{R}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后考虑对其求导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="markdown-them-math-inline">$y' = \frac{1 - x}{e ^ x}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现需要以 <span class="markdown-them-math-inline">$x = 1$</span> 作为分界点进行分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>分析过程与 <span class="markdown-them-math-inline">$y = xe ^ x$</span> 类似<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>所以图像也是类似的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此处不做赘述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="$y-= x \ln x$"><span class="markdown-them-math-inline">$y = x \ln x$</span></h2><img src = "https://s1.ax1x.com/2022/05/16/OhiQk8.png" width="bottom" height="330" align="bottom" /><p>首先容易知道 <span class="markdown-them-math-inline">$y = x \ln x$</span> 的定义域为 <span class="markdown-them-math-inline">$\mathbb{R}^+$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后对其求导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="markdown-them-math-inline">$y' = \ln x + 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现从 <span class="markdown-them-math-inline">$x = 0$</span> 开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$y'$</span> 从 <span class="markdown-them-math-inline">$- \infty$</span> 开始快速增大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$\frac{1}{e}$</span> 处取到 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后继续缓慢增大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是 <span class="markdown-them-math-inline">$y$</span> 一开始快速下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$(\frac{1}{e}, -\frac{1}{e})$</span> 处取到最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后加速上升<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>加速度略大于 <span class="markdown-them-math-inline">$y = x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>远小于 <span class="markdown-them-math-inline">$y = x ^ 2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="$y-= \frac{\ln x}{x}$"><span class="markdown-them-math-inline">$y = \frac{\ln x}{x}$</span></h2><img src = "https://s1.ax1x.com/2022/05/16/OhAa7t.png" width="bottom" height="350" align="bottom" /><p>容易知道 <span class="markdown-them-math-inline">$y = \frac{\ln x}{x}$</span> 的定义域为 <span class="markdown-them-math-inline">$\mathbb{R}^+$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后对其求导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="markdown-them-math-inline">$y' =\frac{1 - \ln x}{x ^ 2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现需要以 <span class="markdown-them-math-inline">$x = 1, e$</span> 作为分界点进行分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li>当 <span class="markdown-them-math-inline">$0 &lt; x &lt; 1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>往左 <span class="markdown-them-math-inline">$1 - \ln x$</span> 快速增大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$x ^ 2$</span> 快速缩小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$y'$</span> 总体快速增大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$y$</span> 从 <span class="markdown-them-math-inline">$(1, 0)$</span> 开始向左以 <span class="markdown-them-math-inline">$y$</span> 轴为渐近线快速下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>当 <span class="markdown-them-math-inline">$1 &lt; x &lt; e$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1 - \ln x &gt; 0, x ^ 2 &gt; 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且 <span class="markdown-them-math-inline">$y'$</span> 的值不大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$y$</span> 从 <span class="markdown-them-math-inline">$(1, 0)$</span> 开始缓慢上升<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以 <span class="markdown-them-math-inline">$(e, \frac{1}{e})$</span> 作为最高点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>当 <span class="markdown-them-math-inline">$x &gt; e$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1 - \ln x &lt; 0, x ^ 2 &gt; 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且 <span class="markdown-them-math-inline">$1 - \ln x$</span> 的下降速度远不如 <span class="markdown-them-math-inline">$x ^ 2$</span> 的上升速度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$y' &lt; 0$</span> 且以 <span class="markdown-them-math-inline">$0$</span> 为渐近线不断变大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>体现在图像上即为 <span class="markdown-them-math-inline">$y$</span> 从 <span class="markdown-them-math-inline">$(e, \frac{1}{e})$</span> 开始减速下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><h2 id="$y-= \frac{x}{\ln x}$"><span class="markdown-them-math-inline">$y = \frac{x}{\ln x}$</span></h2><img src = "https://s1.ax1x.com/2022/05/16/OhVqFx.png" width="bottom" height="400" align="bottom" /><p>容易知道 <span class="markdown-them-math-inline">$y = \frac{x}{\ln x}$</span> 的定义域为 <span class="markdown-them-math-inline">$\mathbb{R}^+ \backslash\{1\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后对其求导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="markdown-them-math-inline">$y' = \frac{\ln x - 1}{\ln ^ 2 x}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现需要以 <span class="markdown-them-math-inline">$x = 1, e$</span> 作为分界点进行分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li>当 <span class="markdown-them-math-inline">$0 &lt; x &lt; 1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\ln x - 1$</span> 始终小于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\ln ^ 2 x$</span> 始终大于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在靠近 <span class="markdown-them-math-inline">$x = 0$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\ln x \to - \infty$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$\frac{\ln x - 1}{\ln ^ 2 x} \to \frac{1}{-\infty}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$y$</span> 下降幅度很小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>在靠近 <span class="markdown-them-math-inline">$x = 1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\ln x \to 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$\frac{\ln x - 1}{\ln ^ 2 x} \to -\infty$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$y$</span> 下降幅度很大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>当 <span class="markdown-them-math-inline">$1 &lt; x &lt; e$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\ln x - 1$</span> 始终小于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\ln ^ 2 x$</span> 始终大于 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于在 <span class="markdown-them-math-inline">$x$</span> 仅比 <span class="markdown-them-math-inline">$1$</span> 大一点点的时候 <span class="markdown-them-math-inline">$\ln x$</span> 非常接近 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$y$</span> 从 <span class="markdown-them-math-inline">$(1, +\infty)$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一个虚拟的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>开始以非常快的速度下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后逐渐变得平缓<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$(e, e)$</span> 取到最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>当 <span class="markdown-them-math-inline">$x &gt; e$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\ln x - 1$</span> 以缓慢的速度从 <span class="markdown-them-math-inline">$0$</span> 开始变大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\ln ^ 2 x$</span> 以比 <span class="markdown-them-math-inline">$\ln x$</span> 快一些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但仍然十分缓慢的速度从 <span class="markdown-them-math-inline">$1$</span> 开始变大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于其结构上与 <span class="markdown-them-math-inline">$\frac{1}{\ln x}$</span> 十分类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以它以非常缓慢的速度减小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>体现在图像上即为 <span class="markdown-them-math-inline">$y$</span> 不断上升<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但上升速度越来越慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「Codechef」Children Trips</title>
      <link href="/2023/06/24/codechef-children-trips/"/>
      <url>/2023/06/24/codechef-children-trips/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.codechef.com/problems/TRIPS">[Codechef] Children Trips</a> 解题报告<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="description">Description</h2><p>你在一颗树上旅行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>树由 <span class="markdown-them-math-inline">$n$</span> 个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n - 1$</span> 条边构成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每条边的长度 <span class="markdown-them-math-inline">$w$</span> 是 <span class="markdown-them-math-inline">$1$</span> 或 <span class="markdown-them-math-inline">$2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>你要从点 <span class="markdown-them-math-inline">$u$</span> 沿着唯一的简单路径走到点 <span class="markdown-them-math-inline">$v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>你的体力有限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以一天之内最多只能走 <span class="markdown-them-math-inline">$l$</span> 的距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一天结束时待在树的节点外是很危险的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以你必须在一天结束前到达某个节点并停下<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>可以刚好到达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即使你没有走到 <span class="markdown-them-math-inline">$l$</span> 的距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>给定这棵树和 <span class="markdown-them-math-inline">$q$</span> 个询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个询问给出 <span class="markdown-them-math-inline">$u,v,l$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请求出至少需要多少天<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>数据范围 : <span class="markdown-them-math-inline">$1 \leqslant n,q \leqslant 10^5, 1 \leqslant x,y,u,v \leqslant n,w \in \{1, 2\}, 2 \leqslant l \leqslant 2n.$</span></p><h2 id="tutorial">Tutorial</h2><p><strong>Lemma1:</strong> 一条路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>正着走和倒着走答案是一样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><strong>Proof1:</strong> 考虑将正着和倒着每天累计走的距离写下来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现正着走相当于一开始落后了至多 <span class="markdown-them-math-inline">$1$</span> 的距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后面在不断追赶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现在走的过程中是存在单调性的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以正着走一定不可能超过倒着走<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但也不可能落后超过 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于最后会走到相同的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以答案是一样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有了上述引理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以考虑分别计算 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$v$</span> 分别跳到 <span class="markdown-them-math-inline">$\textrm{LCA}(u, v)$</span> 下面最高能跳到的点的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$l_1, l_2$</span> 分别表示 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$v$</span> 剩下的距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终答案即为 <span class="markdown-them-math-inline">$u$</span> 和 <span class="markdown-them-math-inline">$v$</span> 的答案之和加上 <span class="markdown-them-math-inline">$\left\lceil\frac{l_1 + l_2}{l}\right\rceil$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑对询问根号分治<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别处理 <span class="markdown-them-math-inline">$l \leqslant \sqrt{n}$</span> 的询问和 <span class="markdown-them-math-inline">$l &gt; \sqrt{n}$</span> 的询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ul><li>对于 <span class="markdown-them-math-inline">$l &gt; \sqrt{n}$</span> 的询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现其跳的次数不超过 <span class="markdown-them-math-inline">$\sqrt{n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是可以直接暴力跳<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用倍增维护一下即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>对于 <span class="markdown-them-math-inline">$l \leqslant \sqrt{n}$</span> 的询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以预处理出从每个点 <span class="markdown-them-math-inline">$u$</span> 开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时的 <span class="markdown-them-math-inline">$l = k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>往上跳 <span class="markdown-them-math-inline">$2 ^ i$</span> 天到的点 <span class="markdown-them-math-inline">$f_{u, k, i}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>倍增往上跳即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \sqrt{n} \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>卡一卡常可以通过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑换一种思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们给树上 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 个点打上标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称它们为特殊点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么如果标记打得足够均匀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就可以使 <span class="markdown-them-math-inline">$u, v \to \textrm{LCA}(u, v)$</span> 的路径上每隔 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 的距离经过一个特殊点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且总共经过 <span class="markdown-them-math-inline">$\sqrt{n}$</span> 个特殊点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>至于如何打标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以记 <span class="markdown-them-math-inline">$dis_u$</span> 表示 <span class="markdown-them-math-inline">$u$</span> 到树上最远点的距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取 <span class="markdown-them-math-inline">$B = \sqrt{n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$u$</span> 为标记点当且仅当 <span class="markdown-them-math-inline">$B | dis_u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑预处理 <span class="markdown-them-math-inline">$f_{u, k}$</span> 表示当 <span class="markdown-them-math-inline">$l = k$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从 <span class="markdown-them-math-inline">$u$</span> 开始走一天到的点<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如果这个点超过了 <span class="markdown-them-math-inline">$u$</span> 祖先中最深的特殊点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就将 <span class="markdown-them-math-inline">$f_{u, k}$</span> 设为该特殊点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且计算剩下了多少距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g_{u, k}$</span> 表示当 <span class="markdown-them-math-inline">$l = k$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从 <span class="markdown-them-math-inline">$u$</span> 开始走到 <span class="markdown-them-math-inline">$u$</span> 祖先中最深的特殊点需要花费的天数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>容易发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于走到 <span class="markdown-them-math-inline">$u$</span> 祖先中最深的特殊点最多 <span class="markdown-them-math-inline">$2\sqrt{n}$</span> 的距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$k$</span> 的取值范围为 <span class="markdown-them-math-inline">$[0, 2\sqrt{n}]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>预处理直接从上往下递推即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于状态总数是 <span class="markdown-them-math-inline">$n \sqrt{n}$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以预处理时间复杂度也是 <span class="markdown-them-math-inline">$\Theta(n \sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>至于如何使用这两个数组优化往上跳的过程则是简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不作赘述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \sqrt{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以轻松通过此题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「CF690A」Collective Mindsets</title>
      <link href="/2023/06/24/cf690a-collective-mindsets/"/>
      <url>/2023/06/24/cf690a-collective-mindsets/</url>
      
        <content type="html"><![CDATA[<p>[CF690 <a href="https://codeforces.com/contest/690/problem/A1">A1</a> <a href="https://codeforces.com/contest/690/problem/A2">A2</a>] Collective Mindsets 解题报告及代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="description">Description</h2><p>你是一只僵尸<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>你现在和 <span class="markdown-them-math-inline">$n - 1$</span> 个僵尸站在一起分配大脑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>你的编号是 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其他僵尸编号 <span class="markdown-them-math-inline">$2 \sim n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>僵尸们按照编号从小到大的顺序提出分配方案<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一个方案是指每个僵尸分配几个大脑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大脑不能有剩余<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后所有僵尸进行投票<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果得票数<strong>大于等于</strong>一半方案就通过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则当前的僵尸会被其它僵尸吃掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由下一个僵尸进行分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>僵尸们都很贪婪和残忍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但它们更不想被吃掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以僵尸们会在保证自己<strong>不被吃掉</strong>的情况下提出自己获得的大脑<strong>最多</strong>的方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且<strong>当且仅当</strong>吃掉分配的僵尸<strong>严格劣于</strong>同意分配方案时才会投赞同票<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>给定 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在你想活下去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且获得至少 <span class="markdown-them-math-inline">$m$</span> 个大脑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请问至少需要多少大脑才能满足<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p><p>数据范围 : <span class="markdown-them-math-inline">$n \leqslant 10 ^ 9, m \in \{0, 1\}.$</span></p><h2 id="tutorial">Tutorial</h2><p>首先考虑 <span class="markdown-them-math-inline">$m = 1$</span> 的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>容易知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$n = 1$</span> 或 <span class="markdown-them-math-inline">$n = 2$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不需要其它任何人同意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以只需要给自己分配一个脑子即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案为 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当 <span class="markdown-them-math-inline">$n = 3$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1$</span> 号不可能获得 <span class="markdown-them-math-inline">$2$</span> 号的投票<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 <span class="markdown-them-math-inline">$1$</span> 号死后 <span class="markdown-them-math-inline">$2$</span> 号可以独占所有脑子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$1$</span> 号只能去争取 <span class="markdown-them-math-inline">$3$</span> 号的同意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>又因为如果让 <span class="markdown-them-math-inline">$2$</span> 号来分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$3$</span> 号一个脑子都得不到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以分给它 <span class="markdown-them-math-inline">$1$</span> 个脑子即可获得它的同意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案为 <span class="markdown-them-math-inline">$2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑不断将 <span class="markdown-them-math-inline">$n$</span> 增加来考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在上一步中可以获得脑子的僵尸是无法收买的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是给上一步中无法获得脑子的僵尸分别分配 <span class="markdown-them-math-inline">$1$</span> 个脑子就可以获得它们的同意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$m = 1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案为 <span class="markdown-them-math-inline">$\left\lfloor\frac{n + 1}{2}\right\rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后考虑 <span class="markdown-them-math-inline">$m = 0$</span> 的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先可以确定一个答案的上界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即考虑到 <span class="markdown-them-math-inline">$m = 1$</span> 情况下的分法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案至多为 <span class="markdown-them-math-inline">$\left\lfloor\frac{n - 1}{2}\right\rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑当答案为 <span class="markdown-them-math-inline">$0$</span> 时有哪些僵尸可以存活:</p><p>首先给僵尸重新标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记最后提方案的僵尸为 <span class="markdown-them-math-inline">$1$</span> 号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>倒数第二个为 <span class="markdown-them-math-inline">$2$</span> 号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>依此类推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>容易知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$n = 1$</span> 或 <span class="markdown-them-math-inline">$n = 2$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所有僵尸均可存活<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$3$</span> 号僵尸无法牵扯任何僵尸的利益<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以它无法存活<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$4$</span> 号僵尸死后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$3$</span> 号僵尸也会死<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是它获得 <span class="markdown-them-math-inline">$3$</span> 号僵尸的支持<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以存活<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$5, 6, 7$</span> 号僵尸全部死后 <span class="markdown-them-math-inline">$1, 2, 3, 4$</span> 号僵尸也不会有任何损失<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是它们都不会同意 <span class="markdown-them-math-inline">$5, 6, 7$</span> 号僵尸的方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 <span class="markdown-them-math-inline">$5, 6, 7$</span> 号无法存活<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$8$</span> 号僵尸死后 <span class="markdown-them-math-inline">$5, 6, 7$</span> 号会死<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是它可以获得除自己外 <span class="markdown-them-math-inline">$3$</span> 只僵尸的支持<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以存活<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>到这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以找到规律<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在用到 <span class="markdown-them-math-inline">$0$</span> 个脑子的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1, 2, 4, 8, 16, \cdots$</span> 号僵尸可以存活<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>用与之前类似的方式分析脑子总数为 <span class="markdown-them-math-inline">$1, 2, 3, \cdots$</span> 的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当脑子总数为 <span class="markdown-them-math-inline">$B$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存活僵尸的集合为 <span class="markdown-them-math-inline">$\{1, 2, \cdots, 2B\} \cup \{2B + 2 ^ i|i \in N ^ *\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当 <span class="markdown-them-math-inline">$n \equiv 1 \pmod 2$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n$</span> 仅有可能在集合 <span class="markdown-them-math-inline">$\{1, 2, \cdots, 2(B + 1)\}$</span> 中出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是答案为 <span class="markdown-them-math-inline">$\frac{n - 1}{2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当 <span class="markdown-them-math-inline">$n \equiv 0 \pmod 2$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以找到最大的 <span class="markdown-them-math-inline">$2$</span> 的幂 <span class="markdown-them-math-inline">$p$</span> 满足 <span class="markdown-them-math-inline">$p \leqslant n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时 <span class="markdown-them-math-inline">$n$</span> 会在 <span class="markdown-them-math-inline">$B = \frac{n - p}{2}$</span> 时第一次出现在集合中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是答案即为 <span class="markdown-them-math-inline">$\frac{n - p}{2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="reference-code">Reference Code</h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">int</span> n, m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n, m = <span class="hljs-number">1</span><span class="hljs-comment">/*0*/</span>;    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (p * <span class="hljs-number">2</span> &lt;= n) p *= <span class="hljs-number">2</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (n - p) / <span class="hljs-number">2</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「题解」AtCoder Beginner Contest 247</title>
      <link href="/2023/06/24/ti-jie-atcoder-beginner-contest-247/"/>
      <url>/2023/06/24/ti-jie-atcoder-beginner-contest-247/</url>
      
        <content type="html"><![CDATA[<p>ABC247 EF 题解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>ABCDEF 代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="e">E</h2><p>考虑枚举右端点 <span class="markdown-them-math-inline">$R$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算对于每个 <span class="markdown-them-math-inline">$R$</span> 有多少个左端点 <span class="markdown-them-math-inline">$L$</span> 满足条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>左端点需要满足的条件如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><span class="markdown-them-math-inline">$[L, R]$</span> 中需要有 <span class="markdown-them-math-inline">$x$</span> 和 <span class="markdown-them-math-inline">$y$</span> 至少各一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li><span class="markdown-them-math-inline">$[L, R]$</span> 中不能出现比 <span class="markdown-them-math-inline">$x$</span> 大或比 <span class="markdown-them-math-inline">$y$</span> 小的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>转化条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>设 <span class="markdown-them-math-inline">$px$</span> 表示 <span class="markdown-them-math-inline">$[1, R]$</span> 中最右边 <span class="markdown-them-math-inline">$x$</span> 的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$py$</span> 表示 <span class="markdown-them-math-inline">$[1, R]$</span> 中最右边 <span class="markdown-them-math-inline">$y$</span> 的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$L \leqslant \min(px, py)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>设 <span class="markdown-them-math-inline">$gex$</span> 表示 <span class="markdown-them-math-inline">$[1, R]$</span> 中最右边大于 <span class="markdown-them-math-inline">$x$</span> 的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$ley$</span> 表示 <span class="markdown-them-math-inline">$[1, R]$</span> 中最右边小于 <span class="markdown-them-math-inline">$y$</span> 的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$L &gt; \max(gex, ley)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>于是只需要在枚举 <span class="markdown-them-math-inline">$R$</span> 的同时维护 <span class="markdown-them-math-inline">$px, py, gex, ley$</span> 并将 <span class="markdown-them-math-inline">$\min(px, py) - \max(gex, ley)$</span> 计入答案即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="f">F</h2><p>考虑到每个数都需要存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且它在恰好两个位置中出现过<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>这两个位置可能相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是将这两个位置在一张图中连无向边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>观察到每个点度数都恰好为 <span class="markdown-them-math-inline">$2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是连边后构成若干个环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>易知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整体方案数为每个环方案数的乘积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个环的方案数为点覆盖方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑求解大小为 <span class="markdown-them-math-inline">$m$</span> 的环的点覆盖方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑强行将环从 <span class="markdown-them-math-inline">$n \sim 1$</span> 处拆成链<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$f_{i, 0/1}$</span> 表示仅考虑 <span class="markdown-them-math-inline">$1 \sim i$</span> 的链<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>中间每条边都至少有一个端点被选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第 <span class="markdown-them-math-inline">$i$</span> 个点被选或不选的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>转移是简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是我们发现最后计算答案时需要知道第一个点到底选没选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是需要钦点第一个点选或不选分别转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>将转移方程写出来后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们观察到它其实是两个斐波那契状物之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是用数列 <span class="markdown-them-math-inline">$f_1 = 1, f_2 = 3, f_i = f_{i - 1} + f_{i - 2}$</span> 来拟合是可行的<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>当然也可以直接算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>代码也没长多少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上即可算出原问题答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="[code-link](https://atcoderjp/contests/abc247/submissions?f.task=&f.languagename=c%2b%2b&f.status=ac&f.user=wa_on_test_233)"><a href="https://atcoder.jp/contests/abc247/submissions?f.Task=&amp;f.LanguageName=C%2B%2B&amp;f.Status=AC&amp;f.User=WA_on_test_233">Code Link</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「题解」AtCoder Beginner Contest 213</title>
      <link href="/2023/06/24/ti-jie-atcoder-beginner-contest-213/"/>
      <url>/2023/06/24/ti-jie-atcoder-beginner-contest-213/</url>
      
        <content type="html"><![CDATA[<p>ABC213 EGH 题解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>ABCDEG 代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="e">E</h2><p>考虑使用 <span class="markdown-them-math-inline">$\rm bfs$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>观察到每一步的代价都是 <span class="markdown-them-math-inline">$0$</span> 或 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是建立双端队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每次迭代取队头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果走了代价为 <span class="markdown-them-math-inline">$0$</span> 的边就将出点加入队首<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则加入队尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑其正确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为走代价为 <span class="markdown-them-math-inline">$0$</span> 的边不会增加当前点的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以维护住当前取出的点一定是答案最小点的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(nm)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种模型还可拓展到代价为 <span class="markdown-them-math-inline">$0 \sim k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要对每种贡献维护一个队列即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现仍然满足单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(nk)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="g">G</h2><p>考虑使用状压 <span class="markdown-them-math-inline">$\rm DP$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$f_S$</span> 表示仅考虑 <span class="markdown-them-math-inline">$S$</span> 的导出子图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令它与 <span class="markdown-them-math-inline">$1$</span> 连通的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$cnt_S$</span> 表示 <span class="markdown-them-math-inline">$S$</span> 导出子图中的边数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$ans_k = \sum _ {1, k \in S} f_S \times 2 ^ {cnt_{U-S}}$$</div><p>考虑容斥求解 <span class="markdown-them-math-inline">$f_S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_S = 2 ^ {cnt_S} - \sum _ {1 \in T, T \subsetneq S} f_T \times 2 ^ {cnt_{S - T}}$$</div><p>求解两部分的时间复杂度分别为 <span class="markdown-them-math-inline">$\Theta(n ^ 2 2 ^ n)$</span> 和 <span class="markdown-them-math-inline">$\Theta(3 ^ n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后半部分可以使用 <span class="markdown-them-math-inline">$\rm FWT$</span> 优化或卷积做到 <span class="markdown-them-math-inline">$\Theta(n ^ 2 2 ^ n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="h">H</h2><p>考虑 <span class="markdown-them-math-inline">$\rm DP$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$f_{i, j}$</span> 表示到 <span class="markdown-them-math-inline">$i$</span> 为止经过长度为 <span class="markdown-them-math-inline">$j$</span> 的路径的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$E_{u, v, w}$</span> 表示从 <span class="markdown-them-math-inline">$u$</span> 到 <span class="markdown-them-math-inline">$v$</span> 长度为 <span class="markdown-them-math-inline">$w$</span> 的路径数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然有转移方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i, j} = \sum _ {k = 1} ^ n \sum _ {l = 1} ^ T f_{k, j - l} \times E_{k, i, l}$$</div><p>考虑用 <span class="markdown-them-math-inline">$\rm GF$</span> 拟合这个过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$F_i(x) = \sum \limits_{j} f_{i, j} x ^ j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$G_{i, j}(x) = \sum \limits_ {k \geqslant 1} E_{i, j, k} x ^ k.$</span> 有方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$F_i(x) = \sum _ {j = 1} ^ n F_j(x) \times G_{j, i}(x)$$</div><p>使用分治多项式乘法即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n ^ 2 T \log ^ 2 T)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><a href="https://atcoder.jp/contests/abc213/submissions?f.Task=&amp;f.LanguageName=C%2B%2B&amp;f.Status=AC&amp;f.User=WA_on_test_233">Code Link</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「题解」AtCoder Beginner Contest 214</title>
      <link href="/2023/06/24/ti-jie-atcoder-beginner-contest-214/"/>
      <url>/2023/06/24/ti-jie-atcoder-beginner-contest-214/</url>
      
        <content type="html"><![CDATA[<h2 id="d">D</h2><p>考虑枚举最大边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别计算从两个端点出发能走到多少个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现并查集能够很好地拟合这个过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是将边从小到大加入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次合并的两个点集即为所求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="e">E</h2><p>考虑贪心<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从小到大枚举每一个盒子 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所有满足 <span class="markdown-them-math-inline">$L \leqslant i$</span> 的球都可以放进这个盒子<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如果 <span class="markdown-them-math-inline">$R &lt; i$</span> 则无解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现要选择 <span class="markdown-them-math-inline">$R$</span> 最小的球放进当前盒子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>但是由于盒子数量很大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不能枚举盒子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑将所有区间按 <span class="markdown-them-math-inline">$L$</span> 从小到大排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$p$</span> 表示当前填到哪个盒子了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将所有满足 <span class="markdown-them-math-inline">$L \leqslant p$</span> 的盒子以 <span class="markdown-them-math-inline">$R$</span> 为关键字加入小根堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时维护 <span class="markdown-them-math-inline">$p$</span> 是简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="f">F</h2><p>首先考虑求解本质不同子序列数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$f_i$</span> 表示考虑到 <span class="markdown-them-math-inline">$s_i$</span> 且 <span class="markdown-them-math-inline">$s_i$</span> 必选的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现不同子序列个数是好求的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移方程为 <span class="markdown-them-math-inline">$f_i = \sum \limits _ {j = 0} ^ {i - 1} f_j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但如何去除重复的子序列呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p><p>令 <span class="markdown-them-math-inline">$k$</span> 为满足 <span class="markdown-them-math-inline">$s_k = s_i, k &lt; i$</span> 的最大整数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意到在这种转移方式下会得出相同的子序列当且仅当在 <span class="markdown-them-math-inline">$f_j (j &lt; k)$</span> 的后面直接接上了 <span class="markdown-them-math-inline">$s_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是本质不同子序列计数的转移方程为 <span class="markdown-them-math-inline">$f_i = \sum \limits _ {j = 0} ^ {i - 1} f_j - \sum \limits _ {j = 0} ^ {k - 1} f_j = \sum \limits _ {j = k} ^ {i - 1} f_j.$</span></p><p>而子序列中相邻两字符在原串中不相同的限制是好保证的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要考虑其不同子序列个数的转移方程为 <span class="markdown-them-math-inline">$f_i = \sum \limits_ {j = 0} ^ {i - 2} f_j$</span> 对后面的推导稍作修改即可得到本质不同子序列计数的转移方程为 <span class="markdown-them-math-inline">$f_i = \sum \limits _ {j = k - 1} ^ {i - 2} f_j$</span>.</p><p>记录一下每个字符 <span class="markdown-them-math-inline">$c$</span> 当前最后出现的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时做前缀和优化即可做到 <span class="markdown-them-math-inline">$\Theta(1)$</span> 转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="g">G</h2><p>首先可以将 <span class="markdown-them-math-inline">$q_i$</span> 对 <span class="markdown-them-math-inline">$p_i$</span> 做置换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将限制转换成 <span class="markdown-them-math-inline">$r_i \not= i, a_i$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑将 <span class="markdown-them-math-inline">$i$</span> 向 <span class="markdown-them-math-inline">$a_i$</span> 连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到若干置换环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时候问题可以重新描述为<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>每个点的取值不能为自身权值或后一个点的权值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span></p><p>考虑容斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要对每个 <span class="markdown-them-math-inline">$k$</span> 分别计算<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>恰有 <span class="markdown-them-math-inline">$k$</span> 个点不满足限制的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易发现可以对每个环分别计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑在一个长度为 <span class="markdown-them-math-inline">$m$</span> 的置换环上如何计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑设 <span class="markdown-them-math-inline">$f_{i, j, 0/1/2}$</span> 表示当前考虑到第 <span class="markdown-them-math-inline">$i$</span> 个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前 <span class="markdown-them-math-inline">$i$</span> 个点中共有 <span class="markdown-them-math-inline">$j$</span> 个点的取值不满足限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且第 <span class="markdown-them-math-inline">$i$</span> 个点的取值为<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>自身/后一个点/两者皆不<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>转移之前枚举第一个点的取值状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移时两个状态之间不能转移当且仅当前一个点的取值为后一个点且后一个点的取值为它自身权值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后统计方案时判断一下最后一个点的状态能否与枚举的第一个点的状态拼合即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>将每个环的方案数算出来后只需要每次取两个最小的环使用暴力多项式乘法即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易证明时间复杂度是 <span class="markdown-them-math-inline">$\Theta(n ^ 2)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最后考虑如何计算答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若设恰好有 <span class="markdown-them-math-inline">$k$</span> 个点的取值不满足限制的方案数为 <span class="markdown-them-math-inline">$g_k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则根据二项式反演公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终答案为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum _ {i = 0} ^ {n} (-1) ^ i \dbinom{n}{i} g_i \times (n - i)!$$</div><p>其中 <span class="markdown-them-math-inline">$(n - i)!$</span> 是不满足限制的点的取值确定后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其它点的取值随意排列的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n ^ 2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="[code-link](https://atcoderjp/contests/abc214/submissions/me?f.task=&f.languagename=c%2b%2b&f.status=ac&f.user=wa_on_test_233)"><a href="https://atcoder.jp/contests/abc214/submissions/me?f.Task=&amp;f.LanguageName=C%2B%2B&amp;f.Status=AC&amp;f.User=WA_on_test_233">Code Link</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「题解」AtCoder Beginner Contest 212</title>
      <link href="/2023/06/24/ti-jie-atcoder-beginner-contest-212/"/>
      <url>/2023/06/24/ti-jie-atcoder-beginner-contest-212/</url>
      
        <content type="html"><![CDATA[<p>ABC212 EFGH 题解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>ABCDEFGH 代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="e">E</h2><p>考虑记 <span class="markdown-them-math-inline">$f_{i, u}$</span> 表示走 <span class="markdown-them-math-inline">$i$</span> 步到 <span class="markdown-them-math-inline">$u$</span> 的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然有转移式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i, u} = \sum _ {(u, v) \in Edge} f_{i - 1, v}$$</div><p>状态数为 <span class="markdown-them-math-inline">$nk$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移的时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是总时间复杂度为 <span class="markdown-them-math-inline">$\Theta(n ^ 2 k).$</span></p><p>考虑到删除的边数很少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是将转移方程改写为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i, u} = \sum _ {v = 1} ^ n f_{i - 1, v} - \sum _ {(u, v) \not\in Edge} f_{i - 1, v}$$</div><p>前一项可以算完每个 <span class="markdown-them-math-inline">$i$</span> 以后记录一下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后一项合法转移数量之和为 <span class="markdown-them-math-inline">$m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是总时间复杂度被优化至 <span class="markdown-them-math-inline">$\Theta(nk + mk).$</span></p><h2 id="f">F</h2><p>看到这个题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们首先想到的肯定是倍增<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>但是细想一下可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从一个点 <span class="markdown-them-math-inline">$i$</span> 开始跳 <span class="markdown-them-math-inline">$2 ^ j$</span> 步到的地方还与时间有关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是难以处理的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我们考虑记 <span class="markdown-them-math-inline">$f_{i, j}$</span> 表示从 <span class="markdown-them-math-inline">$i$</span> 号<strong>路径</strong>开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳 <span class="markdown-them-math-inline">$2 ^ j$</span> 步到的地方<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现此时 <span class="markdown-them-math-inline">$f_{i, j}$</span> 的值是唯一的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是用 <span class="markdown-them-math-inline">$\rm set$</span> 维护出 <span class="markdown-them-math-inline">$y$</span> 号点在 <span class="markdown-them-math-inline">$x$</span> 时刻开始要走上的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后不断往后跳<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到停在最后一个时间不大于 <span class="markdown-them-math-inline">$z$</span> 的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>判断一下是停在路上还是停在点上即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>时间复杂度 <span class="markdown-them-math-inline">$\Theta(n \log n + q \log n).$</span></p><h2 id="g">G</h2><p>首先考虑到当 <span class="markdown-them-math-inline">$x = 0$</span> 时有且仅有 <span class="markdown-them-math-inline">$y = 0$</span> 满足条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们不妨设 <span class="markdown-them-math-inline">$1 \leqslant x, y &lt; P$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后再给答案加上 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑 <span class="markdown-them-math-inline">$P$</span> 的一个原根 <span class="markdown-them-math-inline">$r$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$x = r ^ a, y = r ^ b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现 <span class="markdown-them-math-inline">$(x, y)$</span> 与 <span class="markdown-them-math-inline">$(a, b)$</span> 一一对应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$x ^ n \equiv y \iff r ^ {an} \equiv r ^ b \pmod P$$</div><p>考虑拓展欧拉定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$r ^ {an} \equiv r ^ b \pmod P \iff an \equiv b \pmod {P - 1}$$</div><p>于是问题被转化为求满足 <span class="markdown-them-math-inline">$an \equiv b \pmod {P - 1}$</span> 的 <span class="markdown-them-math-inline">$(a, b)$</span> 数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>根据裴蜀定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以推导出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum _ {a = 1} ^ {P - 1} \sum _ {b = 1} ^ {P - 1} [an \equiv b \pmod {P - 1}] = \sum _ {a = 1} ^ {P - 1} \frac{P - 1}{(P - 1, a)}$$</div><p>考虑对 <span class="markdown-them-math-inline">$(P - 1, a)$</span> 相等的 <span class="markdown-them-math-inline">$a$</span> 一起计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$f(g)$</span> 表示满足 <span class="markdown-them-math-inline">$g = (P - 1, a)$</span> 的 <span class="markdown-them-math-inline">$a$</span> 的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现 <span class="markdown-them-math-inline">$g~|~P - 1$</span> 且 <span class="markdown-them-math-inline">$f(g) = \varphi\left(\frac{P - 1}{g}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑求解 <span class="markdown-them-math-inline">$\varphi(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>观察到 <span class="markdown-them-math-inline">$\varphi \times I = id$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\varphi(n) = n - \sum _ {d | n \&amp; d \not= n} \varphi(d)$$</div><p>进一步有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f(g) = \frac{P - 1}{g} - \sum _ {g|k \&amp; g \not=k} f(g)$$</div><p>从大到小枚举 <span class="markdown-them-math-inline">$g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举其倍数转移一下即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度 <span class="markdown-them-math-inline">$\Theta(\sqrt{P} + d ^ 2(P - 1))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="h">H</h2><p>考虑记 <span class="markdown-them-math-inline">$w + 1$</span> 为第一个大于所有 <span class="markdown-them-math-inline">$a_i$</span> 的 <span class="markdown-them-math-inline">$2$</span> 的幂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S$</span> 为 <span class="markdown-them-math-inline">$a$</span> 序列中数构成的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>造一个集合幂级数 <span class="markdown-them-math-inline">$F(x) = \sum _ {i = 0} ^ w [i \in S]x ^ i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现答案即为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum _ {i = 1} ^ n \left(k ^ i - [x ^ 0] F^i(x) \right)$$</div><p>利用 <span class="markdown-them-math-inline">$\rm FWT$</span> 的线性性推一推式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}&amp;~~~~~\sum _ {i = 1} ^ n \left(k ^ i - [x ^ 0] F^i(x) \right) \\&amp;=\sum _ {i = 1} ^ n \left( k ^ i - [x ^ 0] \textrm{IFWT}(\textrm{FWT}\cdot F^i (x)) \right) \\&amp;=\sum _ {i = 1} ^ n k ^ i - [x ^ 0] \textrm{IFWT}\left( \sum _ {i = 1} ^ n \textrm{FWT} \cdot F^i(x)\right)\end{aligned}$$</div><p><span class="markdown-them-math-inline">$\rm FWT$</span> 后 <span class="markdown-them-math-inline">$F$</span> 的幂表示对每一项系数做点乘<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>设 <span class="markdown-them-math-inline">$G(x) = \textrm{FWT} \cdot F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用一下等比数列求和公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有答案为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum _ {i = 1} ^ n k ^ i - [x ^ 0] \textrm{IFWT}\left[ \sum _ {i = 0} ^ w \left( \frac{g_i ^ {n + 1} - g_i}{g_i - 1} \right)x ^ i \right]$$</div><p>计算上式所需时间复杂度为 <span class="markdown-them-math-inline">$\Theta((n + w) \log (n + w)).$</span></p><h2 id="[code-link](https://atcoderjp/contests/abc212/submissions?f.task=&f.languagename=c%2b%2b&f.status=ac&f.user=wa_on_test_233)"><a href="https://atcoder.jp/contests/abc212/submissions?f.Task=&amp;f.LanguageName=C%2B%2B&amp;f.Status=AC&amp;f.User=WA_on_test_233">Code Link</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「题解」2022 年新一卷数学第 7 题另解</title>
      <link href="/2023/06/24/ti-jie-2022-nian-gao-kao-quan-guo-i-juan-shu-xue-ke-mu-di-qi-ti-de-yi-chong-fei-chang-gui-jie-fa/"/>
      <url>/2023/06/24/ti-jie-2022-nian-gao-kao-quan-guo-i-juan-shu-xue-ke-mu-di-qi-ti-de-yi-chong-fei-chang-gui-jie-fa/</url>
      
        <content type="html"><![CDATA[<p>设 <span class="markdown-them-math-inline">$a = 0.1 e ^ {0.1}, b = \frac{1}{9}, c = -\ln 0.9$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>试比较 <span class="markdown-them-math-inline">$a, b, c$</span> 的大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑到以下公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$e ^ {qx} = \sum _ {n} q ^ n \frac{x ^ n}{n!} \tag{7.1}$$</div><div class="markdown-them-math-block">$$\ln(1 + x) = \sum _ n (-1) ^ n \frac{x ^ {n + 1}}{n + 1} \tag{7. 2}$$</div><p>将 <span class="markdown-them-math-inline">$a$</span> 带入式 <span class="markdown-them-math-inline">$(7. 1)$</span> 可得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}a &amp;= 0.1(1 + 0.1 + \frac{0.01}{2} + \frac{0.001}{6} + \cdots) \\  &amp;= 0.1 + 0.01 + \frac{0.001}{2} + \frac{0.0001}{6} + \cdots \end{aligned}$$</div><p>将 <span class="markdown-them-math-inline">$c$</span> 带入式 <span class="markdown-them-math-inline">$(7.2)$</span> 可得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{aligned}c &amp;= \ln (1 + \frac{1}{9}) \\  &amp;= \frac{1}{9} - \frac{\frac{1}{9 ^ 2}}{2} + \frac{\frac{1}{9 ^ 3}}{3} - \cdots\end{aligned}$$</div><p>分解 <span class="markdown-them-math-inline">$b$</span> 是简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$b = 0.111\cdots = 0.1 + 0.01 + 0.001 + \cdots$$</div><p>此时 <span class="markdown-them-math-inline">$b &gt; a, c$</span> 应当是一目了然的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑对比 <span class="markdown-them-math-inline">$a, c$</span> 的大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>取 <span class="markdown-them-math-inline">$c' = \frac{1}{9} - \frac{1}{2 \times 81} + \frac{1}{3 \times 729} &gt; c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不够好算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再取 <span class="markdown-them-math-inline">$c'' = \frac{1}{9} - \frac{1}{400} + \frac{1}{2000} = \frac{1}{9} - 0.002 &gt; c'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>取 <span class="markdown-them-math-inline">$a' = 0.1 + 0.01 &lt; a$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>易知 <span class="markdown-them-math-inline">$c'' &lt; a'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$c &lt; c' &lt; c'' &lt; a' &lt; a$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$c &lt; a &lt; b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「数学」2021 年计数题康复训练</title>
      <link href="/2023/06/24/shu-xue-2021-nian-ji-shu-ti-kang-fu-xun-lian/"/>
      <url>/2023/06/24/shu-xue-2021-nian-ji-shu-ti-kang-fu-xun-lian/</url>
      
        <content type="html"><![CDATA[<p>本文记录了 2021 年康复训练时做的一些有意思的计数题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="技巧收集">技巧收集</h2><ul><li>将要计数的总体分成很多个部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个部分分别计算贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>有些时候一个集合 <span class="markdown-them-math-inline">$S$</span> 联合产生贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了避免算重<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以将这个集合的贡献放在其中的某个元素上计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如标号最小的那一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>可以考虑划分阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次加入一个元素时计算答案增量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>如果需要计算在一个大的部分中选择一些状态的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以将这个大的部分分为几个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>枚举在这几个部分中选择的状态数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再分别计算并相乘<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>可以先计算每一部分的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用某种数据结构维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>合并的时候考虑两个部分联合产生的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>如果子问题的答案容易计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且原问题与子问题之间存在容斥关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以用 <span class="markdown-them-math-inline">$\rm DP$</span> 计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移的时候容斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><h2 id="好题选做">好题选做</h2><h3 id="[[usaco20feb]-help yourself g](https://wwwluogu.com.cn/problem/p6146)"><a href="https://www.luogu.com.cn/problem/P6146">[USACO20FEB] Help Yourself G</a></h3><p><strong>方法一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p>首先有一个直观的想法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算每条线段对答案的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑将每个连通块的贡献放到这个连通块最左边的线段上去计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们发现在一种选择方案中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一条线段 <span class="markdown-them-math-inline">$[l_i,r_i]$</span> 有 <span class="markdown-them-math-inline">$1$</span> 的贡献当且仅当不存在另一条同时被选择的线段 <span class="markdown-them-math-inline">$[l_j,r_j]$</span> 满足 <span class="markdown-them-math-inline">$l_j&lt;l_i&lt;r_j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即其左端点不能被覆盖<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>因为题目保证了所有端点互不相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以我们不需要经过比较复杂的分类讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接将线段按左端点排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>右端点用线段树维护即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>用线段树求出与当前线段不能同时选择的线段数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记为 <span class="markdown-them-math-inline">$x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则这条线段的贡献为 <span class="markdown-them-math-inline">$2^{n-x-1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, Pow[N], ans;pair &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; seg[N];<span class="hljs-keyword">namespace</span> ST &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LS (p &lt;&lt; 1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RS (p &lt;&lt; 1 | 1)</span><span class="hljs-keyword">int</span> sum[N &lt;&lt; <span class="hljs-number">3</span>], l[N &lt;&lt; <span class="hljs-number">3</span>], r[N &lt;&lt; <span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Build</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;    l[p] = L, r[p] = R, sum[p] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (L == R) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid = (L + R) &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-built_in">Build</span>(LS, L, mid), <span class="hljs-built_in">Build</span>(RS, mid + <span class="hljs-number">1</span>, R);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;    <span class="hljs-keyword">if</span> (l[p] == pos &amp;&amp; r[p] == pos) &#123;        sum[p]++; <span class="hljs-keyword">return</span>;    &#125;    pos &lt;= r[LS] ? <span class="hljs-built_in">add</span>(LS, pos) : <span class="hljs-built_in">add</span>(RS, pos);    sum[p] = sum[LS] + sum[RS];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Query</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;    <span class="hljs-keyword">if</span> (l[p] &gt;= L &amp;&amp; r[p] &lt;= R) <span class="hljs-keyword">return</span> sum[p];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (L &lt;= r[LS]) res += <span class="hljs-built_in">Query</span>(LS, L, R);    <span class="hljs-keyword">if</span> (R &gt;= l[RS]) res += <span class="hljs-built_in">Query</span>(RS, L, R);    <span class="hljs-keyword">return</span> res;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;seg[i].first, &amp;seg[i].second);    Pow[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) Pow[i] = (Pow[i - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">1</span>) % mod;    <span class="hljs-built_in">sort</span>(seg + <span class="hljs-number">1</span>, seg + n + <span class="hljs-number">1</span>);    ST::<span class="hljs-built_in">Build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;        ans = (ans + Pow[n - ST::<span class="hljs-built_in">Query</span>(<span class="hljs-number">1</span>, seg[i].first + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) - <span class="hljs-number">1</span>]) % mod;        ST::<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, seg[i].second);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>方法二<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p>还是考虑将线段按左端点排序后一个个加入并计算贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是我们这次只考虑已经枚举了的 <span class="markdown-them-math-inline">$i$</span> 条线段的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记为 <span class="markdown-them-math-inline">$f_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前枚举的线段不选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么答案为 <span class="markdown-them-math-inline">$f_{i-1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则在选择某一个集合的时候答案会 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这个集合中的线段即为右端点小于当前线段左端点的线段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记其数量为 <span class="markdown-them-math-inline">$x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 由于这个线段集合的每一个子集的答案都相比原来 <span class="markdown-them-math-inline">$+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以这种情况下的答案为 <span class="markdown-them-math-inline">$f_{i-1}+2^x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 故总的转移式为 <span class="markdown-them-math-inline">$f_i=2f_{i-1}+2^x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>至于 <span class="markdown-them-math-inline">$x$</span> 的值可以很方便地在最开始用前缀和求出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, sum[N], Pow[N], ans;pair &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; seg[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;seg[i].first, &amp;seg[i].second);    Pow[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) Pow[i] = (Pow[i - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">1</span>) % mod;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) sum[seg[i].second]++;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, (n &lt;&lt; <span class="hljs-number">1</span>)) sum[i] += sum[i - <span class="hljs-number">1</span>];    <span class="hljs-built_in">sort</span>(seg + <span class="hljs-number">1</span>, seg + n + <span class="hljs-number">1</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) ans = (<span class="hljs-number">2</span> * ans % mod + Pow[sum[seg[i].first - <span class="hljs-number">1</span>]]) % mod;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="[[jsoi2015]-子集选取](https://wwwluogu.com.cn/problem/p6075)"><a href="https://www.luogu.com.cn/problem/P6075">[JSOI2015] 子集选取</a></h3><p>看上去很简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>代码也很简洁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但如果要证明而非直接打表的话是一个有一定难度的题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先观察到题目限制等价于 <span class="markdown-them-math-inline">$\forall i'\leqslant i,j'\leqslant j,A_{i,j}\subseteq A_{i',j'}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>又观察到如果对每个元素分开考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么一定存在一条从左下到右上的分界线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使分界线左边的集合都有这个元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而右边都没有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>形如下图 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><img src="https://s2.ax1x.com/2020/02/11/1oskl9.png" alt=""></p><p>容易发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于每个元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样的路径与每种方案一一对应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且路径数为 <span class="markdown-them-math-inline">$2^n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>进一步的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现每个元素的方案相互独立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是将每个元素的方案数相乘即为最终答案 <span class="markdown-them-math-inline">$2^{nk}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, k;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">int</span> S = <span class="hljs-built_in">Pow</span>(a, k &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod * a % mod;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">Pow</span>(<span class="hljs-built_in">Pow</span>(<span class="hljs-number">2</span>, n), k));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="[[lg1350]-车的放置](https://wwwluogu.com.cn/problem/p1350)"><a href="https://www.luogu.com.cn/problem/P1350">[LG1350] 车的放置</a></h3><p>首先考虑在一个 <span class="markdown-them-math-inline">$k\times k$</span> 的矩形上放置 <span class="markdown-them-math-inline">$k$</span> 个车的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然为 <span class="markdown-them-math-inline">$k!$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后考虑在一个 <span class="markdown-them-math-inline">$n\times m$</span> 的矩形上放置 <span class="markdown-them-math-inline">$k$</span> 个车的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以先从 <span class="markdown-them-math-inline">$n$</span> 行 <span class="markdown-them-math-inline">$m$</span> 列中分别选出 <span class="markdown-them-math-inline">$k$</span> 行 <span class="markdown-them-math-inline">$k$</span> 列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再按照 <span class="markdown-them-math-inline">$k\times k$</span> 矩形的方式计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方案数为 <span class="markdown-them-math-inline">$\binom{n}{k}\binom{m}{k}k!$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑将原图形划分成右边一个 <span class="markdown-them-math-inline">$c\times d$</span> 的矩形和左边一个 <span class="markdown-them-math-inline">$a\times (b+d)$</span> 的矩形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后枚举在右边放置多少个车<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现右边每放置一个车都可以使左边能放置车的行减少一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是容易独立计算两边的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故答案为 :</p><div class="markdown-them-math-block">$$\sum_{i=0}^d \dbinom{c}{i}\dbinom{d}{i}i!\dbinom{a}{k-i}\dbinom{b+d-i}{k-i}(k-i)!$$</div><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e3</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">1e5</span> + <span class="hljs-number">3</span>;<span class="hljs-keyword">int</span> a, b, c, d, k, fac[N], inv[N], ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">int</span> S = <span class="hljs-built_in">Pow</span>(a, k &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod * a % mod;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * fac[n] * inv[m] % mod * inv[n - m] % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>) fac[i] = <span class="hljs-number">1ll</span> * fac[i - <span class="hljs-number">1</span>] * i % mod;    inv[N - <span class="hljs-number">1</span>] = <span class="hljs-built_in">Pow</span>(fac[N - <span class="hljs-number">1</span>], mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">dep</span>(i, N - <span class="hljs-number">2</span>, <span class="hljs-number">0</span>) inv[i] = <span class="hljs-number">1ll</span> * inv[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % mod;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; k;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, k) ans = (ans + <span class="hljs-number">1ll</span> * <span class="hljs-built_in">C</span>(c, i) * <span class="hljs-built_in">C</span>(d, i) % mod * fac[i] % mod * <span class="hljs-built_in">C</span>(a, k - i) % mod * <span class="hljs-built_in">C</span>(b + d - i, k - i) % mod * fac[k - i]) % mod;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="[[usaco20jan]-cave paintings p](https://wwwluogu.com.cn/problem/p6008)"><a href="https://www.luogu.com.cn/problem/P6008">[USACO20JAN] Cave Paintings P</a></h3><p>想这题时思路容易往如何建图上跑偏<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但其实完全不用建图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接对着原模型考虑即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑从底层往上加水的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现一些联通块会逐渐被连接在一起<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以考虑用并查集维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两个连通块合并的答案显然为原本答案的乘积加上 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为所有的点都加上水也是一种方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最终的答案即为所有连通块的方案数之积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(nm\log (nm))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> idx(x, y) ((x - 1) * m + y)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, m, fa[N * N], f[N * N], ans = <span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> s[N][N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x != fa[x]) fa[x] = <span class="hljs-built_in">Find</span>(fa[x]);    <span class="hljs-keyword">return</span> fa[x];&#125;<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; s[i] + <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n * m) fa[i] = i, f[i] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">dep</span>(i, n - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &#123;        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">3</span>, m - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (s[i][j] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; s[i][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) fa[<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i, j))] = <span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i, j - <span class="hljs-number">1</span>));        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">2</span>, m - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (s[i][j] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; s[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; <span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i, j)) != <span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i + <span class="hljs-number">1</span>, j)))            f[<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i, j))] = f[<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i, j))] * f[<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i + <span class="hljs-number">1</span>, j))] % mod, fa[<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i + <span class="hljs-number">1</span>, j))] = <span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i, j));        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">2</span>, m - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (s[i][j] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; <span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i, j)) == <span class="hljs-built_in">idx</span>(i, j)) f[<span class="hljs-built_in">idx</span>(i, j)]++;    &#125;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>) <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">2</span>, m - <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">idx</span>(i, j)) == <span class="hljs-built_in">idx</span>(i, j)) ans = ans * f[<span class="hljs-built_in">idx</span>(i, j)] % mod;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="[[hnoi2012]-排队](https://wwwluogu.com.cn/problem/p3223)"><a href="https://www.luogu.com.cn/problem/P3223">[HNOI2012] 排队</a></h3><p>运用插板法和捆绑法易得答案即为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$(n + 2)! A_{n + 3}^{m} - 2 (n + 1)! A_{n + 2}^{m}$$</div><p>高精差评<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e3</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">namespace</span> BigInt_Class &#123;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MaxL = <span class="hljs-number">5e3</span> + <span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BigInt</span> &#123;</span>    <span class="hljs-keyword">int</span> len, bit[MaxL];    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span> <span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) bit[i] = <span class="hljs-number">0</span>;        len = <span class="hljs-number">1</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span> <span class="hljs-params">(BigInt &amp;x)</span> </span>&#123;    <span class="hljs-keyword">char</span> s[MaxL];    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>), x.len = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= x.len; i++)        x.bit[i] = s[x.len - i + <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Write</span> <span class="hljs-params">(BigInt x, <span class="hljs-keyword">char</span> End)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x.len; i &gt;= <span class="hljs-number">1</span>; i--)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, x.bit[i]);    <span class="hljs-built_in">putchar</span>(End);&#125;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (BigInt a, BigInt b) &#123;    <span class="hljs-keyword">if</span> (a.len != b.len) <span class="hljs-keyword">return</span> a.len &lt; b.len;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.len; i &gt;= <span class="hljs-number">1</span>; i--)        <span class="hljs-keyword">if</span> (a.bit[i] != b.bit[i])            <span class="hljs-keyword">return</span> a.bit[i] &lt; b.bit[i];    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function">BigInt <span class="hljs-title">Change</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    BigInt res;    res.<span class="hljs-built_in">Clear</span>();    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;    <span class="hljs-keyword">else</span> res.len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (x) res.bit[++res.len] = x % <span class="hljs-number">10</span>, x /= <span class="hljs-number">10</span>;    <span class="hljs-keyword">return</span> res;&#125;BigInt <span class="hljs-keyword">operator</span> + (BigInt a, BigInt b) &#123;    BigInt res;    res.<span class="hljs-built_in">Clear</span>();    res.len = <span class="hljs-built_in">max</span>(a.len, b.len);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= res.len; i++)        res.bit[i] = a.bit[i] + b.bit[i];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= res.len; i++)        <span class="hljs-keyword">if</span> (res.bit[i] &gt;= <span class="hljs-number">10</span>)            res.bit[i] -= <span class="hljs-number">10</span>, res.bit[i + <span class="hljs-number">1</span>]++;    <span class="hljs-keyword">if</span> (res.bit[res.len + <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) res.len++;    <span class="hljs-keyword">return</span> res;&#125;BigInt <span class="hljs-keyword">operator</span> - (BigInt a, BigInt b) &#123;    BigInt res;    res.<span class="hljs-built_in">Clear</span>();    res.len = <span class="hljs-built_in">max</span>(a.len, b.len);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= res.len; i++)        res.bit[i] = a.bit[i] - b.bit[i];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= res.len; i++)        <span class="hljs-keyword">if</span> (res.bit[i] &lt; <span class="hljs-number">0</span>)            res.bit[i] += <span class="hljs-number">10</span>, res.bit[i + <span class="hljs-number">1</span>]--;    <span class="hljs-keyword">while</span> (res.bit[res.len] == <span class="hljs-number">0</span> &amp;&amp; res.len &gt; <span class="hljs-number">1</span>) res.len--;    <span class="hljs-keyword">return</span> res;&#125;BigInt <span class="hljs-keyword">operator</span> * (BigInt a, BigInt b) &#123;    BigInt res;    res.<span class="hljs-built_in">Clear</span>();    res.len = a.len + b.len;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= a.len; i++)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= b.len; j++)            res.bit[i + j - <span class="hljs-number">1</span>] += a.bit[i] * b.bit[j];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= res.len; i++)        <span class="hljs-keyword">if</span> (res.bit[i] &gt;= <span class="hljs-number">10</span>)            res.bit[i + <span class="hljs-number">1</span>] += res.bit[i] / <span class="hljs-number">10</span>, res.bit[i] %= <span class="hljs-number">10</span>;    <span class="hljs-keyword">while</span> (res.bit[res.len] == <span class="hljs-number">0</span> &amp;&amp; res.len &gt; <span class="hljs-number">1</span>) res.len--;    <span class="hljs-keyword">return</span> res;&#125;BigInt <span class="hljs-keyword">operator</span> / (BigInt a, BigInt b) &#123;    BigInt res, tmp;    res.<span class="hljs-built_in">Clear</span>();    <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> res;    res.len = a.len - b.len + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.len; i &gt;= b.len; i--) &#123;        tmp.<span class="hljs-built_in">Clear</span>(), tmp.len = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= b.len; j++)            tmp.bit[j + i - b.len] = b.bit[j];        <span class="hljs-keyword">while</span> (!(a &lt; tmp)) a = a - tmp, res.bit[i - b.len + <span class="hljs-number">1</span>]++;    &#125;    <span class="hljs-keyword">while</span> (res.bit[res.len] == <span class="hljs-number">0</span> &amp;&amp; res.len &gt; <span class="hljs-number">1</span>) res.len--;    <span class="hljs-keyword">return</span> res;&#125;BigInt <span class="hljs-keyword">operator</span> % (BigInt a, BigInt b) &#123;    BigInt tmp;    <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.len; i &gt;= b.len; i--) &#123;        tmp.<span class="hljs-built_in">Clear</span>(), tmp.len = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= b.len; j++)            tmp.bit[j + i - b.len] = b.bit[j];        <span class="hljs-keyword">while</span> (!(a &lt; tmp)) a = a - tmp;    &#125;    <span class="hljs-keyword">return</span> a;&#125;&#125;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> BigInt_Class;<span class="hljs-keyword">int</span> n, m;BigInt fac[N];<span class="hljs-function">BigInt <span class="hljs-title">A</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123; <span class="hljs-keyword">return</span> n &lt; m ? <span class="hljs-built_in">Change</span>(<span class="hljs-number">0</span>) : fac[n] / fac[n - m]; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; m;    fac[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Change</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">3</span>) fac[i] = fac[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">Change</span>(i);    <span class="hljs-built_in">Write</span>(fac[n + <span class="hljs-number">2</span>] * <span class="hljs-built_in">A</span>(n + <span class="hljs-number">3</span>, m) - <span class="hljs-built_in">Change</span>(<span class="hljs-number">2</span>) * fac[n + <span class="hljs-number">1</span>] * <span class="hljs-built_in">A</span>(n + <span class="hljs-number">2</span>, m), <span class="hljs-string">&#x27;\n&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="[[sdoi2016]-排列计数](https://wwwluogu.com.cn/problem/p4071)"><a href="https://www.luogu.com.cn/problem/P4071">[SDOI2016] 排列计数</a></h3><p>看到题目一眼二项式反演<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但事实上是不行的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑钦点 <span class="markdown-them-math-inline">$m$</span> 个位置 <span class="markdown-them-math-inline">$a_i=i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的显然是 <span class="markdown-them-math-inline">$n - m$</span> 个数的错排问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>记 <span class="markdown-them-math-inline">$D_{n}$</span> 表示 <span class="markdown-them-math-inline">$n$</span> 个数的错排问题方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>推导其递推式 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>考虑在 <span class="markdown-them-math-inline">$n$</span> 个数的基础上再加入第 <span class="markdown-them-math-inline">$n + 1$</span> 个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不妨设 <span class="markdown-them-math-inline">$a_{n+1}=k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>接下来对 <span class="markdown-them-math-inline">$a_k$</span> 做分类讨论 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>如果 <span class="markdown-them-math-inline">$a_k=n+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$k$</span> 和 <span class="markdown-them-math-inline">$n+1$</span> 互相占用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的方案数为 <span class="markdown-them-math-inline">$D_{n-1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>如果 <span class="markdown-them-math-inline">$a_k\not = n + 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么除了 <span class="markdown-them-math-inline">$a_{n + 1}$</span> 已经被确定之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其它所有位置都有且仅有一个数不能填 <span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>位置 <span class="markdown-them-math-inline">$k$</span> 不能填的数为 <span class="markdown-them-math-inline">$n + 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是方案即为 <span class="markdown-them-math-inline">$D_{n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>再考虑到选取 <span class="markdown-them-math-inline">$k$</span> 的方式有 <span class="markdown-them-math-inline">$n$</span> 种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$\{D_n\}$</span> 的递推式为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$D_{n + 1} = n(D_n + D_{n - 1})$$</div><p>根据错排数列的定义易知 <span class="markdown-them-math-inline">$D_0 = 1, D_1 = 0,D_2 = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案即为 <span class="markdown-them-math-inline">$\binom{n}{m}D_{n-m}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(T+n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> T, n, m, fac[N], inv[N], D[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">int</span> S = <span class="hljs-built_in">Pow</span>(a, k &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod * a % mod;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * fac[n] * inv[m] % mod * inv[n - m] % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>) fac[i] = <span class="hljs-number">1ll</span> * fac[i - <span class="hljs-number">1</span>] * i % mod;    inv[N - <span class="hljs-number">1</span>] = <span class="hljs-built_in">Pow</span>(fac[N - <span class="hljs-number">1</span>], mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">dep</span>(i, N - <span class="hljs-number">2</span>, <span class="hljs-number">0</span>) inv[i] = <span class="hljs-number">1ll</span> * inv[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % mod;    D[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, D[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, D[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">3</span>, N - <span class="hljs-number">1</span>) D[i] = <span class="hljs-number">1ll</span> * (i - <span class="hljs-number">1</span>) * (D[i - <span class="hljs-number">1</span>] + D[i - <span class="hljs-number">2</span>]) % mod;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T); <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-number">1ll</span> * <span class="hljs-built_in">C</span>(n, m) * D[n - m] % mod);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="[[hnoi2010]-合唱队](https://wwwluogu.com.cn/problem/p3205)"><a href="https://www.luogu.com.cn/problem/P3205">[HNOI2010] 合唱队</a></h3><p>考虑到一段区间内的方案数是独立的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是使用区间 <span class="markdown-them-math-inline">$\rm DP$</span> 求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>可以发现我们关心的状态除了区间端点 <span class="markdown-them-math-inline">$l,r$</span> 外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还有上一个填入值的大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为这关系到现在这个数填在左边还是右边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们观察到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上一个数只有可能填在区间的左端点或右端点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是记 <span class="markdown-them-math-inline">$f_{l,r,0/1}$</span> 表示在 <span class="markdown-them-math-inline">$[l,r]$</span> 这段区间内<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上一次填的数在左端点<span class="markdown-them-math-inline">$/$</span>右端点的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>转移是简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分 <span class="markdown-them-math-inline">$4$</span> 种情况 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li><span class="markdown-them-math-inline">$a_i&lt;a_{i + 1},f_{i,j,0}\leftarrow f_{i+1,j,0}$</span></li><li><span class="markdown-them-math-inline">$a_i&lt;a_{j},f_{i,j,0}\leftarrow f_{i+1,j,1}$</span></li><li><span class="markdown-them-math-inline">$a_j&gt;a_{i},f_{i,j,1}\leftarrow f_{i,j-1,0}$</span></li><li><span class="markdown-them-math-inline">$a_j&gt;a_{j-1},f_{i,j,1}\leftarrow f_{i,j-1,1}$</span></li></ul><p>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>赋初值时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以钦点 <span class="markdown-them-math-inline">$[i,j]$</span> 的数是从左端点填进去的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$f_{i,i,0} = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果不这样做的话会算重<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">19650827</span>;<span class="hljs-keyword">int</span> n, a[N], f[N][N][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) f[i][i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(len, <span class="hljs-number">2</span>, n) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) &#123;        <span class="hljs-keyword">int</span> j = i + len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (a[i] &lt; a[i + <span class="hljs-number">1</span>]) f[i][j][<span class="hljs-number">0</span>] = (f[i][j][<span class="hljs-number">0</span>] + f[i + <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]) % mod;        <span class="hljs-keyword">if</span> (a[i] &lt; a[j]) f[i][j][<span class="hljs-number">0</span>] = (f[i][j][<span class="hljs-number">0</span>] + f[i + <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]) % mod;        <span class="hljs-keyword">if</span> (a[j] &gt; a[i]) f[i][j][<span class="hljs-number">1</span>] = (f[i][j][<span class="hljs-number">1</span>] + f[i][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % mod;        <span class="hljs-keyword">if</span> (a[j] &gt; a[j - <span class="hljs-number">1</span>]) f[i][j][<span class="hljs-number">1</span>] = (f[i][j][<span class="hljs-number">1</span>] + f[i][j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % mod;    &#125;        cout &lt;&lt; (f[<span class="hljs-number">1</span>][n][<span class="hljs-number">0</span>] + f[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>]) % mod &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="[[hnoi2011]-卡农](https://wwwluogu.com.cn/problem/p3214)"><a href="https://www.luogu.com.cn/problem/P3214">[HNOI2011] 卡农</a></h3><p><strong>形式化题意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong></p><p>定义全集 <span class="markdown-them-math-inline">$U=\{1,2,3,\cdots ,n\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要从中选出 <span class="markdown-them-math-inline">$m$</span> 个子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>任意子集非空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>子集互不相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>在选出的 <span class="markdown-them-math-inline">$m$</span> 个子集中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1\sim n$</span> 中每个数的出现次数均为偶数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><p>求方案数对 <span class="markdown-them-math-inline">$10^8 + 7$</span> 取模后的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>保证 <span class="markdown-them-math-inline">$n,m\leqslant 10^6$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑计算选出子集有序的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现最后将方案数除以 <span class="markdown-them-math-inline">$m!$</span> 就与原问题等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>记 <span class="markdown-them-math-inline">$f_i$</span> 表示从 <span class="markdown-them-math-inline">$U$</span> 中选出 <span class="markdown-them-math-inline">$i$</span> 个合法子集的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转移考虑容斥 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>如果前面的 <span class="markdown-them-math-inline">$i - 1$</span> 个集合已经确定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这个集合中每个元素是否存在就已经被确定了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且一定存在一种选择这个集合的方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故在不考虑子集非空和子集互不相同的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方案数为 <span class="markdown-them-math-inline">$A_{2^n - 1}^{i - 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑将第 <span class="markdown-them-math-inline">$i$</span> 个集合为空的方案去除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现在第 <span class="markdown-them-math-inline">$i$</span> 个集合为空的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不合法方案与 <span class="markdown-them-math-inline">$f_{i - 1}$</span> 中的每种合法方案一一对应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故第 <span class="markdown-them-math-inline">$i$</span> 个集合为空的方案数为 <span class="markdown-them-math-inline">$f_{i - 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑将第 <span class="markdown-them-math-inline">$i$</span> 个集合与前面某个集合 <span class="markdown-them-math-inline">$S_j$</span> 相同的方案去除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将 <span class="markdown-them-math-inline">$S_i$</span> 和 <span class="markdown-them-math-inline">$S_j$</span> 同时去除后的方案还是合法的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且数量为 <span class="markdown-them-math-inline">$f_{i - 2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> <span class="markdown-them-math-inline">$j$</span> 有 <span class="markdown-them-math-inline">$i - 1$</span> 种取值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S_{i}$</span> 和 <span class="markdown-them-math-inline">$S_{j}$</span> 由于不能与另外 <span class="markdown-them-math-inline">$i - 2$</span> 个集合相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以有 <span class="markdown-them-math-inline">$(2^n - 1) - (i - 2)$</span> 种取法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>故第 <span class="markdown-them-math-inline">$i$</span> 个集合与之前某个集合相同的方案数为 <span class="markdown-them-math-inline">$f_{i - 2}\times (i - 1)\times (2^n - i + 1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>故转移方程为 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$f_{i} = A_{2^n - 1}^{i - 1} - f_{i - 1} - f_{i - 2}\times (i - 1)\times (2^n - i + 1)$$</div><p>经过一些预处理后可以做到 <span class="markdown-them-math-inline">$\Theta(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">1e8</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n, m, A[N], f[N], M;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">int</span> S = <span class="hljs-built_in">Pow</span>(a, k &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod * a % mod;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; m;    A[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Pow</span>(<span class="hljs-number">2</span>, n), A[<span class="hljs-number">1</span>] = A[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, m) A[i] = <span class="hljs-number">1ll</span> * A[i - <span class="hljs-number">1</span>] * (A[<span class="hljs-number">0</span>] - i) % mod;    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, m) f[i] = (A[i - <span class="hljs-number">1</span>] - f[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1ll</span> * f[i - <span class="hljs-number">2</span>] * (i - <span class="hljs-number">1</span>) % mod * (A[<span class="hljs-number">0</span>] - i + <span class="hljs-number">1</span>)) % mod;    M = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m) M = <span class="hljs-number">1ll</span> * M * i % mod;    cout &lt;&lt; (<span class="hljs-number">1ll</span> * f[m] * <span class="hljs-built_in">Pow</span>(M, mod - <span class="hljs-number">2</span>) % mod + mod) % mod &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="[[zjoi2010]-排列计数](https://wwwluogu.com.cn/problem/p2606)"><a href="https://www.luogu.com.cn/problem/P2606">[ZJOI2010] 排列计数</a></h3><p>可以发现 <a href="https://www.luogu.com.cn/problem/P5689">[CSP-S2019 江西] 多叉堆</a> 是这个题的弱化版<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但区别不算很大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑依据偏序关系连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现构成一颗满足小根堆性质的树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>记 <span class="markdown-them-math-inline">$f_{i}$</span> 表示以点 <span class="markdown-them-math-inline">$i$</span> 为根的子树的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然子树内答案独立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故只需要考虑乘上分配给子树的方案数即可得 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$siz_i = siz_{2i} + siz_{2i + 1} + 1$$</div><div class="markdown-them-math-block">$$f_i = f_{2i}\times f_{2i + 1}\times \dbinom{siz_i - 1}{siz_{2i}}$$</div><p>因为模数有可能小于 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以求组合数需要用到 <span class="markdown-them-math-inline">$\rm Lucas$</span> 定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在预处理阶乘逆元的时候最多预处理到 <span class="markdown-them-math-inline">$\rm mod - 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则会出现为 <span class="markdown-them-math-inline">$0$</span> 的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总时间复杂度 <span class="markdown-them-math-inline">$\Theta(n\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, l, r) for (int i = l; i &lt;= r; i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i, r, l) for (int i = r; i &gt;= l; i--)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, mod, Min, fac[N], inv[N], siz[N], f[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">int</span> S = <span class="hljs-built_in">Pow</span>(a, k &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod * a % mod;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * S * S % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Lucas</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n &lt; mod &amp;&amp; m &lt; mod) &#123;        <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * fac[n] * inv[m] % mod * inv[n - m] % mod;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span> * <span class="hljs-built_in">Lucas</span>(n / mod, m / mod) * <span class="hljs-built_in">Lucas</span>(n % mod, m % mod) % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; mod, Min = <span class="hljs-built_in">min</span>(n, mod - <span class="hljs-number">1</span>);        fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, Min) fac[i] = <span class="hljs-number">1ll</span> * fac[i - <span class="hljs-number">1</span>] * i % mod;    inv[Min] = <span class="hljs-built_in">Pow</span>(fac[Min], mod - <span class="hljs-number">2</span>);    <span class="hljs-built_in">dep</span>(i, Min - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) inv[i] = <span class="hljs-number">1ll</span> * inv[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % mod;    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) siz[i] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">dep</span>(i, n, <span class="hljs-number">1</span>) siz[i] += siz[i &lt;&lt; <span class="hljs-number">1</span>] + siz[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];    <span class="hljs-built_in">rep</span>(i, ((n + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>), n) f[i] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">dep</span>(i, ((n + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &#123;        f[i] = <span class="hljs-number">1ll</span> * f[i &lt;&lt; <span class="hljs-number">1</span>] * f[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] % mod * <span class="hljs-built_in">Lucas</span>(siz[i] - <span class="hljs-number">1</span>, siz[i &lt;&lt; <span class="hljs-number">1</span>]) % mod;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
