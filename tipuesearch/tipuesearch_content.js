var tipuesearch = {"pages":[{"title":"多次取 (0, 1) 之间的随机实数, 期望多少次后其和恰不小于 1","url":"/2024/08/27/duo-ci-qu-0-1-zhi-jian-de-sui-ji-shi-shu-qi-wang-duo-shao-ci-hou-qi-he-qia-bu-xiao-yu-1/","text":"设事件 $\\omega_n$ 表示随机取 $n$ 个 $(0, 1)$ 中的实数, 其和小于 $1$. $$\\begin{aligned} E &amp;= \\sum_{n = 1}^{\\infty} n P(\\omega_{n - 1} \\overline{\\omega_n}) \\\\ &amp;= \\sum_{n = 1}^{\\infty} n \\left[ P(\\omega_{n - 1}) - P(\\omega_{n - 1}\\omega_n) \\right] \\\\ &amp;= \\sum_{n = 1}^{\\infty} n \\left[ P(\\omega_{n - 1}) - P(\\omega_n) \\right] \\\\ &amp;= 1 + \\sum_{n = 1}^{\\infty} P(\\omega_n) \\end{aligned} $$考虑根据定义求 $\\omega_n$: $$\\omega_n = \\int_{0}^1 \\mathrm{d}x_1 \\int_{0}^{1 - x_1} \\mathrm{d}x_2 \\int_{0}^{1 - x_1 -x_2} \\mathrm{d}x_3 \\cdots \\int_{0}^{1 - \\sum_{i &lt; n} x_i} \\mathrm{d}x_n $$将 $1$ 用形式变量 $x$ 代替, 即得 $$\\omega_n(x) = \\int_{0}^x \\mathrm{d}x_1 \\int_{0}^{x - x_1} \\mathrm{d}x_2 \\int_{0}^{x - x_1 -x_2} \\mathrm{d}x_3 \\cdots \\int_{0}^{x - \\sum_{i &lt; n} x_i} \\mathrm{d}x_n $$考虑寻找 $\\omega_{n + 1}$ 和 $\\omega_n$ 之间的关系, 有 $$\\omega_{n + 1}(x) = \\int_{0}^{x} \\omega_n(x - x_{n + 1}) \\mathrm{d}x_{n + 1} $$注意到在积分内部, $\\mathrm{d}(x - x_{n + 1})$ 与 $\\mathrm{d}x_{n + 1}$ 实际上是等价的, 于是得到递推式 $$\\omega_{n + 1}(x) = \\int_{0}^{x} \\omega_n(t) \\mathrm{d}t $$根据定义 $\\omega_1(x) = x$, 于是归纳得 $$\\omega_{n}(x) = \\int_{0}^{x} \\frac{t^{n - 1}}{(n - 1)!} \\mathrm{d}t = \\frac{x^n}{n!} $$将 $x$ 换回 $1$, 回代得 $$E = 1 + \\sum_{n = 1}^{\\infty} \\frac{1}{n!} = \\mathrm{e} $$","tags":"数学 概率与期望 自然常数 多重积分"},{"title":"「ABC356F」Distance Component Size Query","url":"/2024/08/22/abc356f-distance-component-size-query/","text":"存在初始为空的点集 $S$, 进行 $n$ 次操作, 形如: $1\\ \\ u:$ 若 $u \\in S$ 则令 $u \\notin S$, 否则令 $u \\in S$. $2\\ \\ u:$ 对 $S$ 中的结点连无向边, $x, y$ 之间有边当且仅当 $|x - y| \\leqslant k$. 求 $u$ 所在的连通块大小. $n \\leqslant 2 \\times 10^5, k, u \\leqslant 10^{18}$. 对于一个固定的点集 $S$, 在只需要维护连通块的情况下对所有点对两两判断是否需要连边是没有必要的, 注意到 $\\forall a, b, c \\in S(a \\leqslant b \\leqslant c)$, 若 $|a - c| \\leqslant k$, 则 $|a - b|, |b - c| \\leqslant k$, 所以只对 $a, b$ 和 $b, c$ 连边同样可以维护 $a, b, c$ 两两之间的连通性, 此时边数降到与 $|S|$ 同阶. 有了上面的结论, 加点是简单的, 只需要求出 $u$ 在 $S$ 中的前驱和后继, 判断它们与 $u$ 是否满足连边条件即可. 连通性用并查集维护, 单次加点的时间复杂度为 $\\log n$. 而对于删点, 我们希望尽可能避免它, 于是求出每个点存在的时间段 $[l, r]$, 将其挂在线段树上覆盖了 $[l, r]$ 的结点上. 遍历线段树时进入结点则加, 退出结点则减, 容易发现这样做只需要处理叶的撤销, 是简单的. 于是我们 $\\Theta(n\\log^2 n)$ 求出了每个时刻询问的答案.","tags":"c++ 题解 atcoder abc"},{"title":"数据结构典中典","url":"/2024/08/09/shu-ju-jie-gou-dian-zhong-dian/","text":"","tags":"算法 oi 数据结构 c++ 分块 线段树 树分治 lca rmq"},{"title":"离散数学","url":"/2024/07/19/chi-san-shu-xue/","text":"","tags":"数学 离散数学 本科课程"},{"title":"树上背包","url":"/2024/06/22/shu-shang-bei-bao/","text":"选取 $m$ 个结点 这是最普遍的情况, 从树中选取 $m$ 个结点, 最大化它们的价值之和. 符合直觉地, 设 $f_{u, i}$ 表示从以 $u$ 为根的子树中选取了 $i$ 个结点的最大价值之和. 转移是显然的: $$f_{u, i + j} = \\max\\{f_{u, i} + f_{v, j}\\} $$其中 $i$, $j$ 的范围应当分别为 $u$ 此前枚举的子树大小和, 以 $v$ 为根的子树大小. 其最优性和可行性都是显然的, 我们考虑这个算法的复杂度. 看起来似乎是 $\\Theta(n^3)$, 但事实上对于任意点对 $(i \\in S_u, j \\in S_v)$, 它只会在 $u$ 处被枚举一次. 于是时间复杂度实际上是 $\\Theta(n^2)$. 选取结点的代价之和至多为 $m$ 在这个问题中为每个结点引入了代价, 此时上述的复杂度分析不再适用. 我们不妨考虑换一种思路, 正常的 $0/1$ 背包复杂度之所以为 $\\Theta(nm)$, 是因为每次只需要对一个物品做是否选取的决策. 在这里, 我们同样考虑将物品独立起来, 只考虑当前物品选或不选. 为了保证无后效性, 接下来的结点编号都被重新设为其在后序遍历中的时间戳. 设 $f_{i, j}$ 表示考虑了前 $i$ 个物品, 背包大小为 $j$, 能取到的最大价值和. 若选该物品, 则可以选择它子树中的物品, $f_{i, j} \\leftarrow f_{i - 1, j - w_i} + v_i$. 若不选该物品, 则它子树内的物品都不可以选, 而子树中的编号恰好是连续的, 于是 $f_{i, j} \\leftarrow f_{i - siz_i, j}$. 这样转移时间复杂度即为 $\\Theta(nm)$. int n, m, dfn; std::vector&lt;std::vector&lt;int&gt;&gt; E, f; std::vector&lt;int&gt; w, v, siz; void dfs (int u) &#123; for (int v : E[u]) dfs(v), siz[u] += siz[v]; dfn++; for (int j = 0; j &lt;= m; j++) &#123; f[dfn][j] = f[dfn - siz[u]][j]; if (j &gt;= w[u]) f[dfn][j] = std::max(f[dfn][j], f[dfn - 1][j - w[u]] + v[u]); &#125; &#125; int knapsack_on_tree () &#123; siz = std::vector&lt;int&gt;(n + 1, 1); f = std::vector&lt;std::vector&lt;int&gt;&gt;(n + 2, std::vector&lt;int&gt;(m + 1)); dfs(0); return f[n + 1][m]; &#125;","tags":"算法 oi c++ 动态规划 树上背包"},{"title":"某 0/1 背包 Trick","url":"/2024/06/22/mou-01-bei-bao-trick/","text":"有 $n$ 个物品, 第 $i$ 个重量为 $a_i$, 求重量不大于 $c$ 的情况下能够装下的最大重量. $n, m = \\max\\{a_i\\} \\leqslant 2 \\times 10 ^ 4, c \\leqslant 10 ^ 9.$ 考虑随便贪心出来一组解 $y$, 设正确答案为 $x$, 显然 $0 \\leqslant x - y \\leqslant m$. 考虑求最大的 $k \\leqslant c - y$, 满足存在一种方案, 删除一些贪心方案中选择的物品, 放入一些贪心方案中没有选择的物品, 总重量的变化量为 $k$. $y + k$ 即为正确答案. 设数列 $\\{s_i\\}$ 为贪心方案中未选的, 数列 $\\{t_i\\}$ 为贪心方案中选择了的数的相反数, 其中选择 $t_i$ 用以刻画从原方案中删除 $-t_i$. 注意到以下策略：当且仅当 $k + s_i \\leqslant m$ 时才考虑是否选择 $s_i$, 当且仅当 $k &gt; 0$ 时, 才考虑是否从 $\\{t_i\\}$ 中选数. 容易发现, 不论最终答案如何分布, 一定可以用这种策略刻画出来. 于是我们发现在转移的过程中, $|k| \\leqslant m$ 始终成立. 因此可以导出一个简单的 $\\rm DP$：设 $f_{i, j, k} = 0/1$ 表示当前考虑了 $s_{1 \\sim i}$ 和 $t_{1 \\sim j}$ 中的数, 能否表示 $k$. 据前文所述策略, 转移是显然的, 时间复杂度为 $\\Theta(n ^ 2 m)$. 考虑继续优化, 注意到 $0/1$ 单独占一个状态表示位非常浪费, 于是设 $f_{i, k} = j$ 表示在考虑 $s_{1 \\sim i}$ 的情况下, 想要表示 $k$, 至少还需要考虑 $t_{1 \\sim j}$. 依据前文策略, 考虑两种转移： 若 $k + a_{i + 1} \\leqslant m$, 则考虑是否选择 $a_{i + 1}$, 转移到 $f_{i + 1, k + a_{i + 1}}$ 和 $f_{i + 1, k}$. 若 $k &gt; 0$, 则考虑从 $\\{t_{i}\\}$ 中选择一个数进行转移, 注意到该下标 $p \\in [f_{i, k} + 1, f_{i - 1, k}]$. 关于 $p$ 的范围, 首先下界是显然的, 因为如果使用 $t_{f_{i, k}}$ 及之前的数可能会算重. 对于上界, $f_{i - 1, k}$ 进行同样转移时的下界即为 $f_{i - 1, k} + 1$, 又因为表示 $k$ 只需要 $s_{1 \\sim i - 1}$ 中的数即可, 若 $f_{i, k}$ 进行转移时使用了 $f_{i - 1, k}$ 转移时使用的同样的 $\\{t_{i}\\}$ 中的数, 那么一定是不优的, 故没有必要. 关于时间复杂度：第一种转移带来的时间复杂度为 $\\Theta(nm)$. 第二种转移中, 对于一个固定的 $k$, $p$ 的枚举至多遍历 $1 \\sim |\\{t_i\\}|$ 中每个数至多一遍, 于是该部分时间复杂度也为 $\\Theta(nm)$. 总时间复杂度为 $\\Theta(nm)$.","tags":"算法 oi 动态规划 背包"},{"title":"The 2024 ICPC St. Petersburg","url":"/2024/06/18/the-2024-icpc-st.petersburg/","text":"Solution of “The 2024 ICPC St. Petersburg”, and it also be kown as “The 3rd Universal Cup. Stage 1: St. Petersburg”. H 记 $f(x)$ 为将 $x$ 翻转后的数, 如 $f(123) = 321$. 给定 $n$, 求集合 $\\{f(1), f(2), \\cdots, f(n)\\}$ 中第一个没出现过的正整数. 显然为 $n + 1$ 和 $10$ 中的较小值. n = int(input()) print(min(n + 1, 10)) K 将字符串的对应关系反过来, 按数字从小到大输出, 详见样例. link = &#123;&#125; while True: try: key, values = input().split(&quot;: &quot;) values = values.split(&quot;, &quot;) link[key] = values except EOFError: break rev = &#123;&#125; for key, values in link.items(): for value in values: if value in rev: rev[value].append(key) else: rev[value] = [key] for key in sorted(rev.keys(), key = lambda x: int(x.split(&#x27;-&#x27;)[1])): values = rev[key] values.sort(key = lambda x: int(x.split(&#x27;-&#x27;)[1])) print(&quot;&#123;&#125;: &#123;&#125;&quot;.format(key, &quot;, &quot;.join(values))) O 长度为 $n$ 的序列 $\\{x_n\\}$ 存在递推关系 $x_{i+2} = ax_{i+1} + bx_i$, 给定 $a, b, n, x_1, x_n$, 要求还原这个序列. 注意到 $x_n$ 可以被表示为 $px_1 + qx_2$, 于是可以解出 $x_2$ 关于 $x_1$ 和 $x_n$ 的表达式. a, b, n, s, t = map(eval, input().split()) x = [(1, 0), (0, 1)] for i in range(2, n): x.append(tuple(a * p + b * q for p, q in zip(x[i - 1], x[i - 2]))) f = [s, (t - x[n - 1][0] * s) / x[n - 1][1]] for i in range(2, n): f.append(a * f[i - 1] + b * f[i - 2]) for x in f: print(x) C 给定长度为 $n$ 的序列 $\\{a_n\\}$ 和 $0/1$ 串 $s$. 求最大的 $x$, 满足仅保留 $s$ 中对应位 $a$ 值不小于 $x$ 的位后, $0/1$ 串中存在 $k$ 个连续的 1. 考虑从大到小将数加入, 用一棵线段树维护最大子段和, 若 $s_i = 1$ 则将该位设为 $1$, 否则设为 $-\\infty$. 时间复杂度 $\\Theta(n \\log n)$. #include &lt;bits/stdc++.h&gt; const int N = 1e5 + 10; int n, k, a[N], p[N]; std::string s; class SegmentTree &#123; private: class Node &#123; public: Node *lc, *rc; long long sum, lmax, rmax, max; Node (int l, int r) : lc(nullptr), rc(nullptr), sum(0), lmax(0), rmax(0), max(0) &#123;&#125; &#125; *root = nullptr; int limL, limR; void pushup (Node *p, int L, int R) &#123; int mid = L + R &gt;&gt; 1; if (p-&gt;lc == nullptr) p-&gt;lc = new Node(L, mid); if (p-&gt;rc == nullptr) p-&gt;rc = new Node(mid + 1, R); p-&gt;sum = p-&gt;lc-&gt;sum + p-&gt;rc-&gt;sum; p-&gt;lmax = std::max(p-&gt;lc-&gt;lmax, p-&gt;lc-&gt;sum + p-&gt;rc-&gt;lmax); p-&gt;rmax = std::max(p-&gt;rc-&gt;rmax, p-&gt;rc-&gt;sum + p-&gt;lc-&gt;rmax); p-&gt;max = std::max(p-&gt;lc-&gt;rmax + p-&gt;rc-&gt;lmax, std::max(p-&gt;lc-&gt;max, p-&gt;rc-&gt;max)); &#125; void upd (int pos, int k, Node *&amp;p, int L, int R) &#123; if (p == nullptr) p = new Node(L, R); if (pos &lt;= L and R &lt;= pos) &#123; p-&gt;sum = p-&gt;lmax = p-&gt;rmax = p-&gt;max = k; return; &#125; int mid = L + R &gt;&gt; 1; if (pos &lt;= mid) upd(pos, k, p-&gt;lc, L, mid); else upd(pos, k, p-&gt;rc, mid + 1, R); pushup(p, L, R); &#125; void del (Node* u) &#123; if (u-&gt;lc != nullptr) del(u-&gt;lc); if (u-&gt;rc != nullptr) del(u-&gt;rc); delete u; u = nullptr; &#125; public: SegmentTree (int l, int r) : limL(l), limR(r), root(nullptr) &#123;&#125; void upd (int pos, int k) &#123; upd(pos, k, root, limL, limR); &#125; int qry () &#123; if (root == nullptr) return 0; return root-&gt;max; &#125; ~SegmentTree () &#123; del(root); &#125; &#125;; int main () &#123; std::cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i], p[i] = i; std::sort(p + 1, p + n + 1, [&amp;](int i, int j) &#123; return a[i] &gt; a[j]; &#125;); std::cin &gt;&gt; s, s = &#x27; &#x27; + s; SegmentTree tree(1, n); for (int i = 1; i &lt;= n; i++) &#123; if (s[p[i]] == &#x27;1&#x27;) tree.upd(p[i], 1); else tree.upd(p[i], -1e9); if (a[p[i + 1]] != a[p[i]] and tree.qry() &gt;= k) return std::cout &lt;&lt; a[p[i]] &lt;&lt; &quot;\\n&quot;, 0; &#125; puts(&quot;0&quot;); return 0; &#125; D 这是一个交互题, 有 $n$ 个独立的问题. 每个问题形如: 有一个人在每天的 $1440$ 分钟中恰好睡固定的 $720$ 分钟, 你想知道他从什么时候开始睡觉. 你每次可以询问一个时刻, 并知道他在这一刻是醒着的还是睡着的. 在每个问题中最多进行 $50$ 次询问. def encode(t: int) -&gt; str: t %= 1440 ho = t // 60 mi = t % 60 return f&#x27;&#123;ho:02d&#125;:&#123;mi:02d&#125;&#x27; def ask(idx: int, t: int) -&gt; bool: print(f&#x27;at &#123;encode(t)&#125; check &#123;idx&#125;&#x27;, flush=True) res = input() return (res == &#x27;awake&#x27;) ans = [] if __name__ == &#x27;__main__&#x27;: T = int(input()) for idx in range(1, T + 1): resori = ask(idx, 0) l, r = 1, 720 while l &lt; r: mid = (l + r) // 2 if ask(idx, mid) == resori: l = mid + 1 else: r = mid if resori: l += 720 ans.append(l) print(&#x27;answer&#x27;) for t in ans: print(encode(t)) 以上是一份错误的代码, 提交上去会有莫名其妙的 RE, 在此仅作记录. J 给定 $2n$ 个正整数, 选出其中的一些使它们的和恰好为 $10^9$. 请注意, 数据用以下方式生成: 生成有 $n$ 个元素的正整数集 $\\mathbb{S}$, 其元素和为 $10^9$, 且对于所有元素集服从随机分布. 用相同的方式生成 $\\mathbb{T}$, 将两个集合合并为一个可重集作为最终输入. 该题的一个经典做法为, 随意将所有数分为两半, 求出其中一半能组合出的所有和存入 map. 然后枚举另一半能组合出的所有和 $s$, 在 map 中查询是否存在 $10^9 - s$ 即可. 该做法又被称为 meet in the middle. 容易发现, 上述做法最多处理到 $n$ 约为 $20$ 的情况, 于是我们不妨将所有数随机打包成至多 $40$ 个组, 每组中的数同时选择, 在这种情况下使用 meet in the middle. 考虑该做法的正确性: 由于本题特别的数据生成方式, 这 $40$ 个数能组合出的和差不多是在 $[n, 2 \\times 10^9]$ 内以某种中心集中的方式随机的. 注意到 $2^{40} \\gg 2 \\times 10^9$, 于是打包以后也几乎必然能找到一个解. #include &lt;bits/stdc++.h&gt; constexpr unsigned int b = 20, aim = 1e9; std::mt19937 gen(std::chrono::system_clock::now().time_since_epoch().count()); unsigned int n; std::map&lt;int, unsigned int&gt; exi; int main() &#123; std::cin &gt;&gt; n; std::vector a(n, 0); for (unsigned int i = 0; i &lt; n; i++) std::cin &gt;&gt; a[i]; std::vector S(b, std::vector(1, 0)), T(b, std::vector(1, 0)); for (unsigned int i = 0; i &lt; std::min(n, b &lt;&lt; 1); i++) if (i &amp; 1) T[i &gt;&gt; 1].push_back(i), T[i &gt;&gt; 1][0] += a[i]; else S[i &gt;&gt; 1].push_back(i), S[i &gt;&gt; 1][0] += a[i]; for (unsigned int i = (b &lt;&lt; 1); i &lt; n; i++) &#123; int opt = (gen() &amp; 1), pos = gen() % b; if (opt) S[pos].push_back(i), S[pos][0] += a[i]; else T[pos].push_back(i), T[pos][0] += a[i]; &#125; for (unsigned int R = 0; R &lt; (1 &lt;&lt; b); R++) &#123; int sum = 0; for (unsigned int i = 0; i &lt; b; i++) if ((R &gt;&gt; i) &amp; 1) sum += S[i][0]; exi[sum] = R; &#125; for (unsigned int R = 0; R &lt; (1 &lt;&lt; b); R++) &#123; int sum = 0; for (unsigned int i = 0; i &lt; b; i++) if ((R &gt;&gt; i) &amp; 1) sum += T[i][0]; if (exi.contains(aim - sum)) &#123; std::vector&lt;int&gt; ans; for (unsigned int i = 0; i &lt; b; i++) if ((R &gt;&gt; i) &amp; 1) for (unsigned int j = 1; j &lt; T[i].size(); j++) ans.push_back(T[i][j]); unsigned int P = exi[aim - sum]; for (unsigned int i = 0; i &lt; b; i++) if ((P &gt;&gt; i) &amp; 1) for (unsigned int j = 1; j &lt; S[i].size(); j++) ans.push_back(S[i][j]); std::cout &lt;&lt; ans.size() &lt;&lt; &quot; &quot;; for (int x : ans) std::cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot;; return 0; &#125; &#125; &#125; N","tags":"c++ 题解 python ucup xcpc"},{"title":"The 2024 ICPC North America Championship","url":"/2024/06/17/the-2024-icpc-north-america-championship/","text":"Solution of “The 2024 ICPC North America Championship”, and it also be kown as “The 3rd Universal Cup. Stage 0: Trial Contest”. D 给定一个长度为 $n$ 的环, 其能进行翻转和旋转, 问另一个长度为 $m$ 的串能否成为它的子串. 注意到最多翻转一次, 且等价于将原序列逆序. 于是定位 $b_1$ 在 $\\{a_n\\}$ 中的位置然后分别向左向右查找即可. 时间复杂度 $\\Theta(n)$. def check (): for pos in range(n): if a[pos] == b[0]: for i in range(m): if (a[(pos + i) % n] != b[i]): return False break return True if __name__ == &quot;__main__&quot;: n, m = map(int, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) if check(): print(&#x27;1&#x27;) else: a.reverse() if check(): print(&#x27;1&#x27;) else: print(&#x27;0&#x27;) A 有 $n$ 个物品, 每个物品在 $A$ 手中有 $a_i$ 的价值, 在 $B$ 手中有 $b_i$ 的价值, 最小化 $A, B$ 手中价值和的较大值. 设 $f_{i, j}$ 表示考虑前 $i$ 个物品, 此时 $A$ 手中的价值和为 $j$, $B$ 手中价值和的最小值. 转移考虑第 $i$ 个物品给 $A$ 还是 $B$ 即可. 时间复杂度 $\\Theta(n^2\\max\\{a_i, b_i\\})$. #include &lt;bits/stdc++.h&gt; const int N = 52, M = 1e5 + 5; int n, a[N], b[N], suma, sumb; int main () &#123; std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i] &gt;&gt; b[i], suma += a[i], sumb += b[i]; std::vector&lt;std::vector&lt;int&gt;&gt; f(n + 1, std::vector&lt;int&gt;(suma + 1, N * M)); f[0][suma] = 0; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= suma; j++) &#123; f[i][j] = f[i - 1][j]; if (j &lt;= suma - a[i]) f[i][j] = std::min(f[i][j], f[i - 1][j + a[i]] + b[i]); &#125; int ans = N * M; for (int j = 0; j &lt;= suma; j++) ans = std::min(ans, std::max(j, f[n][j])); std::cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0; &#125; J 有 $n$ 个物品, 第 $i$ 个物品占据一个长度为 $a_i$ 的区间. 一开始空白区间长度为 $p$, 从第 $1$ 个物品开始, 依次令每个物品选择一个完全空白的区间并占据, 问最坏情况下到第几个物品无法找到可以占据的区间. 注意到若答案为 $i$, 则至多需要 $i(a_i - 1) + \\sum\\limits_{j &lt; i}a_j + 1$ 的空间. 若 $p$ 小于这个值则到第 $i$ 个物品放不下. 时间复杂度 $\\Theta(n)$. if __name__ == &quot;__main__&quot;: n, p = map(int, input().split()) a = [int(input()) for _ in range(n)] sum = 0 for i in range(n): if p &lt;= (i + 1) * (a[i] - 1) + sum: print(i); exit(0) sum += a[i] print(n) G 存在 $n \\times m$ 的网格, 每个格子一开始随机等概率指向右或下, 且每个格子上都有一个计时器, 其值随机等概率取 $[0, p]$ 中的实数, 计时器归零时指向会改变, 然后其值重新变为 $p$. 现在你要从 $(1, 1)$ 走到 $(n, m)$, 每走到一个格子可以选择沿着它的指向前进或等待计时器归零再前往另一个方向, 需要注意的是你只有到达一个格子的时候才能知道格子的指向和计时器值, 求最优策略下走完的期望等待时间. 设 $f_{i, j}$ 表示从 $(i, j)$ 出发的期望时间. 注意到所有格子的决策都是独立的, 于是考虑求 $f_{i, j}$. 设 $f_{i + 1, j}$ 和 $f_{i, j + 1}$ 是 $a, b(a \\leqslant b)$. 若 $b \\geqslant a + p$, 则一定选择走 $a$ 的方向, 有 $f_{i, j} = a + \\frac{p}{4}$. 若 $b &lt; a + p$, 有 $f_{i, j} = \\frac{a}{2} + \\frac{(p - b + a)b}{2p} + \\frac{(b - a)(a + b)}{4p}$. 若当前指向 $a$, 则走 $a$, 概率为 $\\frac{1}{2}$, 贡献为 $a$. 若到 $a$ 的计时器大于 $b - a$, 则走 $b$, 概率为 $\\frac{p - (b - a)}{2p}$, 贡献为 $b$. 若到 $a$ 的计时器不大于 $b - a$, 则走 $a$, 概率为 $\\frac{b - a}{2p}$, 贡献为 $a + \\frac{b - a}{2}$. 特别的, 若 $i = n$ 或 $j = m$, 则只有一个方向可以转移, 设其期望为 $e$, 有 $f_{i, j} = e + \\frac{p}{4}$. 时间复杂度 $\\Theta(nm)$. n, m, p = map(int, input().split()) f = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n, 0, -1): for j in range(m, 0, -1): if i == n and j == m: continue if i == n: f[i][j] = f[i][j + 1] + p / 4 elif j == m: f[i][j] = f[i + 1][j] + p / 4 else: a, b = min(f[i + 1][j], f[i][j + 1]), max(f[i + 1][j], f[i][j + 1]) if b &gt;= a + p: f[i][j] = a + p / 4 else: f[i][j] = a / 2 + ((p - b + a) * b) / (2 * p) + ((b - a) * (a + b)) / (4 * p) print(f[1][1]) H 如图所示, 每座山都是三角形, 用其顶点坐标代替. 有 $q$ 次操作, 每次加入或者删除一座山, 动态维护从上到下能看到的线条长度. 注意到线条长度等于 $\\sqrt 2$ 倍的横坐标长度, 于是一座山 $(x, y)$ 转化为一个区间 $[x - y, x + y]$, 用动态开点线段树维护区间最小值和其数量即可. 时间复杂度 $\\Theta(q\\log w)$. #include &lt;bits/stdc++.h&gt; class SegmentTree &#123; private: class Node &#123; public: Node *lc, *rc; int min, cnt, lazy; Node (int l, int r) : lc(nullptr), rc(nullptr), min(0), cnt(r - l + 1), lazy(0) &#123;&#125; &#125; *root = nullptr; int limL, limR; void pushdown (Node *p, int L, int R) &#123; if (p-&gt;lazy == 0) return; int mid = L + R &gt;&gt; 1; if (p-&gt;lc == nullptr) p-&gt;lc = new Node(L, mid); p-&gt;lc-&gt;min += p-&gt;lazy, p-&gt;lc-&gt;lazy += p-&gt;lazy; if (p-&gt;rc == nullptr) p-&gt;rc = new Node(mid + 1, R); p-&gt;rc-&gt;min += p-&gt;lazy, p-&gt;rc-&gt;lazy += p-&gt;lazy; p-&gt;lazy = 0; &#125; std::pair&lt;int, int&gt; merge (std::pair&lt;int, int&gt; a, std::pair&lt;int, int&gt; b) &#123; int min = std::min(a.first, b.first), cnt = 0; if (a.first == min) cnt += a.second; if (b.first == min) cnt += b.second; return std::make_pair(min, cnt); &#125; void upd (int l, int r, int k, Node *&amp;p, int L, int R) &#123; if (p == nullptr) p = new Node(L, R); if (l &lt;= L and R &lt;= r) &#123; p-&gt;min += k, p-&gt;lazy += k; return; &#125; pushdown(p, L, R); int mid = L + R &gt;&gt; 1; if (l &lt;= mid) upd(l, r, k, p-&gt;lc, L, mid); if (r &gt;= mid + 1) upd(l, r, k, p-&gt;rc, mid + 1, R); if (p-&gt;lc == nullptr and p-&gt;rc == nullptr) std::tie(p-&gt;min, p-&gt;cnt) = std::make_pair(0, R - L + 1); else if (p-&gt;lc == nullptr) std::tie(p-&gt;min, p-&gt;cnt) = std::make_pair(0, mid - L + 1 + p-&gt;rc-&gt;cnt * (p-&gt;rc-&gt;min == 0)); else if (p-&gt;rc == nullptr) std::tie(p-&gt;min, p-&gt;cnt) = std::make_pair(0, R - mid + p-&gt;lc-&gt;cnt * (p-&gt;lc-&gt;min == 0)); else std::tie(p-&gt;min, p-&gt;cnt) = merge(std::make_pair(p-&gt;lc-&gt;min, p-&gt;lc-&gt;cnt), std::make_pair(p-&gt;rc-&gt;min, p-&gt;rc-&gt;cnt)); &#125; std::pair&lt;int, int&gt; qry (int l, int r, Node *p, int L, int R) &#123; if (p == nullptr) return std::make_pair(0, std::min(r, R) - std::max(l, L) + 1); if (l &lt;= L and R &lt;= r) return std::make_pair(p-&gt;min, p-&gt;cnt); pushdown(p, L, R); int mid = L + R &gt;&gt; 1; auto res = std::make_pair(INT_MAX, 0); if (l &lt;= mid) res = merge(res, qry(l, r, p-&gt;lc, L, mid)); if (r &gt;= mid + 1) res = merge(res, qry(l, r, p-&gt;rc, mid + 1, R)); return res; &#125; public: SegmentTree (int l, int r) : limL(l), limR(r), root(nullptr) &#123;&#125; void upd (int l, int r, int k) &#123; upd(l, r, k, root, limL, limR); &#125; std::pair&lt;int, int&gt; qry (int l, int r) &#123; return qry(l, r, root, limL, limR); &#125; &#125;; int q, w, x, y; std::set&lt;std::pair&lt;int, int&gt;&gt; S; int main () &#123; std::cin &gt;&gt; q &gt;&gt; w; SegmentTree tree(0, w - 1); while (q--) &#123; std::cin &gt;&gt; x &gt;&gt; y; if (S.find(std::make_pair(x, y)) != S.end()) tree.upd(std::max(0, x - y), std::min(x + y - 1, w - 1), -1), S.erase(std::make_pair(x, y)); else tree.upd(std::max(0, x - y), std::min(x + y - 1, w - 1), 1), S.insert(std::make_pair(x, y)); auto ans = tree.qry(0, w - 1); std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; sqrt(2) * (w - ans.second * (ans.first == 0)) &lt;&lt; &quot;\\n&quot;; &#125; return 0; &#125; I 给定长度为 $n$ 的字符串, 你需要将其中的 ? 改成 N/A/C 之一, 使最终的字符串中恰好存在 $k$ 个 NAC 作为子序列. 设 $f_{i, N, C, k}$ 表示考虑了长度为 $i$ 的前缀中的 A 的贡献, 前缀中 N 的数量为 $N$, 后缀中 C 的数量为 $C$ 时, 能否恰有 $k$ 个 NAC 作为子序列. 转移时枚举变成什么即可, 可以用 bitset 优化. 时间复杂度 $\\Theta(\\frac{n^3k}{\\omega})$. #include &lt;bits/stdc++.h&gt; const int N = 50; int n, k; char s[N], ans[N]; std::bitset&lt;2600&gt; f[N][N][N]; int main() &#123; scanf(&quot;%d%d%s&quot;, &amp;n, &amp;k, s + 1); for (int i = 0; i &lt;= n; i++) f[0][0][i][0] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= i; j++) for (int k = 0; k &lt;= n - i + 1; k++) &#123; if ((s[i] == &#x27;N&#x27; or s[i] == &#x27;?&#x27;) and j &gt;= 1) f[i][j][k] |= f[i - 1][j - 1][k]; if (s[i] == &#x27;A&#x27; or s[i] == &#x27;?&#x27;) f[i][j][k] |= (f[i - 1][j][k] &lt;&lt; (j * k)); if ((s[i] == &#x27;C&#x27; or s[i] == &#x27;?&#x27;) and k + 1 &lt;= n) f[i][j][k] |= f[i - 1][j][k + 1]; if ((s[i] != &#x27;N&#x27; and s[i] != &#x27;A&#x27; and s[i] != &#x27;C&#x27;) or s[i] == &#x27;?&#x27;) f[i][j][k] |= f[i - 1][j][k]; &#125; for (int i = 0; i &lt;= n; i++) &#123; if (f[n][i][0][k]) &#123; int p = i, q = 0, r = k; for (int i = n; i &gt;= 1; i--) &#123; if ((s[i] == &#x27;N&#x27; or s[i] == &#x27;?&#x27;) and p &gt;= 1 and f[i - 1][p - 1][q][r]) ans[i] = &#x27;N&#x27;, p--; else if ((s[i] == &#x27;A&#x27; or s[i] == &#x27;?&#x27;) and r - p * q &gt;= 0 and f[i - 1][p][q][r - p * q]) ans[i] = &#x27;A&#x27;, r -= p * q; else if ((s[i] == &#x27;C&#x27; or s[i] == &#x27;?&#x27;) and q + 1 &lt;= n and f[i - 1][p][q + 1][r]) ans[i] = &#x27;C&#x27;, q++; else if (s[i] == &#x27;?&#x27;) ans[i] = &#x27;B&#x27;; else ans[i] = s[i]; &#125; ans[n + 1] = 0; printf(&quot;%s\\n&quot;, ans + 1); return 0; &#125; &#125; puts(&quot;-1&quot;); return 0; &#125; M 存在 $n$ 个任务, 每个任务包含两个区间. 一开始有能力值 $a$ 和 $b$, 按顺序遍历 $n$ 个任务, 对每个任务可以选择跳过, 或解决后使 a++ 或 b++. 问最多能解决多少个任务. 一个自然的想法是设 $f_{i, j}$ 表示能否恰好执行 $i$ 次 a++ 和 $j$ 次 b++. 转移时枚举每个任务, 枚举每个值为 $1$ 的 $f_{i \\in [a_l - a, a_r - a], j \\in [b_l - b, b_r - b]}$, 将 $f_{i + 1, j}$ 和 $f_{i, j + 1}$ 置为 $1$. 答案为最大的 $i + j$, 满足 $f_{i, j} = 1$. 时间复杂度 $\\Theta(n ^ 3)$. 注意到一个二元组 $(i, j)$ 对应的 $f_{i, j}$ 被置为 $1$ 后就不会变了, 于是考虑利用这个势能限制复杂度. 维护已经被置为 $1$ 但还未用其更新其它 $f$ 值的二元组集 $S$, 每次更新将满足 $i \\in [a_l - a, a_r - a]$ 和 $j \\in [b_l - b, b_r - b]$ 的二元组从 $S$ 中取出, 然后将它们能更新到的二元组置为 $1$ 并加入 $S$. 对于每个二元组, 它最多加入 $S$ 一次, 从 $S$ 中被删除一次, 单次操作的时间复杂度为 $\\Theta(\\log n)$, 于是总时间复杂度为 $\\Theta(n^2\\log n)$, 具体实现可以对每个 $i$ 维护它对应的 $j$ 的集合. #include &lt;bits/stdc++.h&gt; const int N = 5e3 + 5; int n, a, b, ans; bool f[N][N]; std::set&lt;int&gt; S[N]; std::vector&lt;std::pair&lt;int, int&gt;&gt; upd; int main () &#123; std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; f[0][0] = true, S[0].insert(0); for (int al, ar, bl, br, p = 1; p &lt;= n; p++) &#123; std::cin &gt;&gt; al &gt;&gt; ar &gt;&gt; bl &gt;&gt; br; upd.clear(); for (int i = std::max(0, al - a); i &lt;= std::min(p, ar - a); i++) &#123; auto l = S[i].lower_bound(std::max(0, bl - b)); if (l != S[i].end()) &#123; auto r = S[i].upper_bound(std::min(p, br - b)); for (auto it = l; it != r; it++) &#123; if (not f[i + 1][*it]) f[i + 1][*it] = true, upd.push_back(std::make_pair(i + 1, *it)); if (not f[i][(*it) + 1]) f[i][(*it) + 1] = 1, upd.push_back(std::make_pair(i, (*it) + 1)); &#125; S[i].erase(l, r); &#125; &#125; for (auto x : upd) S[x.first].insert(x.second), ans = std::max(ans, x.first + x.second); &#125; std::cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0; &#125;","tags":"c++ 题解 python ucup xcpc"},{"title":"24 高考新 I 卷数学 19(3)","url":"/2024/06/08/24-xin-gao-kao-i-juan-shu-xue-19-3/","text":"对 $m = 1, 2$, 取几组合法 $(i, j)$ 即证. 对 $m \\geqslant 3$, 设 $f_m$ 表示 $a_{1 \\sim 4m + 2}$ 中能取出的合法数对数量. 注意到 $a_{1 \\sim 4m + 2}$ 中任意长度为 $4l + 2$ 的子区间对应的答案均为 $f_l$, 则取分界点 $p_1 = 4, p_2 = 4m - 2$​ 进行容斥. $$\\begin{aligned} f_m &amp;= f_m[i \\not\\in [1, p_1]~\\textrm{or}~j \\not\\in [p_2 + 1, 4m + 2]] + f_m[i \\in [1, p_1]~\\textrm{and}~j \\in [p_2 + 1, 4m + 2]]\\\\ &amp;= f_m[i, j \\in [p_1 + 1, 4m + 2]] + f_m[i, j \\in [1, p_2]] - f_m[i, j \\in [p_1 + 1, p_2]] \\\\&amp;~~~~+ f_m[i \\in [1, p_1]~\\textrm{and}~j \\in [p_2 + 1, 4m + 2]]\\\\ &amp;= 2f_{m - 1} - f_{m - 2} + f_m[i \\in [1, p_1]~\\textrm{and}~j \\in [p_2 + 1, 4m + 2]] \\end{aligned} $$考虑求 $f_m[i \\in [1, p_1]~\\textrm{and}~j \\in [p_2 + 1, 4m + 2]]$ 的下界. 显然 $(i, j) = (1, 4m + 2)$ 是合法的. 对于 $(i, j) = (2, 4m + 1)$, 当 $m = 3$ 时其合法性在第 $(2)$ 问中已证. 当 $m &gt; 3$ 时, 从前后各取 $2$ 个下标公差为 $2$ 的子序列, 注意到只看子区间 $[9, 4m - 6]$, 其中 $10$ 和 $4m - 7$ 已经被取过了, 于是变成了等价的子问题. 故归纳可证 $(i, j) = (2, 4m + 1)$ 是合法的. 此时有 $f_m[i \\in [1, p_1]~\\textrm{and}~j \\in [p_2 + 1, 4m + 2]] \\geqslant 2$, 于是 $f_m \\geqslant 2f_{m - 1} - f_{m - 2} + 2$. 取 $f'_m = 2f'_{m - 1} - f'_{m - 2} + 2 \\leqslant f_m, f'_1 = 3, f'_2 = 7$. 变换得 $(f'_m - f'_{m - 1}) = (f'_{m - 1} - f'_{m - 2}) + 2$, 由熟知的方法解得 $f_m \\geqslant f'_m = m ^ 2 + m + 1$. 于是 $P_m = \\frac{f_m}{\\binom{4m + 2}{2}} \\geqslant \\frac{f'_m}{\\binom{4m + 2}{2}} = \\frac{m ^ 2 + m + 1}{8m^2 + 6m + 1} &gt; \\frac{1}{8}$, 原命题得证.","tags":"题解 数学 高考"},{"title":"关于「顺序遍历随机排列取尽可能大的值」问题的一些思考","url":"/2024/04/11/guan-yu-shun-xu-bian-li-sui-ji-pai-lie-qu-jin-ke-neng-da-de-zhi-wen-ti-de-yi-xie-si-kao/","text":"一个广为流传的结论是: 从前往后遍历 $37\\%$ 的元素(事实上是 $\\frac{1}{e}$), 称其中最大的为 $\\max$, 继续往后遍历, 一旦一个元素大于 $\\max$ 就立刻选择, 找不到则选最后一个元素 . 写了一个程序来验证这个结论: import random import matplotlib.pyplot as draw n, t = map(int, input().split()) # n, t = 1000, 100000 p = [i for i in range(n)] aveval = [0 for _ in range(n)] maxval = [0 for _ in range(n)] def calcave (pos): Max = -1 for i in range(pos): Max = max(Max, p[i]) for i in range(pos, n): if p[i] &gt; Max: return p[i] return p[n - 1] def calcmax (pos): Max = -1 for i in range(pos): Max = max(Max, p[i]) for i in range(pos, n): if p[i] &gt; Max: return (p[i] == n - 1) return (p[n - 1] == n - 1) for _ in range(t): random.shuffle(p) for i in range(n): aveval[i] += calcave(i) for i in range(n): maxval[i] += calcmax(i) aveval = list(map(lambda x: x / t / n, aveval)) maxval = list(map(lambda x: x / t, maxval)) draw.plot([100 / n * i for i in range(n)], aveval) draw.plot([100 / n * i for i in range(n)], maxval) idx, val = 0, 0 for i in range(n): if aveval[i] &gt; val: val, idx = aveval[i], 100 / n * i draw.plot(idx, val, &#x27;or&#x27;) draw.text(idx, val, &quot;(&#123;:.1f&#125;%, &#123;:.2f&#125;)&quot;.format(idx, val), color = &#x27;r&#x27;) idx, val = 0, 0 for i in range(n): if maxval[i] &gt; val: val, idx = maxval[i], 100 / n * i draw.plot(idx, val, &#x27;or&#x27;) draw.text(idx, val, &quot;(&#123;:.1f&#125;%, &#123;:.2f&#125;)&quot;.format(idx, val), color = &#x27;r&#x27;) draw.show() 得到结果如下: 其中蓝线为这种策略取到的元素大小期望除以 $n$ 的值, 也即取到的元素占最大值百分比的期望. 橙线表示取到最大值的概率. 横坐标为观察的元素数量占总元素数量的比例. 可以发现, 虽然观察 $37.1\\%$ 的元素有最大的概率取到最大值, 但只观察 $3.1\\%$ 的元素就出手获得的元素期望是最大的, 这启发我们, 直接取某一个位置之后的第一个前缀最大值是否有些呆板了呢? 我们是否可以做一些更加动态的决策呢? 接下来会尝试训练一个神经网络用以决策, 未完待续……","tags":"数学 python 期望 37%-法则"},{"title":"整除性校验的本质","url":"/2024/04/09/zheng-chu-xing-jian-yan-de-ben-zhi/","text":"从小学开始我们就知道, 一个数能被 $3$ 整除当且仅当其各位数字之和能被 $3$ 整除. 一个数能被 $4$ 整除, 当且仅当其最后 $2$ 位数能被 $4$ 整除. 一个数能被 $11$ 整除, 当且仅当其奇数位减去偶数位数字之和能被 $11$ 整除(个位数记为第 $1$ 位). 长大一点后, 我们可以用数学语言来刻画这个规律 : $$\\begin{cases} \\overline{a_ta_{t - 1}\\cdots a_2a_1} \\equiv a_1 + a_2 + \\cdots + a_t \\pmod 3 \\\\ \\overline{a_ta_{t - 1}\\cdots a_2a_1} \\equiv \\overline{a_2a_2} \\pmod 4 \\\\ \\overline{a_ta_{t - 1}\\cdots a_2a_1} \\equiv a_1 - a_2 + a_3 - \\cdots + (-1)^{t - 1} a_t \\pmod {11} \\\\ \\overline{a_ta_{t - 1}\\cdots a_2a_1} \\equiv \\overline{a_3a_2a_1} - \\overline{a_6a_5a_4} + \\cdots + (-1)^{\\frac{t}{3} - 1} \\overline{a_ta_{t - 1}a_{t - 2}} \\pmod 7 \\end{cases} $$容易发现, 其分为 $3$ 类 : 第一类: $x$ 与 $x$ 的末 $k$ 位在模 $n$ 意义下同余. 第二类: $x$ 与 $x$ 每 $k$ 位一段求和得到的数在模 $n$ 意义下同余. 第三类: $x$ 与 $x$ 每 $k$ 位一段正负交替求和得到的数在模 $n$ 意义下同余. 现在我们来探寻 $b$ 进制数在模 $n$ 意义下可以使用哪种同余化简方式(或不满足三类中任意一种). 若存在 $k$ 满足 $b ^ k \\equiv 0 \\pmod n$, 那么 $\\overline{a_ta_{t - 1}\\cdots a_{k + 1}00 \\cdots 0} \\equiv 0 \\pmod n$, 则 $\\overline{a_ta_{t - 1}\\cdots a_2a_1} \\equiv \\overline{a_ka_{k - 1}\\cdots a_2a_1} \\pmod n$, 可以使用第一类化简方式. 若存在 $k$ 满足 $b ^ k \\equiv 1 \\pmod n$, 那么 $\\overline{a_ta_{t - 1}\\cdots a_{k + 1}00 \\cdots 0} \\equiv \\overline{a_ta_{t - 1}\\cdots a_{k + 1}} \\pmod n$, 则 $\\overline{a_ta_{t - 1}\\cdots a_2a_1} \\equiv \\overline{a_ka_{k - 1}\\cdots a_1} + \\overline{a_{2k}a_{2k - 1}\\cdots a_{k + 1}} + \\cdots \\pmod n$, 可以使用第二类化简方式. 若存在 $k$ 满足 $b ^ k \\equiv -1 \\pmod n$, 那么 $\\overline{a_{pk}a_{pk - 1}\\cdots a_{(p - 1)k + 1} 00\\cdots 0} \\equiv (-1) ^ p\\overline{a_{pk}a_{pk - 1}\\cdots a_{(p - 1)k + 1}}$, 则 $\\overline{a_ta_{t - 1}\\cdots a_2a_1} \\equiv \\overline{a_ka_{k - 1}\\cdots a_1} - \\overline{a_{2k}a_{2k - 1}\\cdots a_{k + 1}} + \\cdots \\pmod n$, 可以使用第三类化简方式. 于是想找到 $b$ 进制数在模 $n$ 意义下的化简方式, 只需要找到最小的 $k$ 满足 $b ^ k \\equiv 0~\\textrm{or}~1~\\textrm{or}- 1$ 即对应第 $1/2/3$ 类化简方式. 若直到 $k$ 等于 $b$ 的幂在模 $n$ 意义下的循环节长度仍未找到满足条件的 $k$, 则 $b$ 进制数在模 $n$ 意义下不能使用这 $3$ 种方式化简. 一种找最小 $k$ 的代码实现如下 : #include &lt;bits/stdc++.h&gt; using namespace std; int T, b, n; unordered_map &lt;int, bool&gt; vis; int main () &#123; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d%d&quot;, &amp;b, &amp;n), b %= n; int a = 0, k = 1, tmp = b; while (b != 0 &amp;&amp; b != 1 &amp;&amp; b != n - 1 &amp;&amp; !vis[b]) &#123; vis[b] = true; b = 1ll * b * tmp % n, k++; &#125; if (b == 0) a = 1; if (b == 1) a = 2; if (b == n - 1) a = 3; a ? printf(&quot;kind = %d, k = %d\\n&quot;, a, k) : puts(&quot;0&quot;); vis.clear(); &#125; return 0; &#125;","tags":"c++ 数学 新的思考 数论 整除性检验"},{"title":"一类贝叶斯定理相关积分的变换技巧","url":"/2024/04/09/yi-lei-bei-xie-si-ding-li-xiang-guan-ji-fen-de-bian-huan-ji-qiao/","text":"考虑非负实数域上某可用条件概率刻画的期望： $$E(x) = \\int_{0}^{+\\infty} xP(t = x|q) \\mathrm{d}x $$其中 $q$ 为已知，且 $P(q|t = x)$ 是可用初等函数刻画的，于是： 考虑贝叶斯定理： $$E(x) = \\int_{0}^{+\\infty} x\\frac{P(q|t = x)P(t = x)}{P(q)} \\mathrm{d}x $$观察发现对 $x$ 微分本质上就是在枚举每个 $t = x$ 的情况，于是 $P(t = x)$ 已经被 $\\mathrm{d}x$ 包含，可以看作 $1$，故 $$E(x) = \\int_{0}^{+\\infty} x\\frac{P(q|t = x)}{P(q)} \\mathrm{d}x $$大多数情况下，哪怕 $P(q)$ 可以用初等函数刻画，整个式子也会难以化简，于是考虑拆 $P(q)$： $$E(x) = \\int_{0}^{+\\infty} x\\frac{P(q|t = x)}{\\int_{0}^{+\\infty} P(q|t = y) \\mathrm{d}y } \\mathrm{d}x $$整理可得 $$E(x) = \\frac{\\int_{0}^{+\\infty} xP(q|t = x) \\mathrm{d}x}{\\int_{0}^{+\\infty} P(q|t = x) \\mathrm{d}x } $$设 $P(q|t = x) = f(x)$，其中 $f(x)$ 是初等函数，又设 $\\delta$ 为积分算子（即 $[\\delta f(x)]' = f(x)$ ），即得 $$E(x) = \\frac{\\int_{0}^{+\\infty} xf(x) \\mathrm{d}x}{\\int_{0}^{+\\infty} f(x) \\mathrm{d}x } = \\lim_{\\varepsilon \\to 0^+}^{m \\to +\\infty}\\frac{\\delta mf(m) - \\delta \\varepsilon f(\\varepsilon)}{\\delta f(m) - \\delta f(\\varepsilon)} $$","tags":"数学 概率与期望 新的思考 贝叶斯定理 微积分"},{"title":"2024 年 2~3 月趣题记录","url":"/2024/04/09/2024-nian-2-3-yue-qu-ti-ji-lu/","text":"$\\rm CF1929D$ $\\rm (^*1974)$ 给定一颗 $n$ 个点的树, 求黑白染色的方案数, 使任意一条路径上的黑点数量不超过 $2$. $2 \\leqslant n \\leqslant 3 \\times 10 ^ 5, \\mathrm{mod} = 998244353$. 最自然的想法肯定是设 $f_{u, 0/1/2}$ 表示考虑以 $u$ 为根的子树, 所有从 $u$ 到叶子的链中, 包含黑点数量最大的恰好为 $0/1/2$ 的方案数. 转移考虑 $u$ 是否为黑点进行分类讨论即可. 但出题人给出了一种另辟蹊径的做法, 设 $f_u$ 表示考虑以 $u$ 为根的子树, 所有从 $u$ 到叶子的链中, 包含黑点数量最大的恰好为 $1$ 的方案数. 设 $v \\in son_u$, 则所有 $v$ 的染色方案互不干扰, 故有 $f_u = \\prod (f_v + 1)$. 考虑如何计算被漏掉的, 存在黑色点对 $(u, v)$ 满足 $u$ 是 $v$ 的祖先的情况. 我们发现如果枚举 $u$, $\\sum_{v \\in son_u} f_v$ 即为点对 $(u, v)$ 的数量, 若枚举所有 $u$, 则 $2 \\sim n$ 号结点恰好均被计算一次. 再加上不存在黑色点对 $(u, v)$ 满足 $u$ 是 $v$ 的祖先的情况 $f_1 + 1$, 答案即为 $1 + \\sum f_u$. 该算法时间复杂度 $\\Theta(n)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 3e5 + 10, mod = 998244353; int T, n, f[N]; vector &lt;int&gt; E[N]; void dfs (int u, int fa) &#123; f[u] = 1; for (int v : E[u]) if (v != fa) dfs(v, u), f[u] = 1ll * f[u] * (f[v] + 1) % mod; &#125; int main () &#123; ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int u, v, i = 1; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v; E[u].push_back(v), E[v].push_back(u); &#125; dfs(1, 0); int ans = 0; for (int i = 1; i &lt;= n; i++) ans = (ans + f[i]) % mod; cout &lt;&lt; (ans + 1) % mod &lt;&lt; &quot;\\n&quot;; for (int i = 1; i &lt;= n; i++) E[i].clear(); &#125; return 0; &#125; $\\rm CF1929E$ $\\rm (^*2414)$ 有一棵 $n$ 个顶点的树, 对于其上 $k$ 对顶点 $(a_1, b_1), \\ldots, (a_k, b_k)$ 中的任意一对, 在顶点 $a_i$ 与 $b_i$ 之间的简单路径上至少有一条边为黑色. 为了满足该条件, 求树上最少有多少条黑色边. $n \\leqslant 10 ^ 5, k \\leqslant 20$. 注意到选择的边一定是至少一条路径上深度最浅的边. 证明: 选深度最浅的边更劣, 当且仅当可以构造出两条路径 $L_1,L_2$ 在某条边 $e$ 处相交, 且满足: $e$ 不是 $L_1, L_2$ 最浅的边. $e$ 的父边不同时属于 $L_1, L_2$​. 否则 $e$ 用其父边替换一定不劣. 但是, 若 $e$ 不是 $L$ 最浅的边, 则 $e$ 的父边一定属于 $L$, 故 $e$ 的父边同时属于 $L_1, L_2$, 产生矛盾, 故原命题得证. 因此我们发现, 该树中可能成为答案的边最多 $2k$ 条, 且每条边 $e$ 分别对应了一个集合 $S$, 满足 $\\forall L \\in S, e \\in L$. 考虑记 $T_i$ 表示第 $i$ 条有可能成为答案的边属于哪些路径, $f_S$ 表示将 $S$ 表示的路径全部覆盖至少需要选择多少条边, 转移时枚举选择哪条边加入即可, 方程为 $f_{S | T_i} = \\min\\{f_S + 1\\}$. 总时间复杂度 $\\Theta(nk + k2 ^ k)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5 + 10, K = 22; int T, n, k, a[K], b[K], dep[N], fa[N], f[1 &lt;&lt; K]; vector &lt;int&gt; E[N]; map &lt;pair&lt;int, int&gt;, int&gt; tag, M; void dfs (int u, int f) &#123; fa[u] = f, dep[u] = dep[f] + 1; for (int v : E[u]) if (v != f) dfs(v, u); &#125; int main () &#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int u, v, i = 1; i &lt; n; i++) cin &gt;&gt; u &gt;&gt; v, E[u].push_back(v), E[v].push_back(u); cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) cin &gt;&gt; a[i] &gt;&gt; b[i]; dfs(1, 0); for (int i = 0; i &lt; k; i++) &#123; int u = a[i + 1], v = b[i + 1]; while (dep[u] &gt; dep[v] &amp;&amp; fa[u] != v) u = fa[u]; while (dep[v] &gt; dep[u] &amp;&amp; fa[v] != u) v = fa[v]; if (fa[u] == v) &#123; tag[make_pair(v, u)] |= 1 &lt;&lt; i; continue; &#125; if (fa[v] == u) &#123; tag[make_pair(u, v)] |= 1 &lt;&lt; i; continue; &#125; while (fa[u] != fa[v]) u = fa[u], v = fa[v]; tag[make_pair(fa[u], u)] |= 1 &lt;&lt; i; tag[make_pair(fa[v], v)] |= 1 &lt;&lt; i; &#125; for (int i = 0; i &lt; k; i++) &#123; int u = a[i + 1], v = b[i + 1]; while (dep[u] &gt; dep[v] &amp;&amp; fa[u] != v) &#123; if (tag[make_pair(fa[u], u)]) M[make_pair(fa[u], u)] |= 1 &lt;&lt; i; u = fa[u]; &#125; while (dep[v] &gt; dep[u] &amp;&amp; fa[v] != u) &#123; if (tag[make_pair(fa[v], v)]) M[make_pair(fa[v], v)] |= 1 &lt;&lt; i; v = fa[v]; &#125; if (fa[u] == v) &#123; M[make_pair(v, u)] |= 1 &lt;&lt; i; continue; &#125; if (fa[v] == u) &#123; M[make_pair(u, v)] |= 1 &lt;&lt; i; continue; &#125; while (fa[u] != fa[v])&#123; if (tag[make_pair(fa[u], u)]) M[make_pair(fa[u], u)] |= 1 &lt;&lt; i; if (tag[make_pair(fa[v], v)]) M[make_pair(fa[v], v)] |= 1 &lt;&lt; i; u = fa[u], v = fa[v]; &#125; M[make_pair(fa[u], u)] |= 1 &lt;&lt; i; M[make_pair(fa[v], v)] |= 1 &lt;&lt; i; &#125; int lim = 1 &lt;&lt; k; for (int S = 1; S &lt; lim; S++) f[S] = 1e9; for (int S = 0; S &lt; lim; S++) for (auto it : M) f[S | it.second] = min(f[S | it.second], f[S] + 1); cout &lt;&lt; f[lim - 1] &lt;&lt; &quot;\\n&quot;; for (int i = 1; i &lt;= n; i++) E[i].clear(); M.clear(); &#125; return 0; &#125; $\\rm ABC341G$ $\\rm (^*2208)$ 给定长度为 $n$ 的序列 $\\{a_n\\}$, 对每个整数 $k \\in [1, n]$, 求 $\\max_{r \\geqslant k} \\left\\{\\frac{1}{r - k + 1}\\sum _{i = k}^r a_i\\right\\}$. $n \\leqslant 2 \\times 10 ^ 5, \\forall i, a_i \\leqslant 10 ^ 6$. 考虑将平均数转化为直线的斜率, 构造平面上如下 $n + 1$ 个点 : 编号为 $0$ 的点为 $(0, 0)$. 编号为 $i (i \\in [1, n] \\cup \\mathbb{Z})$ 的点为 $(i, a_1 + a_2 + \\cdots + a_i)$. 注意到 $l \\to r$ 的平均数即为点 $l - 1$ 和 $r$ 之间的斜率, 于是从右往左用单调栈维护一个上凸壳转移即可. 时间复杂度 $\\Theta(n)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; int n, sta[N], top; long long s[N]; double ans[N]; int main () &#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i], s[i] += s[i - 1]; sta[++top] = n; for (int i = n - 1; i &gt;= 0; i--) &#123; while (top &gt; 1 &amp;&amp; (s[sta[top - 1]] - s[i]) * (sta[top] - i) &gt;= (s[sta[top]] - s[i]) * (sta[top - 1] - i)) top--; ans[i + 1] = 1.0 * (s[sta[top]] - s[i]) / (sta[top] - i); sta[++top] = i; &#125; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans[i] &lt;&lt; &quot;\\n&quot;; return 0; &#125; $\\rm ARC172E$ $\\rm (^*2358)$ 有 $q$ 次询问, 每次询问给定正整数 $x$, 求最小的 $n$ 满足 $n ^ n \\equiv x \\pmod p$. $q \\leqslant 10 ^ 4, 1 \\leqslant x &lt; p = 10 ^ 9, 2, 5 \\nmid x$. 引理 设集合 $U_k$ 为 $10 ^ k (k \\in \\mathbb{Z^{+}})$ 的简化剩余系, 命题 $P_k : \\{n^n~|~n \\in U_k\\} = U_k$ 成立. 证明 对于 $P_{1}$, $U_1 = \\{1, 3, 7, 9\\}$. 注意到 $1 ^ 1 \\equiv 1, 3 ^ 3 \\equiv 7, 7 ^ 7 \\equiv 3, 9 ^ 9 \\equiv 9 \\pmod {10}$, 于是 $P_1$​ 成立. 对于 $P_2$, 与 $P_1$ 类似的, 同样注意到 $n \\in U_2$ 时, $n$ 与 $n ^ n$ 在模 $10^2$ 意义下一一对应, 于是 $P_2$ 成立. 假设 $P_k (k \\geqslant 2)$ 成立, 即 $\\{n^n~|~n \\in U_k\\} = U_k$. 注意到二项式定理 : $(a + b) ^ k = \\sum _ {i = 0} ^ k \\binom{k}{i} a ^ i b ^ {k - i}$, 代入得 $$(n+t \\cdot10 ^ k)^{n+t \\cdot10 ^ k} = \\sum _ {i = 0} ^ {n+t \\cdot10 ^ k} \\dbinom{n+t \\cdot10 ^ k}{i} (t \\cdot10 ^ k) ^ i n ^ {n+t \\cdot10 ^ k - i} $$注意到 $(t \\cdot10 ^ k) ^ 2 \\equiv 0 \\pmod {10 ^ {k + 1}}$, 于是 $$\\begin{aligned} &amp;\\quad\\sum _ {i = 0} ^ {n+t \\cdot10 ^ k} \\dbinom{n+t \\cdot10 ^ k}{i} (t \\cdot10 ^ k) ^ i n ^ {n+t \\cdot10 ^ k - i}\\\\ &amp;\\equiv n ^ {n+t \\cdot10 ^ k} + (n+t \\cdot10 ^ k) \\cdot n ^ {n+t \\cdot10 ^ k - 1} \\cdot t \\cdot10 ^ k \\pmod {10 ^ {k + 1}} \\\\ &amp;\\equiv n ^ {n+t \\cdot10 ^ k} + n ^ {n+t \\cdot10 ^ k} \\cdot t \\cdot10 ^ k \\pmod {10 ^ {k + 1}} \\\\ &amp;\\equiv (n ^ n + n ^ n \\cdot t \\cdot10 ^ k) (n ^ {10 ^ k}) ^ t \\pmod {10 ^ {k + 1}} \\end{aligned} $$注意到欧拉定理 : 若 $a \\perp m$, 则 $a ^ {\\varphi(m)} \\equiv 1 \\pmod m$, 其中 $\\varphi(x)$ 表示 $[1, x]$ 中与 $x$ 互质的整数数量. 因为 $\\varphi(2 ^ {k + 1}) = 2 ^ k$, 且 $n \\perp 2 ^ {k + 1}$, 故 $n ^ {2 ^ k} \\equiv 1 \\pmod {2 ^ {k + 1}}$, 进而 $n ^ {10 ^ k}\\equiv (n ^ {2 ^ k}) ^ {5 ^ k} \\equiv 1 \\pmod {2 ^ {k + 1}}$. 因为 $\\varphi (5 ^ {k + 1}) = 4 \\times 5 ^ k$, 且 $n \\perp 5 ^ {k + 1}$, 故 $n ^ {4 \\times 5 ^ k} \\equiv 1 \\pmod {5 ^ {k + 1}}$, 进而 $n ^ {10 ^ k} \\equiv (n ^ {4 \\times 5 ^ k}) ^ {2 ^ {k - 2}} \\equiv 1 \\pmod {5 ^ {k + 1}}$. 又因为 $2 ^ {k + 1} \\perp 5 ^ {k + 1}$, 因此 $n ^ {10 ^ k} \\equiv 1 \\pmod {10 ^ {k + 1}}$. 代入得 $$(n ^ n + n ^ n \\cdot t \\cdot10 ^ k) (n ^ {10 ^ k}) ^ t \\equiv n ^ n \\cdot (t \\cdot 10 ^ k + 1) \\pmod {10 ^ {k + 1}} $$于是 $\\{n^n~|~n \\in U_{k + 1}\\}$ 中的每个数 $(n+t \\cdot10 ^ k)^{n+t \\cdot10 ^ k} \\equiv n ^ n \\cdot (t \\cdot 10 ^ k + 1) \\pmod {10 ^ {k + 1}}$. 假设存在 $t_i \\not= t_j$, 满足 $n ^ n (t_i \\cdot 10 ^ k + 1) \\equiv n ^ n (t_j \\cdot 10 ^ k + 1) \\pmod {10 ^ {k + 1}}$, 因为 $n ^ n \\perp 10 ^ {k + 1}$, 所以 $n ^ n$ 存在逆元(可除), 故解得 $t_i = t_j$, 矛盾. 于是 $\\forall i \\not= j, n ^ n (i \\cdot 10 ^ k + 1) \\not\\equiv n ^ n (j \\cdot 10 ^ k + 1) \\pmod {10 ^ {k + 1}}$. 于是 $\\{n^n~|~n \\in U_{k + 1}\\}$ 是个不重集得证, 即 $\\textrm{card}\\{n^n~|~n \\in U_{k + 1}\\} = U_{k + 1}$. 因为我们构造 $n ^ n$ 构成的集合的方式为, 令其尾数为 $\\{1, 3, 7, 9\\}$ 其中之一, 不断向首位前添加 $\\{0, 1, \\cdots, 9\\}$, 于是 $n ^ n$ 的尾数一定是 $\\{1, 3, 7, 9\\}$ 其中之一. 又因为 $U_{k + 1}$ 包含了所有小于 $10 ^ {k + 1}$ 且尾数为 $\\{1, 3, 7, 9\\}$ 其中之一的正整数, 所以 $\\{n^n~|~n \\in U_{k + 1}\\} \\subseteq U_{k + 1}$. 综上, $P_k : \\{n^n~|~n \\in U_{k + 1}\\} = U_{k + 1}$ 也即 $P_{k + 1}$ 得证. 归纳可证原命题. 回到原问题, 显然 $n ^ n \\to x$ 的映射是可以 $\\Theta(\\log n)$ 确定的, 于是我们考虑一位位确定 $x \\to n$ 的映射. 对于最后两位, 可以直接枚举 $n$ 检验 $n ^ n \\equiv x \\pmod {100}$ 是否成立. 假设后 $k$ 位已经确定, 我们有 $n ^ n \\equiv x \\pmod {10 ^ {k}}$, 且 $(t \\cdot 10 ^ k + n) ^ {t \\cdot 10 ^ k + n} \\equiv x \\pmod {x ^ {k + 1}}$ 对且仅对一个 $t \\in \\{0, 1, \\cdots, 9\\}$ 成立, 于是可以枚举 $t$ 检验是否成立. 综上我们找到了一个 $\\Theta(k ^ 2)$ 单次查询 $x \\to n$ 的映射满足 $n ^ n \\equiv x \\pmod {x ^ k}$ 的算法. #include &lt;bits/stdc++.h&gt; using namespace std; int q, x, n, fac[10]; int Pow (int a, int k, int mod) &#123; int res = 1; for (; k; k &gt;&gt;= 1, a = 1ll * a * a % mod) if (k &amp; 1) res = 1ll * res * a % mod; return res; &#125; int main () &#123; fac[0] = 1; for (int i = 1; i &lt;= 9; i++) fac[i] = fac[i - 1] * 10; cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; x; for (int i = 0; i &lt;= 99; i++) if (Pow(i, i, 100) == x % 100) n = i; for (int k = 2; k &lt;= 8; k++) &#123; for (int t = 0; t &lt;= 9; t++) if (Pow(t * fac[k] + n, t * fac[k] + n, fac[k + 1]) == x % fac[k + 1]) &#123; n += t * fac[k]; break; &#125; &#125; cout &lt;&lt; n &lt;&lt; &quot;\\n&quot;; &#125; return 0; &#125; $\\rm CF1864F$ $\\rm (^*2415)$ 存在一个长度为 $n$ 的整数序列 $\\{a_n\\}$, 有 $q$ 个独立的查询, 每次给出 $l, r$. 求最小的操作次数 $m$, 将值在 $[l, r]$ 内的所有数字变成 $0$. 单次操作被定义为 : 选择一个区间 $[x, y]$, 满足这个区间与之前的所有区间不相交或包含或被包含于之前的某个区间. 选择一个非负整数 $z$, 将区间 $[x, y]$ 中的所有数减去 $z$. $n, q \\leqslant 10 ^ 6, \\forall i, 1 \\leqslant a_i \\leqslant n$. 首先, 对于询问 $l, r$, 我们可以只考虑满足 $a_i \\in [l, r]$ 的数. 注意到我们每次必将至少一个数减成 $0$, 若这个数不是序列中的非 $0$ 最小值 $a_p$, 那么$a_p$之后还是要单独再减一次, 于是取 $z = a_p$ 是不劣的. 另外, 将 $a_p$ 置为 $0$ 的同时给以 $0$ 划分的联通区间内所有的数减去 $z$ 一定是不劣的. 减完后, 序列又以 $p$ 为分界点被划分为两个区间分别考虑. 对于朴素的策略, 每次只删一个数, 我们发现所需操作次数即为值在 $[l, r]$ 之间的元素数量 $\\ell$. 而若采取上述策略, 两个数 $a_i, a_j$ 可能同时被删, 当且仅当 $\\forall k \\in [i + 1, j - 1], a_k \\geqslant a_i = a_j~\\textrm{or}~a_k &lt; l$, 记满足该条件的二元组 $(i, j)$ 数量为 $\\tau$, 最终所需操作次数即为 $\\ell - \\tau$. 考虑将询问按 $r$ 排序, 从小到大加入数, 那 $\\exists k \\in [i + 1, j - 1], a_k \\geqslant a_i = a_j$ 就不可能成立了, 于是仅需考虑 $a_k &lt; l$, 也即 $\\max_{k \\in [i + 1, j - 1]} &lt; l$. 这个是好维护的, 只需要一棵支持单点修改, 区间查询最大值的线段树. 而对于 $l$ 的查询, 可以将线段树上查出的最大值插入值域树状数组, 查询小于 $l$ 的数有多少个即为 $\\tau$. 注意, 由于我们只想求值域在 $[l, r]$ 中数对应的最大值小于 $l$ 的数量, 所以要减去 $[1, l - 1]$ 中数对应的最大值小于 $l$ 的数量, 可以发现就是 $[1, l - 1]$ 中数的数量减去不同的小于 $l$ 的数的数量. 于是最终每个询问的答案就是已经插入线段树中数的数量减去当前树状数组中 $1 \\sim l - 1$ 的值, 再减去本质不同的小于 $l$ 的数的数量. 时间复杂度 $\\Theta(n \\log n)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6 + 10; int n, q, dif[N], ans[N]; vector &lt;int&gt; p[N]; pair &lt;int, pair&lt;int, int&gt; &gt; s[N]; namespace ST &#123; #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) int Max[N &lt;&lt; 2], l[N &lt;&lt; 2], r[N &lt;&lt; 2]; void Build (int p, int L, int R) &#123; Max[p] = 0, l[p] = L, r[p] = R; if (L == R) return; int mid = (L + R) &gt;&gt; 1; Build(ls, L, mid), Build(rs, mid + 1, R); &#125; void Modify (int p, int pos, int k) &#123; if (l[p] == pos &amp;&amp; r[p] == pos) &#123; Max[p] = k; return; &#125; r[ls] &gt;= pos ? Modify(ls, pos, k) : Modify(rs, pos, k); Max[p] = max(Max[ls], Max[rs]); &#125; int Query (int p, int L, int R) &#123; if (L &gt; R) return 0; if (l[p] &gt;= L &amp;&amp; r[p] &lt;= R) return Max[p]; int res = 0; if (r[ls] &gt;= L) res = max(res, Query(ls, L, R)); if (l[rs] &lt;= R) res = max(res, Query(rs, L, R)); return res; &#125; &#125; namespace BIT &#123; #define lowbit(x) (x &amp; (-x)) int t[N]; void add (int pos) &#123; if (pos == 0) &#123; t[0]++; return; &#125; for (; pos &lt;= n; pos += lowbit(pos)) t[pos]++; &#125; int Query (int pos) &#123; int res = 0; for (; pos &gt;= 1; pos -= lowbit(pos)) res += t[pos]; return res + t[0]; &#125; &#125; int main () &#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; q; for (int a, i = 1; i &lt;= n; i++) cin &gt;&gt; a, p[a].push_back(i), dif[a] = 1; for (int i = 1; i &lt;= n; i++) dif[i] += dif[i - 1]; for (int i = 1; i &lt;= q; i++) cin &gt;&gt; s[i].second.first &gt;&gt; s[i].first, s[i].second.second = i; sort(s + 1, s + q + 1); ST::Build(1, 1, n); for (int cnt = 0, pos = 0, k = 1; k &lt;= q; k++) &#123; int l = s[k].second.first, r = s[k].first; while (pos &lt; r) &#123; pos++, cnt += p[pos].size(); if (p[pos].empty()) continue; int num = p[pos].size(); for (int i = 1; i &lt; num; i++) BIT::add(ST::Query(1, p[pos][i - 1] + 1, p[pos][i] - 1)); for (int i : p[pos]) ST::Modify(1, i, pos); &#125; ans[s[k].second.second] = cnt - BIT::Query(l - 1) - dif[l - 1]; &#125; for (int i = 1; i &lt;= q; i++) cout &lt;&lt; ans[i] &lt;&lt; &quot;\\n&quot;; return 0; &#125; $\\rm ARC172D$ $\\rm (^* 2936)$ 给定 $n$ 和 $\\frac{n(n - 1)}{2}$ 组条件 $(a_i, b_i)$, 要求在 $n$ 维空间中放置 $n$ 个坐标在 $[0, 10 ^ 8]$ 内的整点, 满足 $\\textrm{dis}(p_{a_i}, p_{b_i})$ 按照给出条件的顺序从小到大排序. $3 \\leqslant n \\leqslant 20$. 考虑先构造任意两点之间距离相等, 再细微调整使其满足条件. 不妨令 $$\\begin{pmatrix} p_1 = [1, 0, 0, \\cdots, 0] \\\\ p_2 = [0, 1, 0, \\cdots, 0] \\\\ \\cdots \\\\ p_n = [0, 0, 0, \\cdots, 1] \\\\ \\end{pmatrix} $$这样就能使任意两点之间距离为 $\\sqrt2$, 然后给每个点的每个维度加上一个极小量 $$\\begin{pmatrix} p_1 = [1 + \\varepsilon_{1, 1},\\varepsilon_{1, 2} , \\varepsilon_{1, 3}, \\cdots, \\varepsilon_{1, n}] \\\\ p_2 = [\\varepsilon_{2, 1}, 1 + \\varepsilon_{2, 2},\\varepsilon_{2, 3} , \\cdots, \\varepsilon_{3, 3}] \\\\ \\cdots \\\\ p_n = [\\varepsilon_{n, 1}, \\varepsilon_{n, 2},\\varepsilon_{n, 3} , \\cdots, 1 + \\varepsilon_{n, n}] \\\\ \\end{pmatrix} $$此时两点距离为 $$\\textrm{dis} ^ 2(p_i, p_j) = \\sum_{k \\not= i, j} (\\varepsilon_{i, k} - \\varepsilon_{j, k}) ^ 2 + (1 + \\varepsilon_{i, i} - \\varepsilon_{j, i}) ^ 2 + (\\varepsilon_{i, j} - 1 - \\varepsilon_{j, j}) ^ 2 $$注意到二阶小量对构造结果的影响很小, 于是消去, 得 $$\\textrm{dis}(p_i, p_j) = \\sqrt{1 + \\varepsilon_{i, i} + \\varepsilon_{j, j} - \\varepsilon_{i, j} - \\varepsilon_{j, i}} \\cdot \\sqrt2 $$我们不妨设 $i &lt; j$ 且 $\\varepsilon_{i, i}, \\varepsilon_{j, j}, \\varepsilon_{j, i} = 0$, 则原命题转化为 $$\\sqrt{1 - \\varepsilon_{a_1, b_1}} &lt; \\sqrt{1 - \\varepsilon_{a_2, b_2}} &lt; \\cdots &lt; \\sqrt{1 - \\varepsilon_{a_n, b_n}} $$将坐标等比例放大 $L$ 倍, 可设 $\\varepsilon_{a_i, b_i}$ 为 $-i$, 考虑到坐标不能为负数, 于是再将所有点的坐标加上 $l$. 此题可取 $L = 9 \\times 10 ^ 7, l = \\frac{n(n - 1)}{2}$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 22, L = 9e7; int n, p[N][N]; int main () &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) p[i][j] = n * (n - 1) / 2 + L * (i == j); for (int a, b, i = 1; i &lt;= n * (n - 1) / 2; i++) cin &gt;&gt; a &gt;&gt; b, p[a][b] -= i; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) printf(&quot;%d%c&quot;, p[i][j], &quot; \\n&quot;[j == n]); return 0; &#125; $\\rm CF1905E$ $\\rm (^* 2484)$ 递归定义长度为 $n$ 的线段树. 根节点为 $1$, 代表区间 $[1, n]$. 若一个结点 $p$ 代表的区间为 $[l, r]$, 那么当且仅当 $l \\not= r$ 时它存在两个子节点 $2p$ 和 $2p + 1$, 分别代表区间 $[l, \\lceil\\frac{l + r}{2}\\rceil]$ 和 $[\\lceil\\frac{l + r}{2}\\rceil + 1, r]$. 共 $T$ 组询问, 每次给定 $n$, 求长度为 $n$ 的线段树对应的 $\\sum \\textrm{LCA}(S)$, 其中 $S$ 表示任意一个叶子节点的非空集合, $\\textrm{LCA}(S)$ 表示 $S$ 中所有结点的最近公共祖先的编号. 答案对 $998244353$ 取模. $T \\leqslant 10 ^ 3, 2 \\leqslant n \\leqslant 10 ^ {18}$. 首先考察结点 $(p, l, r)$ 的贡献, 其作为最近公共祖先当且仅当 $2p$ 和 $2p + 1$ 内均至少存在一个结点被选择, 且 $[l, r]$ 之外没有结点被选择. 故其贡献为 : $$p(2 ^ {\\lceil\\frac{l + r}{2}\\rceil - l + 1} - 1)(2 ^ {r - \\lceil\\frac{l + r}{2}\\rceil} - 1) $$注意到线段树每层最多存在两种长度的区间, 且相同长度的区间被算进贡献的次数是相同的, 于是考虑合并计算. 递归时维护当前长度 $l$ 对应的结点编号和 $s$, 数量 $c$ 即可, 用 map 存储. 时间复杂度 $\\Theta(T\\log ^ 2 n)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100, mod = 998244353; int T, ans; long long n; set &lt;long long&gt; S; map &lt;long long, int&gt; s, c; void Build (long long l) &#123; S.insert(l); if (l == 1) return; if (S.find((l + 1) / 2) == S.end()) Build((l + 1) / 2); if (S.find(l / 2) == S.end()) Build(l / 2); &#125; int Pow (int a, long long k) &#123; int res = 1; for (; k; k &gt;&gt;= 1, a = 1ll * a * a % mod) if (k &amp; 1) res = 1ll * res * a % mod; return res; &#125; int main () &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; S.clear(), Build(n); s.clear(), c.clear(), ans = 0, s[n] = c[n] = 1; for (auto it = S.rbegin(); it != S.rend(); it++) &#123; long long l = *it, lx = (l + 1) / 2, ly = l / 2; if (l == 1) ans = (ans + s[l]) % mod; else &#123; ans = (ans + 1ll * s[l] * (Pow(2, lx) - 1) % mod * (Pow(2, ly) - 1)) % mod; s[lx] = (s[lx] + 2ll * s[l]) % mod, c[lx] = (c[lx] + c[l]) % mod; s[ly] = (s[ly] + 2ll * s[l] + c[l]) % mod, c[ly] = (c[ly] + c[l]) % mod; &#125; &#125; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; &#125; return 0; &#125; $\\rm CF1923E$ $\\rm (^* 2044)$ 给定一棵 $n$ 个结点的树, 每个结点有一个 $[1, n]$ 中的颜色, 求满足以下条件的路径的数量 : 至少由 $2$ 个结点组成. 路径的起点与终点颜色相同. 路径上起点和终点以外的点颜色与起点不同. $n \\leqslant 2 \\times 10 ^ 5$. 此处给出一个优于官方 $\\Theta(n \\log n)$ 做法的线性做法. 考虑按 $\\rm dfs$ 序枚举树上的每个结点, 统计当前结点 $u$ 能和前面结点构成的合法路径 $(u, v)$ 的数量. 可以发现若设 $f$ 为 $u$ 的祖先中最近的与 $u$ 颜色相同的结点, 则合法的 $v$ 可以用以下方式刻画 : 若 $f$ 存在则将其计入答案, 否则设 $f = fa(1) = 0$, 不计入答案. 遍历 $u$ 至 $f$ 路径上的每个结点 $r$ (不含 $u, f$), 从 $r$ 开始向其子树(不含包括 $u$ 的这棵)中遍历, 遇到与 $u$​ 颜色相同的结点则停下, 并将其计入答案. 设 $c_i$ 表示若 $u$ 的颜色为 $i$, 能被计入答案的结点数量. 因为以 $u$ 为根的子树中所有想走出来的合法路径都会被 $u$ 拦住, 所以进入子树时要将 $c_i$ 设为 $1$. 因为出以 $u$ 为根的子树时原本的答案会还原, 且 $u$ 也是合法路径的端点, 所以出子树时要将 $c_i$ 加 $1$. 使用这种策略遍历一遍整棵树即可算出答案. 时间复杂度 $\\Theta(n)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; int T, n, col[N], cf[N], c[N]; long long ans; vector &lt;int&gt; E[N]; void dfs (int u, int fa) &#123; ans += c[col[u]]; int mark = c[col[u]]; for (int v : E[u]) if (v != fa) c[col[u]] = 1, dfs(v, u); c[col[u]] = mark + 1; &#125; int main () &#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; col[i]; for (int u, v, i = 1; i &lt; n; i++) cin &gt;&gt; u &gt;&gt; v, E[u].push_back(v), E[v].push_back(u); dfs(1, 0), cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; ans = 0; for (int i = 1; i &lt;= n; i++) E[i].clear(), cf[i] = c[i] = 0; &#125; return 0; &#125; $\\rm CF1918F$ $\\rm (^* 2696)$ 给定一颗 $n$ 个结点的树, 从 $1$ 开始在树上行走, 求走到过所有结点的最小步数. 操作 $1$ : 移动到相邻的结点, 花费 $1$ 步. 操作 $2$ : 移动到 $1$ 号结点, 无花费, 但操作 $2$ 最多进行 $k$ 次. $2 \\leqslant n \\leqslant 2 \\times 10 ^ 5, 0 \\leqslant k \\leqslant 10 ^ 9$. 可以发现如下性质 : 操作 $2$ 只会在叶子结点进行. 题目等效于要求最后需要回到 $1$ 号结点, 但操作 $2$ 可以进行 $k + 1$ 次. 如果只使用操作 $1$, 则每条边会经过恰好 $2$ 次, 总共需要 $2(n - 1)$ 步. 考虑求操作 $2$ 最多能节省多少步数. 假设遍历顺序已经确定下来了, 那对于其中一对访问时间相邻的叶子结点 $(u, v)$ (相邻被定义为 $u \\to v$ 的路径上不存在其它叶子结点), 如果在 $u$ 处使用操作 $2$, 设 $f = \\textrm{LCA}(u, v)$, 能够节省的步数为 $\\textrm{dis}(u, v) - \\textrm{dis}(1, v)$, 可转化为 $\\textrm{dis}(u, f) - \\textrm{dep}(f)$. 考察每个非叶子结点 $f$, 在以 $f$ 为根的子树中如果存在某个叶节点使用了操作 $2$, 考虑到要最大化 $\\textrm{dis}(u, f) - \\textrm{dep}(f)$, 那么一定是深度最大的结点, 且它是最后一个被遍历到的. 于是对 $f$ 的所有子节点 $u$ 按以 $u$ 为根的子树深度从小到大排序, 这样得出的叶节点访问顺序也即能最小化总步数的访问顺序. 注意到每个叶节点的贡献是独立的, 于是计算最大的 $\\sum \\textrm{dis}(u, f) - \\textrm{dep}(f)$ 只需要求出前 $k$ 大即可. 时间复杂度 $\\Theta(n \\log n)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; int n, k, fa[N], dep[N], siz[N], son[N], len[N], top[N], ans; vector &lt;int&gt; E[N], leaf, val; void dfs1 (int u, int f) &#123; dep[u] = dep[f] + 1, siz[u] = 1; for (int v : E[u]) dfs1(v, u), siz[u] += siz[v], len[u] = max(len[u], len[v] + 1), son[u] = siz[v] &gt; siz[son[u]] ? v : son[u]; &#125; void dfs2 (int u, int t) &#123; top[u] = t; if (son[u]) dfs2(son[u], t); for (int v : E[u]) if (v != son[u]) dfs2(v, v); &#125; int LCA (int u, int v) &#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; &#125; return dep[u] &lt; dep[v] ? u : v; &#125; int dis (int u, int v) &#123; return dep[u] + dep[v] - 2 * dep[LCA(u, v)]; &#125; bool cmp (int a, int b) &#123; return len[a] &lt; len[b]; &#125; void dfs3 (int u) &#123; sort(E[u].begin(), E[u].end(), cmp); for (int v : E[u]) dfs3(v); &#125; void dfs4 (int u) &#123; if (E[u].empty()) leaf.push_back(u); for (int v : E[u]) dfs4(v); &#125; int main () &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 2; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;fa[i]), E[fa[i]].push_back(i); dfs1(1, 0), dfs2(1, 1), dfs3(1), dfs4(1); int num = leaf.size(); for (int i = 0; i &lt; num; i++) if (i &lt; num - 1) val.push_back(dis(leaf[i], leaf[i + 1]) - dis(1, leaf[i + 1])); else val.push_back(dis(1, leaf[i])); sort(val.begin(), val.end(), greater &lt;int&gt; ()); for (int i = 0; i &lt;= k &amp;&amp; i &lt; num; i++) if (val[i] &gt; 0) ans += val[i]; printf(&quot;%d\\n&quot;, 2 * (n - 1) - ans); return 0; &#125; $\\rm ARC173B$ $\\rm (^* 1594^+)$ 给定平面上的 $n$ 个整点, 第 $i$ 个点坐标为 $(x_i, y_i)$. 问最多能用这些顶点构建多少个非退化三角形(每个点只能用一次). $3 \\leqslant n \\leqslant 300, |x_i|, |y_i| \\leqslant 10 ^ 9.$ 设 $l$ 为平面上穿过点数最多的直线, 其上点数为 $m$. 若 $m \\geqslant n - \\lfloor\\frac{n}{3}\\rfloor + 1$, 那么答案为 $n - m$, 即每从 $l$ 外取一个点, 从 $l$ 内取两个点构成一个三角形. 若 $m \\leqslant n - \\lfloor\\frac{n}{3}\\rfloor$, 那么可以取到答案上界 $\\lfloor\\frac{n}{3}\\rfloor$. 下归纳证明第二种情况的正确性, 假设对小于 $n$ 个点的情况该结论均正确 : 尝试从 $n$ 个点中选取 $3$ 个先构成一个三角形, 钦点其中两个点从 $l$ 上选, 则 $l$ 上现在的点数 $m' = m - 2$, 由 $m \\leqslant n - \\lfloor\\frac{n}{3}\\rfloor$ 得 $m' = m - 2 \\leqslant n - \\lfloor\\frac{n}{3}\\rfloor - 2 = n - 3 - \\lfloor\\frac{n - 3}{3}\\rfloor$, 可以取到 $n - 3$ 个点的答案上界 $\\lfloor\\frac{n - 3}{3}\\rfloor$, 进而 $n$ 个点的第二种情况可以取到 $n$ 个点的答案上界 $\\lfloor\\frac{n}{3}\\rfloor$ 得证. 归纳得原命题得证. 有这个结论, 则可以直接枚举两个点, 设过它们的直线为 $l$ 并计算 $m$, 时间复杂度 $\\Theta(n ^ 3)$, 可以通过原问题. 注意到若答案不为 $\\lfloor\\frac{n}{3}\\rfloor$ 则 $l$ 上的点数占总点数的 $\\frac{2}{3}$ 以上, 用类摩尔投票法的方式来统计显然是一个更聪明的做法. 在一个栈中保存我们认为在 $l$ 上的点, 若栈大小小于 $2$ 则将当前点加入栈, 否则判断其跟栈内元素是否在同一条直线上. 若是, 则将其入栈, 否则踢出栈内一个元素. 注意到 $l$ 上的元素为绝对众数, 所以最终栈内留下来的元素一定是 $l$ 上的元素(若没留下来超过 $1$ 个元素, 则说明栈中元素代表的 $l$ 上的点数并非绝对众数, 答案为 $\\lfloor\\frac{n}{3}\\rfloor$). 特别的, 若当前栈中只剩两个元素, 则需要全部踢出, 否则一个不在 $l$ 上的点可能永远留在栈中. 注意到所求 $l$ 上的点数大于总点数的 $\\frac{2}{3}$​, 所以哪怕每次都踢出两个元素也不会影响投票法的正确性. 最后, 栈中剩下元素代表的 $l$ 即为所求, 枚举判断一下有多少个点在 $l$ 上即可. 时间复杂度被优化到 $\\Theta(n)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6 + 10; int n, x[N], y[N], sta[N], top; bool check (int i, int j, int k) &#123; return (1ll * x[j] * y[k] - 1ll * y[j] * x[k]) - (1ll * x[i] * y[k] - 1ll * y[i] * x[k]) + (1ll * x[i] * y[j] - 1ll * y[i] * x[j]) == 0; &#125; int main () &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; x[i] &gt;&gt; y[i]; for (int i = 1; i &lt;= n; i++) &#123; if (top &lt;= 1) sta[++top] = i; else if(check(sta[1], sta[2], i)) sta[++top] = i; else top -= 1 + (top == 2); &#125; if (top &lt; 2) return printf(&quot;%d\\n&quot;, n / 3), 0; int m = 2; for (int i = 1; i &lt;= n; i++) if (i != sta[1] &amp;&amp; i != sta[2]) m += check(sta[1], sta[2], i); (m &lt;= n - n / 3) ? printf(&quot;%d\\n&quot;, n / 3) : printf(&quot;%d\\n&quot;, n - m); return 0; &#125; $\\rm CF1946D$ $\\rm (^* 2006)$ 有一个长度为 $n$ 的数列 $\\{a_n\\}$ 和一个数 $x$, 请找到最大的数$k$, 使得可以选择一些数字对 $[l_1, r_1]$, $[l_2, r_2]$, $\\cdots$, $[l_k, r_k]$ 满足以下条件 : $l_1 = 1$, $r_k = n$. 对于所有 $i$ 从 $1$ 到 $k$ , $l_i \\leqslant r_i$. 对于所有 $i$ 从 $1$ 到 $k - 1$, $r_i + 1 = l_{i + 1}$. $(a_{l_1} \\oplus a_{l_1 + 1} \\oplus \\ldots \\oplus a_{r_1}) | (a_{l_2} \\oplus a_{l_2 + 1} \\oplus \\ldots \\oplus a_{r_2}) | \\ldots | (a_{l_k} \\oplus a_{l_k + 1} \\oplus \\ldots \\oplus a_{r_k}) \\leqslant x$. 如果不存在这样的 $k$, 则输出 $-1$. 设 $s_i = \\oplus_{j = 1}^i a_j$, 则原问题被转化为 $s_{r_1}|(s_{r_2}\\oplus s_{r_1})|\\cdots|(s_{r_k} \\oplus s_{r_{k - 1}}) \\leqslant x$. 注意到 $x | x \\oplus y = x | y$, 于是问题被转化为从 $\\{s_n\\}$ 中选尽可能多的数, 使其或和不超过 $x$. 这就变成了经典问题, 枚举 $x$ 最高的为 $1$ 且或和中该位为 $0$ 的是哪一位, 然后进行贪心即可. 时间复杂度 $\\Theta(n \\log n)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5 + 10; int T, n, x, a[N], ans; int calc (int y) &#123; int res = 1; if ((a[n] | y) != y) return -1; for (int i = n - 1; i &gt;= 1; i--) if ((a[i] | y) == y) res++; return res; &#125; int main () &#123; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;x); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), a[i] ^= a[i - 1]; ans = -1; for (int k = 30; k &gt;= 0; k--) if ((x &gt;&gt; k) &amp; 1) ans = max(ans, calc(((x &gt;&gt; (k + 1)) &lt;&lt; (k + 1)) + (1 &lt;&lt; k) - 1)); ans = max(ans, calc(x)); printf(&quot;%d\\n&quot;, ans); &#125; return 0; &#125; $\\rm CF1944F2$ $\\rm (^* 2828)$ 如果一个长度为 $m$ 的数列 $\\{b_{m}\\}$ 能通过若干次操作变成全 $0$ 序列, 则该序列为合法的. 操作被定义为, 选择 $1 \\leqslant l &lt; r \\leqslant m$, 将所有满足 $i \\in [l, r]$ 的 $b_i$ 减 $1$. 给定 $n, k, p$, 求有多少个长度为 $n$ 的数列 $\\{a_n\\}$ 是合法的, 且满足 $\\forall i, 0 \\leqslant a_i \\leqslant k$, 答案对 $p$ 取模. $3 \\leqslant n \\leqslant 3000, 1 \\leqslant k \\leqslant n, 10^8 &lt; p &lt; 10^9, p \\in \\mathbb{P}$. 首先我们考虑$\\{a_n\\}$ 合法的充要条件是什么, 容易想到为 $\\forall i, a_i \\leqslant a_{i - 1} + a_{i + 1}$. 注意到 $a_i &gt; a_{i - 1} + a_{i + 1}$ 和 $a_{i + 1} &gt; a_i + a_{i + 2}$ 不可能同时成立, 于是同时计算合法和不合法的方案数只需要记录前 $1$ 个元素. 具体来说, 设 $f_{i, j}$ 为考虑到 $a_i$, 且 $a_i = j$ 的合法方案数, 设 $g_i,j$ 为考虑到 $a_i$, 有且仅有 $a_i = j$ 这一位不合法的方案数. 那么有转移式 : $$g_{i, j} = \\sum_{t = 0}^k f_{i - 2}, t \\times \\max\\{k - j - t, 0\\}, f_{i, j} = \\sum_{t = 0}^k f_{i - 1, t} - g_{i, j} $$前缀和优化后时间复杂度 $\\Theta(n^2)$. #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 3e3 + 10; int T, n, k, p, f[N][N], g[N][N], sum[N]; int main () &#123; f[0][0] = 1; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; k &gt;&gt; p; for (int sigma, i = 1; i &lt;= n + 1; i++) &#123; sum[0] = f[i - 2][0], sigma = f[i - 1][0]; for (int j = 1; j &lt;= k; j++) sum[j] = (sum[j - 1] + f[i - 2][j]) % p, sigma = (sigma + f[i - 1][j]) % p; for (int j = k; j &gt;= 0; j--) &#123; g[i][j] = (g[i][j + 1] + sum[k - 1 - j]) % p, f[i][j] = (sigma - g[i][j] + p) % p; &#125; &#125; cout &lt;&lt; f[n + 1][0] &lt;&lt; &quot;\\n&quot;; for (int i = 1; i &lt;= n + 1; i++) for (int j = 0; j &lt;= k; j++) f[i][j] = g[i][j] = 0; &#125; return 0; &#125; $\\rm CF1944D$ $\\rm (^* 2072)$ 定义一个字符串为 $\\textrm {k-good}$ 的, 当且仅当其存在至少一个长度为 $k$ 的子串不是回文的. 给定长度为 $n$ 的字符串 $s$, 共 $q$ 次询问, 每次给定 $l, r$, 求 $\\sum_k k[s_{l \\sim r}~\\textrm{is~k-good}]$. $n, q \\leqslant 2 \\times 10 ^ 5, 1 \\leqslant l &lt; r \\leqslant n.$ 考虑计算一个特定的子串 $t$ 对应的 $\\sum_k k[t~\\textrm{is~k-good}]$. 对 $k$ 分类讨论: $k = 1$: 任意字符串均不是 $\\textrm {1-good}$ 的. $k = |t|$: $t$ 为 $\\textrm {|t|-good}$ 的当且仅当 $t$ 本身为回文串. $k$ 为偶数: 若 $t$ 不为 $\\textrm {k-good}$ 的, 则任意长度为 $k$ 的子串均为回文的, 则 $t$ 中所有字符均相等. $k$ 为奇数: 若 $t$ 不为 $\\textrm {k-good}$ 的, 则任意长度为 $k$ 的子串均为回文的, 则 $t$ 中所有距离为 $2$ 的字符均相等. 考虑如何判断 $s$ 的子串是否满足以下几个条件: $s_{l \\sim r}$ 是回文的: 使用 $\\textrm{Manacher}$ 算法或哈希即可. $s_{l \\sim r}$ 是全部相等的: 对 $[s_i = s_{i - 1}]$ 做前缀和即可. $s_{l \\sim r}$ 是间隔相等的: 对 $[s_i = s_{i - 2}]$ 分奇偶做前缀和即可. 满足的条件判断出来后等差数列求和即可算出答案. 时间复杂度 $\\Theta(n + q)$. def manacher (n, s): if n == 0: return [] res = [0] * (2 * n - 1) l, r = -1, -1 for z in range(2 * n - 1): i = (z + 1) // 2 j = z // 2 p = 0 if i &gt;= r else min(r - i, res[2 * (l + r) - z]) while j + p + 1 &lt; n and i - p - 1 &gt;= 0: if s[j + p + 1] != s[i - p - 1]: break p += 1 if j + p &gt; r: l, r = i - p, j + p res[z] = p return res T = int(input()) for _ in range(T): n, q = map(int, input().split()) s = input().strip() p1 = [0] * (n + 2) p2 = [0] * (n + 2) for i in range(n + 1, -1, -1): if i &gt;= n: p1[i] = p2[i] = i else: if i + 1 &lt; n and s[i] != s[i + 1]: p1[i] = i else: p1[i] = p1[i + 1] if i + 2 &lt; n and s[i] != s[i + 2]: p2[i] = i else: p2[i] = p2[i + 1] pal = manacher(n, s) for __ in range(q): l, r = map(int, input().split()) l -= 1; r -= 1 length = r - l + 1 if p1[l] &gt;= r: print(0) continue if p2[l] &gt;= r - 1: k = length // 2 print(k * (k + 1)) continue ans = length * (length + 1) // 2 - 1 if pal[l + r] &gt;= length // 2: ans -= length print(ans) $\\rm ABC347F$ $\\rm (^* 2120)$ 给定 $n \\times n$ 的由非负整数构成的矩阵, 要从中选出 $3$ 个 $m \\times m$ 的不相交的子矩阵, 最大化所有子矩阵的元素和. $2 \\leqslant n \\leqslant 1000, 1 \\leqslant m \\leqslant \\frac{n}{2}, a_{i, j} \\leqslant 10^9$. 尝试枚举三个子矩阵的相对位置关系, 可以发现, 一定存在以上 $6$ 中划分方式的其中一种, 使 $3$ 个子矩阵分属 $3$ 个不同的区域, 且不会有任何部分被其它区域包含. 容易发现这 $6$ 种划分方式本质上是两种. 对于 $|~|$ 型: 求出每一列上的点作为子矩阵左上角的点对应的最大元素和, 预处理列区间的最大值, 枚举划分方案即可. 对于 $|-$ 型: 求出列前缀最大值和右上, 右下部分的前缀最大值, 枚举划分方案即可. 时间复杂度 $\\Theta(n^2)$. n, m = map(int, input().split()) a = [list(map(int, input().split())) for _ in range(n)] def calc (a): for i in range(n): for j in range(n - 1): a[i][j + 1] += a[i][j] a[i].append(0) for j in range(n): for i in range(n - 1): a[i + 1][j] += a[i][j] a.append([0] * (n + 1)) b = [[0] * n for _ in range(n)] for i in range(m - 1, n): for j in range(m - 1, n): b[i][j] = a[i][j] - a[i][j - m] - a[i - m][j] + a[i - m][j - m] c = [max(b[i]) for i in range(n)] d = c[:] e = [0] * n res = 0 for i in range(n - 1): d[i + 1] = max(d[i + 1], d[i]) for i in range(n - m - 1, m - 2, -1): f = 0 g = [0] * (i + m) + c[i + m : ] for j in range(n): e[j] = max(e[j], b[i + m][j]) for j in range(2 * m - 1, n): f = max(f, e[j - m]) res = max(res, d[i] + e[j] + f) for j in range(i + m, n - 1): g[j + 1] = max(g[j + 1], g[j]) for j in range(i + 2 * m, n): res = max(res, d[i] + g[j - m] + c[j]) return res ans = 0 for _ in range(4): ans = max(ans, calc([list(l) for l in zip(*a)])) a = [list(l)[ : : -1] for l in zip(*a)] print(ans)","tags":"c++ 题解 趣题 python codeforces atcoder"},{"title":"一封面向社会，关于对近日来 CCF 不当行为之抗议的公开信","url":"/2023/06/24/zhi-ccf-de-yi-feng-gong-kai-xin/","text":"​ $\\quad$前天，我看到 $\\rm CCF$ 发布了这样一则公告 ： $\\quad$得知此事，我很愤怒，但愤怒过后是深深的失落。大概是因为看着我所热爱的信息学竞赛正因为一个组织的糊涂行为走向毁灭吧。 $\\quad$是的，毁灭。“ $\\rm OI$ 要做干净的竞赛。” 这句话的提出者正抬起脚，狠狠地将这块令所有信息竞赛生引以为傲的招牌踩在地上，变得四分五裂。当一个竞赛已经失去了信用，那它的存在倒比毁灭更令人难过了。 $\\quad$在过去的很多年里，$\\rm CCF$ 一直有一个规定，若某省存在选手作弊，那么扣除该省省队名额一个，并将作弊选手禁赛三年。由于这个政策的存在，有很多本该进入省队的选手因为某个与自己毫不相关的人作弊而与自己本该获得的奖牌失之交臂。 $\\quad$但这项规则对所有人都是如此吗？去年南门口中学某谢姓选手在省选考场上作弊，并进入省队。作弊事实败露后他仅仅是被 $\\rm CCF$ 以非公开的方式取消了抄袭题目的分数，甚至还参加了在省选之后举办的清华集训。 $\\quad$而今年情况越发严峻，十多个省由于存在作弊选手而被扣除省队名额，其中大多数为入门组的小朋友，而代价却要能够进入省队的高水平选手来承担。幸好后来事情发生了变化，有一名被判定为作弊的选手来自某超级强校，而那所学校的教练对 $\\rm CCF$ 的行为进行了强烈的抗议，直接促使 $\\rm CCF$ 被迫取消此规定。 $\\quad$在结果大快人心的同时，我们不妨想想，之前难道没有学校对这个规定进行过抗议吗？为什么 $\\rm CCF$ 可以置若罔闻，而超级强校对其抗议却立刻奏效了呢？ $\\quad$在 $\\rm CCF$ 取消上述规定后，我本来以为风波已平，却不想是另一场风暴的开端，而这次更是带来了席卷 $\\rm OI$ 界的滔天巨浪 —— 某些选手因为在代码注释中写下 F**k_CCF 等内容而被取消本次考试成绩并被禁赛一年。 $\\quad$先对一些关键点进行解释 ： 代码注释是形如下文中 &quot; $//$ &quot; 后面的内容 ： void read (int &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) c = getchar(); while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - 48, c = getchar(); &#125; // 这段代码被用来快速读入一个数&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;注意&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;只能用来读取不大于 2^31 - 1 的正整数&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;。&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt; $\\quad$注释一般被写在代码中用来提醒程序员这段代码起什么作用或者需要注意什么事情，在评测时机器不会读取这些字符。 在 $\\rm OI$ 考试中，时间紧，任务重，大多数选手在考试结束时是拿不到自己的极限分数的。而在考试中，题目质量，考场状态，考试策略等都能极大地影响一个选手的分数，但一场考试又最多只有 $4$ 道题，所以选手在在看到自己不擅长的题目类型时是非常难受的。比如说这次 $\\rm NOIp$，我本人在发现有一半题目是 $\\rm DP$ 题，并且 $\\rm DP$ 又是我最不擅长的知识点时，花 $5$ 分钟去厕所洗了个脸才基本冷静下来。而某些选手在注释中写下一些对 $\\rm CCF$ 的怒斥又何尝不是他们宣泄情绪，让自己保持冷静的方式呢 ？ $\\quad$至于某些人将这种行为类比成在高考作文中骂教育部是完全不恰当的，因为在了解了 $\\rm OI$ 的规则后，我们知道这种行为顶多算是在草稿纸上写 F**k jyb. 改卷老师（评测机）是不会看到这些语句的。虽然草稿纸最后会被公示（此处不得不承认 $\\rm CCF$ 在赛后公示选手代码（答卷）是考试史上的一大进步），但公示后会看到的人数至多以千记，造成的影响不算很大。 禁赛一年是指在接下来的一年中，被禁赛的选手将不能参加所有 $\\rm NOI$ 系列的比赛，这意味着一个选手不能参加次年的 $\\rm NOIp$，而又有谁能在不参加 $\\rm NOIp$ 的情况下进入省队呢？所以一个选手两年内的所有比赛将会被禁止，这意味着如果这个选手是高中生，那么他的 $\\rm OI$ 之路必将就此断绝。 $\\quad$回归正题。看到这里，大家对 $\\rm CCF$ 的行为应该已经有了自己的评判。我想，大多数 $\\rm OIer$ 对 $\\rm CCF$ 所作行为的愤怒之处并不在于他对涉事选手的处罚，而在于 ： 选手不过是在 “草稿纸” 上骂了 $\\rm CCF$ 几句，而 $\\rm CCF$ 却要对他们赶尽杀绝，这未免已经超出了批评教育，甚至惩罚的范畴。 前 $\\rm IOI$ 中国代表队成员钟子谦已经对全国选手的代码进行了查找，发现在代码中辱骂 $\\rm CCF$ 者高达 $122$ 人之多，而 $\\rm CCF$ 却只处罚了 $5$ 名高水平选手，仅占总数的 $4\\%$，其中甚至包含一名联赛 $344$ 分，排名浙江第 $4$，不出意外必然进入国家集训队的选手。这不禁让人联想，其中是不是有其它的利益关系呢？ $\\rm CCF$ 这样做并没有任何法律依据，而仅仅是搬出了 “ 国务院办公厅近日印发的《关于全面加强新时代语言文字工作的意见》指出，要“加强语言文明教育，强化对互联网等各类新媒体语言文字使用的规范和管理，坚决遏阻庸俗暴戾网络语言传播，建设健康文明的网络语言环境。” 这样一段并不具有法律效力的文本，就对 $5$ 名选手做出了如此严厉的处罚。这种行为本就违反了中国科学技术协会发布的《中国科协全国五项学科竞赛条例》中 “ 不可擅自更改参赛学生的竞赛结果或成绩 ” 这一条款。 $\\rm CCF$ 做出这样的事非但没有法律依据，并且还是在没有任何提前通知的情况下猝然做出的。这不禁让人忧心，如果今后某位选手在考完试后得罪了某位 $\\rm CCF$ 的领导，那他是不是可以生造一条莫须有的规定来取消这位选手的成绩并将他禁赛呢？这未免太可怕了！ $\\quad$因此，我作为一名现役的高二信息竞赛生，在此对 $\\rm CCF$ 提出我们 $\\rm OIer$ 的共同诉求 ：撤销对 $5$ 名选手取消成绩和禁赛一年的处罚，将对它们的惩罚限定在批评教育的范畴内。如果贵学会坚持认为他们的行为对自己造成了严重的声誉影响，可以依法向他们提出合理的经济赔偿。 $\\quad$我奉劝中国计算机学会，既然要承办信息学奥林匹克竞赛，那就要秉承奥林匹克精神，守住竞赛公平的底线，而不是成为用心险恶之人作恶的工具。 $\\quad$作为一名中学生，我当然对改变此事无能为力。但 $\\rm OIer$ 不是一名中学生，而是千千万万心怀公义的少年。若是 $\\rm CCF$ 继续执迷不悟，非要一意孤行，将 $\\rm OI$ 变成自己滥权和敛财的工具，那么必将被另一个更有能力的组织取代。事实上，我期待这一天的到来！ $\\quad$最后我想说，国家交给任何组织的公权力都不是让其肆意滥用的，竞赛这种为国举才的大事不能用于满足某些人的私利，希望 $\\rm CCF$ 悬崖勒马，不要陷自己于不仁不义不法之地。 $\\quad$此致。 $\\quad$下附信息学竞赛赛程和基本规则，以助不了解信息学竞赛者快速理解上文中某些内容 ： $\\quad$信息学竞赛的赛程是 ： $\\quad$初赛 $+~\\rm CSP$ ：决定选手是否有资格参加 联赛 $\\rm (NOIp)$，允许社会人员参与。并且 $\\rm CCF$ 曾宣布过 “ $\\rm CSP$ 与 $\\rm NOI$ 系列比赛没有任何关系” ，但最后还是成为了 $\\rm NOIp$ 的预选赛，其真实目的也不过是为了对抗教育部 “ 竞赛不可收费 ” 的规定，违规收取选手的参赛费罢了。 $\\quad \\rm NOIp$ ：全国中学生信息联赛，对于一般选手来说这是一个赛季中最重要的比赛，将评出省一二三等奖，在 $\\rm -OH$ 计划出台后已无实际作用，或许更大程度上是一个选手认真参加过 $\\rm OI$ 的证明。 $\\quad$省选 ：全国高中生信息竞赛省队选拔赛，用于选拔各省省队去参加 国赛 $\\rm (NOI)$，每个省的名额在 $10$ 人左右，根据各省成绩好坏会有所增减。选拔方式为，将联赛和省选分数计算其占该省最高分比例后，分别以 $0.4,0.6$ 的权重加权而得的值降序排列，从前往后取至省队名额。同时每所学校的进队人数不可占省队名额的 $1 / 3$ 以上（四舍五入），因该限制而空出的名额向后顺延。 $\\quad \\rm NOI$ : 全国高中生信息竞赛，绝大多数顶尖选手的最终挑战，前 $50$ 名进入国家集训队保送清北，$51\\sim 200$ 名获得银牌破格入围 $\\rm -OH$，除了这 $200$ 人之外，无论获得其它什么奖项都仅作为纪念和荣誉，他们将带着对 $\\rm OI$ 的回忆回归文化课。 $\\quad$信息学竞赛的评分机制是 : $\\quad$初赛 ：笔试，题型为选择题和填空题，全部随机选择的期望分数可以晋级 $\\rm CSP.$ $\\quad \\rm CSP,NOIp~:~CSP~4$ 小时，$\\rm NOIp~4.5$ 小时，均为 $4$ 道题。 $\\quad$省选，$\\rm NOI$ ：均为两场，每场 $5$ 小时，$3$ 道题。 $\\quad$除了初赛之外，考试中的每道题形如，给定一个问题，如 “ 给出两个数，求它们的和 ”，你需要在规定时间内编写一个程序用来解决它。考完之后选手编写的程序会被上交，统一进行评测。 $\\quad$评测时评测机会给出一些输入文本，待测程序读取后会按照选手所编写的程式对其进行一定处理，然后给出输出文本。如果待测程序在规定时间内给出了输出文本，评测机会将它与标准答案进行对比，如果完全相同（也有一些非传统评测规则并非如此，此处略过）则选手获得该测试点的分数。比如说在之前那个问题中，评测机若给出输入文本 “ $2~3$ ”，那么一个正确的程序应该输出 “ $5$ ”，并且可以获得这个测试点的分数。 $\\quad$在 $\\rm OI$ 赛制中，每道题目的分数均为 $100$，最后每道题的得分之和就是一场考试的总分。当然，每道题的分数并不是非零即 $100$，大多数题目会给出若干子任务，如果选手无法解决完整的问题，可以选择一些弱化问题来解决，并获得相应的部分分。","tags":"oi ccf noip"},{"title":"生成函数强化训练","url":"/2023/06/24/sheng-cheng-han-shu-qiang-hua-xun-lian/","text":"$\\rm [集训队作业2013]城市规划$ 考虑 $\\rm EGF$ 的组合意义，可以发现若设任意图方案数的 $\\rm EGF$ 为 $F(x)$，连通图的 $\\rm EGF$ 为 $G(x)$，显然任意图计数可以被看做先将 $n$ 个点分进若干个非空子集，然后做连通图计数的方案数，那么根据之前的结论，有 ： $$F(x) = \\exp G(x) \\iff G(x) = \\ln F(x) $$显然有 $F(x) = \\sum _ n 2 ^ {\\binom{n}{2}} x ^ n$，于是只需直接对其求 $\\ln$ 即可。 时间复杂度 $\\Theta(n \\log n).$ $\\rm Code~Link$ $\\rm [CF438E]The~Child~and~Binary~Tree$ 首先可以考虑一个 $\\rm DP$，设 $f_S$ 表示点权之和为 $S$ 的二叉树数量，迭代时可以考虑枚举左子树的权值和 $S_l$，右子树的权值和 $S_r$ 和根节点的权值 $w$，那么有 $f_{S_l + S_r + w} = \\sum _{S_l} \\sum _{S_r} \\sum _{w \\in C} f_{S_l} f_{S_r}.$ 容易发现，这个式子可以用三个多项式的卷积来拟合，设 $F(x) = \\sum _ n f_n x ^ n, G(x) = \\sum _ n [n \\in C] x ^ n$，于是有 ： $$F = F ^ 2 G + 1 $$最后的 $+1$ 是为了补齐常数项，因为 $f_0$ 为 $1.$ 解方程可以得到 ： $$F = \\frac{1 \\pm \\sqrt{1 - 4G}}{2G} $$由于有两个解，显然不可能都成立，于是考虑 $x \\to 0$ 时的特殊情况。 当 $x \\to 0$ 时，$F(x) \\to 1,G(x) \\to 0.$ $$\\lim _ {x \\to 0} \\frac{1 + \\sqrt{1 - 4G}}{2G} = +\\infty \\not= \\lim _ {x \\to 0} F $$$$\\lim _ {x \\to 0} \\frac{1 - \\sqrt{1 - 4G}}{2G} = 1 = \\lim _ {x \\to 0} F $$于是选取 $F= \\frac{1 - \\sqrt{1 - 4G}}{2G}$ 作为方程的解。 到这一步，我们发现一个问题，因为 $G(x)$ 的常数项为 $0$，所以 $G(x)$ 不可以求逆。 考虑对解做变换，这里选取分子有理化 ： $$F = \\frac{\\left(1 - \\sqrt{1 - 4G}\\right)\\left(1 + \\sqrt{1 - 4G}\\right)}{2G\\left(1 + \\sqrt{1 - 4G}\\right)} = \\frac{2}{1 + \\sqrt{1 - 4G}} $$可以发现分母的常数项必定不为 $0$，于是做多项式开方和多项式求逆即可。 时间复杂度 $\\Theta(n \\log n).$ $\\rm Code~Link$ $\\rm [国家集训队]整数的~lqp~拆分$ 设 $\\{f_n\\},\\{g_n\\}$ 分别为斐波那契数列和答案序列，$F(x)$ 和 $G(x)$ 分别为它们的生成函数。 显然有斐波那契数列的生成函数 ： $$F(x) = \\frac{x}{1 - x - x ^ 2} $$而对于 $G(x)$，可以发现如果 $g_i$ 已经被求出来了，那么给所有的拆分加上一个数 $n - i$ 即可得到 $g_n$ 的所有拆分，$g_i$ 对 $g_n$ 的贡献为 $g_i \\times f_{n - i}.$ 于是有 $g_n$ 的递推式 ： $$g_n = \\sum _ {i = 0} ^ {n- 1} g_i \\times f_{n - i} $$将 $\\{g_n\\}$ 带入 $G(x)$ 可得 ： $$G(x) = \\sum _ n x ^ n \\sum _ {i = 0} ^ {n - 1} g_i f_{n - i} $$可以发现等式右边实际上是卷积的形式，于是有 ： $$G = GF $$但是我们发现这样的话 $G(x) = 0$，原因是 $g_0 = 0$，于是我们强制 $g_0 = 1$，得到 ： $$G = GF + 1 $$$$G(x) = \\frac{1}{1 - F(x)} = 1 + \\frac{x}{1 - 2x - x ^ 2} $$可以发现现在求出的 $G(x)$ 比实际值多了 $1$，因为我们将 $g_0 = 0$ 强制变成了 $g_0 = 1$，修正后有 ： $$G(x) = \\frac{x}{1 - 2x - x ^ 2} = \\frac{\\frac{\\sqrt{2}}{4}}{1 - (1 + \\sqrt{2})x} + \\frac{-\\frac{\\sqrt{2}}{4}}{1 - (1 - \\sqrt{2})x} $$$$[x ^ n]G(x) = \\frac{\\sqrt{2}}{4}(1 + \\sqrt{2}) ^ n - \\frac{\\sqrt{2}}{4}(1 - \\sqrt{2}) ^ n $$最后求出 $\\sqrt{2}$ 在模 $10 ^ 9 + 7$ 意义下的二次剩余，并且用拓展欧拉定理即可计算出答案。 时间复杂度 $\\Theta(\\log n).$ $\\rm Code~Link$ $\\rm [HAOI2018]染色$ 首先考虑二项式反演 ： 设 $f_i$ 表示恰好有 $i$ 个数的数量为 $S$ 的方案数，$g_i$ 表示钦点 $i$ 个数的数量为 $S$ 的方案数，显然有 ： $$g_k = \\dbinom{m}{k} \\times \\frac{n ^ {\\underline{kS}}}{(S!) ^ k} \\times (m - k) ^ {n - kS} $$$$g_k = \\sum_{i = k} ^ m \\dbinom{i}{k} f_i \\iff f_k = \\sum _ {i = k} ^ m (-1) ^ {i - k} \\dbinom{i}{k} g_i $$$$Ans = \\sum _ {i = 0} ^ m w_if_i $$于是我们考虑如何对于每个 $i \\in [0, m]$ 求出 $f_i$，这里有个技巧 ： $$\\begin{aligned} f_k &amp;= \\sum _ {i = k} ^ m (-1) ^ {i - k} \\frac{i!}{k!(i - k)!} g_i\\\\ &amp;= k! \\sum _ {i = k} ^ m i! g_i \\times \\frac{(-1) ^ {i - k}}{(i - k)!} \\end{aligned} $$容易发现上式可以用差值卷积计算，时间复杂度 $\\Theta(n \\log n).$ $\\rm 付公主的背包$ 容易发现若设每种大小的物品的数量为 $f_i$，那么答案的生成函数为 ： $$\\prod _ i \\left (\\sum _ j x ^ {ji}\\right) ^ {f _ i} = \\prod _ i \\left(\\frac{1}{1 - x ^ i}\\right) ^ {f _ i} $$可以直接使用欧拉变换的求解方式。 时间复杂度 $\\Theta(n \\log n).$ $无标号无根树计数$ 考虑设 $f_n$ 表示大小为 $n$ 的无标号有根树的方案数，$F(x)$ 为数列 $f$ 的生成函数。 可以发现，如果将一颗大小为 $n$ 的无标号有根树的根去除，那么剩下的子树是一个个相同的子问题，只要子树大小的和为 $n - 1$，再加上根结点就可以唯一确定地拼出一颗无标号有根树。于是有生成函数方程 ： $$F(x) = x \\cdot \\varepsilon \\circ F(x) $$求解这个生成函数方程有两种方法，第一种是直接化简，分治多项式乘法求解 ： $$F(x) = x \\prod _ i (1 - x ^ i) ^ {-f_i} $$考虑对两边取 $\\ln$，将连乘转连加 ： $$\\ln F(x) = \\ln x - \\sum _ i f_i \\ln (1 - x ^ i) $$对数不好处理，考虑求导 ： $$\\frac{F'(x)}{F(x)} = \\frac{1}{x} + \\sum _ i if_i \\times \\frac{x ^ {i - 1}}{1 - x ^ i} $$将两边同时乘以 $xF(x)$ ： $$xF'(x) = F(x) + F(x) \\sum _ i if_i \\frac{x ^ i}{1 - x ^ i} $$考虑将右半部分还原成 $F(x)$ 表示 ： $$xF'(x) = F(x) + F(x)\\left(\\sum _ {i \\geqslant 1} x ^ i F'(x ^ i)\\right) $$设 $G(x) = \\sum _ k x ^ k F'(x ^ k)$，简单推一推 ： $$G(x) = \\sum _ k x ^ k \\sum _ {i\\geqslant 1} if _ i \\left(x ^ {k}\\right) ^ {i - 1} = \\sum _ k \\sum _ i i f _ i x ^ {ik} = \\sum _ n x ^ n \\sum _ {d | n} d f _ d $$故 $g_n = \\sum _ {d | n} df_d,g_1 = f_1 = 1.$ 因此 ： $$f_n = \\frac{1}{n - 1} \\sum _ {k = 1} ^ {n - 1} f _ k g _ {n - k} $$$f$ 使用分治多项式乘法求解，$g$ 暴力求解即可做到 $\\Theta(n \\log ^ 2 n).$ 另一种方法是使用牛顿迭代 ： 显然我们要求解方程 $G \\circ F(x) = F(x) - x \\cdot \\varepsilon \\circ F(x) = 0$. 假设当前已经求出了方程在模 $x ^ n$ 意义下的解 $F_0(x)$，设方程在模 $x ^ {2n}$ 意义下的解为 $F(x)$，众所周知有 ： $$F(x) = F_0(x) - \\frac{G \\circ F_0(x)}{G' \\circ F_0(x)} $$我们知道，$\\varepsilon \\circ F(x)$ 可以在 $\\Theta(n \\log n)$ 的时间复杂度内求出，$F'(x)$ 可以 $\\Theta(n)$ 求，所以可以在 $\\Theta(n \\log n)$ 的时间复杂度内求下式 ： $$F(x) = F_0(x) - \\frac{F_0(x) - x \\cdot \\varepsilon \\circ F_0(x)}{[F_0(x) - x \\cdot \\varepsilon \\circ F_0(x)]'} $$用上式迭代即可算出 $F(x)$，时间复杂度 $\\Theta(n \\log n).$ 现在我们已经求出了无标号有根树的方案数，考虑将无标号无根树的方案数容斥出来。 考虑钦点无标号无根树的根是它的重心，于是只需要去掉根不是重心的无标号有根树的方案数可以了，分类讨论 ： 如果重心唯一，那么一定存在一颗子树的大小大于 $\\left\\lfloor\\frac{n}{2}\\right\\rfloor$，考虑枚举它的大小 $i$，容易发现这颗子树的方案数和将它切除后树的方案数都是无标号有根树计数问题，其答案我们已经算出，于是总方案数需要减去 $\\sum _ {i = \\left\\lfloor\\frac{n}{2}\\right\\rfloor + 1} ^{n - 1} f_i \\times f_{n - i}.$ 如果重心不唯一，那么一棵树还会在两个重心上分别被计算，这种方案只会在 $n$ 为偶数的情况下出现。考虑到这两个重心一定相连，于是将它们之间的连边断开后形成的两个子树的方案数是独立的。但是我们发现，当两颗子树完全相同时，分别以它的两个重心为根时形成的有根树是同构的，所以我们还是只会将它计算一次，故算重的方案中不包括两颗子树相同的情况，于是总方案数还需要减去 $\\binom{f_{\\frac{n}{2}}}{2}.$ 综上，问题得到解决，时间复杂度为 $\\Theta(n \\log ^ 2 n)$ 或 $\\Theta(n \\log n).$ $\\rm [CEOI2004]Sweets$ 考虑构造 $F_i(x) = \\sum _ {j = 0} ^ {m _ i} x ^ j$，容易发现题目要求的就是 $\\prod _ {i = 1} ^ n F_i(x)$ 的系数前缀和。 于是再构造 $F_0(x) = \\sum _ i x ^ i$，将它和原本的 $n$ 个幂级数卷在一起，现在考虑求 $F(x) = \\prod _ {i = 0} ^ n F_i(x)$ 的第 $L$ 项系数。 容易发现有 ： $$F(x) = \\frac{(1 - x ^ {m_1 + 1})(1 - x ^ {m_2 + 1})\\cdots(1 - x ^ {m_n + 1})}{(1 - x) ^ {n + 1}} $$观察到 $n$ 很小，考虑暴力将分子拆开，于是分式变成了 $2 ^ n$ 个形如 $\\frac{x ^ k}{(1 - x) ^ {n + 1}}$ 的部分之和。 容易发现 ： $$[x ^ L]\\frac{x ^ k}{(1 - x) ^ {n + 1}} = \\dbinom{n + L - k}{n} $$于是只需要求 $2 ^ {n + 1}$ 次形如 $\\binom{t}{n}$ 的组合数即可。 到这里我们又发现模数 $p$ 不是质数，于是考虑将式子变形 ： $$\\dbinom{t}{n}~\\bmod~p = \\frac{t^{\\underline{n}}}{n!}~\\bmod~p = \\frac{t ^ {\\underline{n}}~\\bmod~n!\\cdot p}{n!}~\\bmod~p $$于是这样就可以 $\\Theta(n)$ 求解组合数了，总时间复杂度 $\\Theta(2^n n).$ $\\rm [51nod1728]不动点$ 简化题意 ：求有多少个从 $\\{1,2,\\cdots,n\\}$ 到 $\\{1,2,\\cdots,n\\}$ 的映射 $f$，满足 ： $$\\underbrace{f \\circ f \\circ \\cdots \\circ f}_{k}=\\underbrace{f \\circ f \\circ \\cdots \\circ f}_{k-1} $$保证 $nk \\leqslant 2 \\times 10 ^ 6,1\\leqslant k \\leqslant 3.$ 可以发现这题本质上就是在求深度不超过 $k$，环大小为 $1$ 的基环内向树森林的数量，进一步发现其等价于树高不超过 $k$ 的有标号有根树森林的数量。 考虑设树高不超过 $k$ 的有标号有根树数量的 $\\rm EGF$ 为 $\\hat{F}_k(x).$ 计算考虑递推，深度不超过 $k$ 的树可以看作若干棵深度不超过 $k - 1$ 的树全部接在一个点上，于是有 ： $$\\hat{F}_k(x) = x\\cdot \\exp \\hat{F}_{k - 1}(x) $$考虑到需要求的是森林的数量，于是答案的指数型生成函数为 $\\exp \\hat{F}_k(x).$ 时间复杂度 $\\Theta(kn\\log n).$ $\\rm [CF891E]Lust$ 考虑一次对 $x$ 的操作造成的影响，他会使 $a_x$ 减少 $1$，答案增加 $\\prod _ {i \\not= x} a_i$，$\\prod _ i a_i$ 减少 $\\prod _ {i \\not= x} a_i.$ 于是我们可以发现，一次操作对答案的贡献等于 $\\prod _ i a_i$ 的变化量。进一步的，最终答案等于 $k$ 次操作进行完后 $\\prod _ i a_i$ 的变化量。假设第 $a_i$ 被操作了 $b_i$ 次，那么答案为 $\\prod _ i a_i - \\prod _ i (a_i - b_i).$ 考虑计算所有情况下 $\\prod _ i (a_i - b_i)$ 的和，最后再将答案除以 $n ^ k.$ 假设有两个集合 $S,T,S \\cap T = \\varnothing$，$f_i$ 表示 $\\sum b_k = i,k\\in S$ 对答案的贡献，$g_i$ 表示 $\\sum b_k = i,k\\in T$ 对答案的贡献，$h_i$ 表示 $\\sum b_k = i,k\\in S \\cup T$ 对答案的贡献，那么显然有 ： $$g_n = \\sum _ {i = 0} ^ n \\dbinom{n}{i} f_i \\times g_{n - i} $$因为 $f_i$ 和 $g_{n - i}$ 联合起来的贡献是它们的乘积，并且由于操作有序，所以将 $n$ 次操作分配到它们还导致要乘上 $\\binom{n}{i}$ 的方案数。 很明显，这个式子可以用 $\\rm EGF$ 来拟合，设 $\\hat{F}_i(x) = \\sum _ j (a_i - j) \\frac{x ^ j}{j!}$，那么答案的生成函数为 ： $$\\begin{aligned} \\hat{F}(x) &amp;= \\prod _ i F_i(x)\\\\ &amp;= \\prod _ i \\left( \\sum _ j (a_i - j) \\frac{x ^ j}{j!} \\right)\\\\ &amp;= \\prod _ i \\left( a_i \\sum _ j \\frac{x ^ j}{j!} - \\sum _ {j} \\frac{x ^ {j + 1}}{j!} \\right)\\\\ &amp;= \\prod _ i (a_i - x)e ^ x\\\\ &amp;= e ^ {nx} \\prod _ i (a_i - x) \\end{aligned} $$$\\prod _ i (a_i - x)$ 直接分治乘可以做到 $\\Theta(n \\log ^ 2 n)$，$e ^ {nx}$ 的系数可以直接求，由于 $\\prod _ i (a_i - x)$ 的最高次数为 $n$，所以直接枚举计算即可。 总时间复杂度 $\\Theta(n \\log ^2 n).$","tags":"oi 题解 组合数学 ntt 生成函数 图计数"},{"title":"「省选联考 2021」矩阵游戏","url":"/2023/06/24/sheng-xuan-lian-kao-2021-ju-zhen-you-xi/","text":"$\\rm Sol.$ 首先可以发现，若不考虑 $a_i \\leqslant 10 ^ 6$ 的限制，那么构造一组合法解是容易的。 同时可以发现，如果对一行或一列进行 $+1, -1, +1, -1, \\cdots $ 操作，那么得到的 $a_i$ 还是合法的。 设 $c_i$ 和 $d_i$ 分别表示每行，每列进行了多少次操作，下面两个矩阵即为 $a_{i, j}$ 得到真实值需要加上修改值的系数： $$\\begin{bmatrix} +1 &amp; -1 &amp; +1 &amp; -1 \\\\ +1 &amp; -1 &amp; +1 &amp; -1 \\\\ +1 &amp; -1 &amp; +1 &amp; -1 \\\\ +1 &amp; -1 &amp; +1 &amp; -1 \\\\ \\end{bmatrix} \\rm and \\begin{bmatrix} +1 &amp; +1 &amp; +1 &amp; +1 \\\\ -1 &amp; -1 &amp; -1 &amp; -1 \\\\ +1 &amp; +1 &amp; +1 &amp; +1 \\\\ -1 &amp; -1 &amp; -1 &amp; -1 \\\\ \\end{bmatrix} $$列出需要满足的方程 ： $$ 0 \\leqslant a_{i, j} \\pm c_i \\pm d_j \\leqslant 10 ^ 6 $$可以发现，若将 $c_i$ 和 $d_i$ 作为未知数，可能会出现 “求和约束”，这是难以解决的。 观察到发生这个问题的本质是因为在两个矩阵的相同位置出现了相同的符号，于是考虑重构矩阵： $$\\begin{bmatrix} +1 &amp; -1 &amp; +1 &amp; -1 \\\\ -1 &amp; +1 &amp; -1 &amp; +1 \\\\ +1 &amp; -1 &amp; +1 &amp; -1 \\\\ -1 &amp; +1 &amp; -1 &amp; +1 \\\\ \\end{bmatrix} \\rm and \\begin{bmatrix} -1 &amp; +1 &amp; -1 &amp; +1 \\\\ +1 &amp; -1 &amp; +1 &amp; -1 \\\\ -1 &amp; +1 &amp; -1 &amp; +1 \\\\ +1 &amp; -1 &amp; +1 &amp; -1 \\\\ \\end{bmatrix} $$于是此时就可以使用差分约束的常规求解方式了。 使用 $\\rm SPFA$ 的时间复杂度为 $\\Theta[n ^ 2 (n + m)]$，常数很小，可以通过。 $\\rm Code$ #include &lt;bits/stdc++.h&gt; using namespace std; #define int long long const int N = 300 + 10, M = N * N &lt;&lt; 1; int T, n, m, a[N][N], b[N][N]; int last[N &lt;&lt; 1], to[M], Next[M], W[M], tot; int vis[N &lt;&lt; 1], dis[N &lt;&lt; 1], num[N &lt;&lt; 1]; queue &lt;int&gt; Q; void Link (int u, int v, int w) &#123; to[++tot] = v, W[tot] = w, Next[tot] = last[u], last[u] = tot; &#125; signed main () &#123; scanf(&quot;%lld&quot;, &amp;T); while (T--) &#123; scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); tot = 0; for (int i = 0; i &lt;= n + m; i++) last[i] = num[i] = 0, vis[i] = false, dis[i] = 1e9; while (!Q.empty()) Q.pop(); for (int i = 2; i &lt;= n; i++) for (int j = 2; j &lt;= m; j++) scanf(&quot;%lld&quot;, &amp;b[i][j]); for (int i = 1; i &lt;= n; i++) a[i][1] = 0; for (int i = 1; i &lt;= m; i++) a[1][i] = 0; for (int i = 2; i &lt;= n; i++) for (int j = 2; j &lt;= m; j++) a[i][j] = b[i][j] - a[i - 1][j] - a[i][j - 1] - a[i - 1][j - 1]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if ((i + j) &amp; 1) Link(n + j, i, a[i][j]), Link(i, n + j, 1e6 - a[i][j]); else Link(i, n + j, a[i][j]), Link(n + j, i, 1e6 - a[i][j]); for (int i = 1; i &lt;= n + m; i++) Link(0, i, 0); dis[0] = 0, Q.push(0), vis[0] = 1; bool flag = false; while (!Q.empty()) &#123; int u = Q.front(); if (++num[u] &gt; 10) &#123; flag = true; break; &#125; Q.pop(), vis[u] = false; for (int i = last[u]; i; i = Next[i]) if (dis[to[i]] &gt; dis[u] + W[i]) &#123; dis[to[i]] = dis[u] + W[i]; if (!vis[to[i]]) Q.push(to[i]), vis[to[i]] = true; &#125; &#125; if (flag) &#123; puts(&quot;NO&quot;); continue; &#125; puts(&quot;YES&quot;); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if ((i + j) &amp; 1) a[i][j] += dis[n + j] - dis[i]; else a[i][j] += dis[i] - dis[n + j]; printf(&quot;%lld &quot;, a[i][j]); &#125; puts(&quot;&quot;); &#125; &#125; return 0; &#125;","tags":"oi c++ 题解 省队选拔"},{"title":"「省选联考 2021」图函数","url":"/2023/06/24/sheng-xuan-lian-kao-2021-tu-han-shu/","text":"$\\rm Sol.$ 首先考虑分析 $f(u, G)$，可以观察出一些性质 ： 会产生贡献的 $v$ 必须满足 $v &lt; u.$ $v$ 与 $u$ 会产生贡献当且仅当 $u$ 和 $v$ 可以仅通过大于 $v$ 的点互达。 $\\rm Proof: $ 当 $v &gt; u$ 时 $u$ 自己都已经删掉了，肯定不能产生贡献。 如上图所示，我们不妨设 $u \\to v$ 的路径上必须经过 $x(x &lt; u)$，那么 $x$ 和 $u$ 一定相互可达，$x$ 会在统计 $v$ 的答案之前被删掉。 于是我们可以发现，若定义两点 $(u, v)$ 有贡献当且仅当 $u &gt; v$ 且 $u$ 和 $v$ 之间可以通过大于 $v$ 的点相互到达，则 $h(G)$ 就是在求解 $G$ 中所有点对的贡献之和。 我们考虑 $\\rm Floyd$ 算法的过程，实际上就是在不断求解如果只经过当前已经枚举的这些中转点 $k$，有哪些 $u$ 可以走到 $v.$ 于是求解 $h(G)$ 只需要从大到小枚举中转点 $k$，并在 $\\rm Floyd$ 的过程中记录下当前 $v = k - 1$ 的答案即可。 进一步观察发现，如果我们按照编号从大到小将边加入图 $G$，那么必然可以找到一个分界点，使得 $u$ 和 $v$ 恰好变为有贡献的点对。容易发现，这个分界点就是 $u$ 和 $v$ 可以相互到达的路径上编号最小的边的最大值。求解这个最大值是简单的，只需要将初始矩阵修改成边的编号，方程改写为 $f_{u, v} = \\max\\{f_{u, v}, \\min\\{f_{u, k}, f_{k, v}\\}\\}$ 即可。 最后用差分维护一下就可以得到最终答案。 时间复杂度 $\\Theta(n ^ 3 + m)$，常数很小，写得好的话可以通过。 为了进一步优化复杂度，我们摈弃之前使用 $\\rm Floyd$ 的想法。 考虑按编号从大到小枚举所有的边，可以发现每对点 $(u, v)(u &gt; v)$ 都会有一个成为有贡献的点对的分界点。 首先计算 $v$ 可以到达 $u$ 的分界点， $u$ 到 $v$ 的分界点可以通过在反图上进行同样的操作来计算。 有两个显然的性质 ： 有贡献的点对数量最多 $n ^ 2$ 量级。 在加边的过程中有贡献的点对数量不减。 于是考虑计算每条边加入后有贡献的点对的增量。 如上图所示，设当前加入的边为 $x \\to y$，$u_1, u_2, u_3, \\cdots $ 和 $v_1, v_2, v_3, \\cdots$ 分别为能到达 $x$ 的点和 $y$ 能到的点。 考虑用 $\\rm bitset$ 记录某个点能直接到达的所有点，能到达的所有点和能到达这个点的所有点，不妨分别设它们为 $E_u, S_u$ 和 $T_u.$ 可以发现，若点对 $(u, v)$ 因 $x \\to y$ 而增加，需要满足 ： $u$ 在加入 $x \\to y$ 之前不能到达 $y.$ $u$ 在加入 $x \\to y$ 之前要能到达 $x.$ 路径上所有点的编号都不小于 $u.$ 首先前两个条件可以通过 $T_x \\cap (U - T_y)$ 简单地得到，考虑枚举集合中的所有点作为 $u$ 从 $y$ 开始遍历。遍历的过程中，每一步要将 $E_v \\cap (U - S_u)$ 中所有编号大于 $u$ 的点作为下一个遍历的点。另外，还要记得随时更新 $S_u.$ 考虑这样做的复杂度为什么是对的。因为每一步都会走到一个合法的 $v$，所以答案每一步会增加 $1.$ 并且每走一步都需要计算 $E_v \\cap (U - S_u)$，其时间复杂度为 $\\Theta(\\frac{n}{\\omega}).$ 另外，每加入一条边都需要计算 $T_x \\cap (U - T_y)$，其时间复杂度也为 $\\Theta(\\frac{n}{\\omega}).$ 于是总时间复杂度为 $\\Theta(\\frac{n ^ 3 + nm}{\\omega})$。 $\\rm Code$ #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e3 + 10, M = 2e5 + 10; int n, m, E[N][N], ans[M], Eik, tmp; int main () &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int u, v, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), E[u][v] = i; for (int k = n; k &gt;= 1; k--) &#123; for (int i = 1; i &lt;= n; i++) if (E[i][k]) &#123; int j; for (j = 1; j + 7 &lt;= n; j += 8) &#123; Eik = E[i][k]; tmp = Eik &lt; E[k][j] ? Eik : E[k][j]; E[i][j] = E[i][j] &gt; tmp ? E[i][j] : tmp; tmp = Eik &lt; E[k][j + 1] ? Eik : E[k][j + 1]; E[i][j + 1] = E[i][j + 1] &gt; tmp ? E[i][j + 1] : tmp; tmp = Eik &lt; E[k][j + 2] ? Eik : E[k][j + 2]; E[i][j + 2] = E[i][j + 2] &gt; tmp ? E[i][j + 2] : tmp; tmp = Eik &lt; E[k][j + 3] ? Eik : E[k][j + 3]; E[i][j + 3] = E[i][j + 3] &gt; tmp ? E[i][j + 3] : tmp; tmp = Eik &lt; E[k][j + 4] ? Eik : E[k][j + 4]; E[i][j + 4] = E[i][j + 4] &gt; tmp ? E[i][j + 4] : tmp; tmp = Eik &lt; E[k][j + 5] ? Eik : E[k][j + 5]; E[i][j + 5] = E[i][j + 5] &gt; tmp ? E[i][j + 5] : tmp; tmp = Eik &lt; E[k][j + 6] ? Eik : E[k][j + 6]; E[i][j + 6] = E[i][j + 6] &gt; tmp ? E[i][j + 6] : tmp; tmp = Eik &lt; E[k][j + 7] ? Eik : E[k][j + 7]; E[i][j + 7] = E[i][j + 7] &gt; tmp ? E[i][j + 7] : tmp; &#125; for ( ; j &lt;= n; ++j) E[i][j] = max(E[i][j], min(E[i][k], E[k][j])); &#125; for (int u = k + 1; u &lt;= n; u++) ans[min(E[u][k], E[k][u]) - 1]++; &#125; for (int i = m; i &gt;= 0; i--) ans[i] += ans[i + 1]; for (int i = 0; i &lt;= m; i++) printf(&quot;%d &quot;, ans[i] + n); return 0; &#125;","tags":"oi c++ 题解 省队选拔"},{"title":"「省选联考 2021」卡牌游戏","url":"/2023/06/24/sheng-xuan-lian-kao-2021-qia-pai-you-xi/","text":"$\\rm Sol$ 法一 可以证明，若进行了操作 $a_i \\to b_i$，那么 $\\forall j &lt; i$，操作 $a_j \\to b_j$ 都进行了。因为如果存在 $j &lt; i$，$a_i \\to b_i$ 执行了，但 $a_j \\to b_j$ 没执行，那么 $a_i \\to b_i$ 执行就没有意义，因为 $a_j$ 还是会作为最小值。 同理，我们可以证明操作序列也是后缀连续的。 于是我们可以枚举操作了的前缀，然后预处理出 $b$ 序列后缀最大值等信息即可计算答案。 时间复杂度 $\\Theta(n).$ 法二 容易发现答案满足可二分性，于是二分答案 $\\rm mid.$ 如果选定了答案区间的左端点，那么右端点可以容易地确定。 于是问题转化成了一个前后缀 $\\rm RMQ.$ 时间复杂度 $\\Theta(n \\log n).$ 法三 考虑将 $a_i$ 和 $b_i$ 全部取出来排序，可以发现答案是删去一些数后的最大值减最小值。 于是双指针维护，记录当前删去了多少个 $a_i$ 和一张牌的 $a_i$ 和 $b_i$ 是否同时被删掉即可。 时间复杂度 $\\Theta(n \\log n)$，因为要排序。 $\\rm Code$ #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 2e6 + 10; int n, m, num, ans = INT_MAX; pair &lt;int, int&gt; a[N]; bool tag[N]; int idx (int pos) &#123; return a[pos].second - (a[pos].second &lt;= n ? 0 : n); &#125; bool check (int pos) &#123; if (a[pos].second &lt;= n &amp;&amp; num &gt;= m) return false; if (tag[idx(pos)]) return false; return true; &#125; void del (int pos) &#123; if (a[pos].second &lt;= n) num++; tag[idx(pos)] = true; &#125; void rev (int pos) &#123; if (a[pos].second &lt;= n) num--; tag[idx(pos)] = false; &#125; int main () &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n &lt;&lt; 1; i++) scanf(&quot;%d&quot;, &amp;a[i].first), a[i].second = i; sort(a + 1, a + 2 * n + 1); int l = 1, r = 2 * n; while (check(r)) del(r), r--; while (r &lt;= n &lt;&lt; 1) &#123; ans = min(ans, a[r].first - a[l].first); if (a[l].second &lt;= n) while (num &gt;= m &amp;&amp; r &lt;= 2 * n) rev(r + 1), r++; while (tag[idx(l)] &amp;&amp; r &lt;= 2 * n) rev(r + 1), r++; del(l), l++; &#125; printf(&quot;%d\\n&quot;, ans); return 0; &#125;","tags":"oi c++ 题解 省队选拔"},{"title":"复杂度分析","url":"/2023/06/24/fu-za-du-fen-xi/","text":"主定理 主定理 $\\rm (Master~Theorem)$ 被用来求解一类递归算法的时间复杂度，假设有递推式形如: $$T(n) = aT\\left(\\frac{n}{b}\\right) + f(n) $$上式的含义是，存在一个规模为 $n$ 的问题可以被划分成 $a$ 个规模为 $\\frac{n}{b}$ 的问题，且将它们合并的运算复杂度为 $f(n)$。 那么根据主定理，有 ： $$T(n)= \\begin{cases} \\Theta\\left(n^{\\log _{b} a}\\right) &amp; f(n)=O\\left(n^{\\log _{b} a-\\epsilon}\\right) \\\\ \\Theta(f(n)) &amp; f(n)=\\Omega\\left(n^{\\log _{b} a+\\epsilon}\\right) \\\\ \\Theta\\left(n^{\\log _{b} a} \\log ^{k+1} n\\right) &amp; f(n)=\\Theta\\left(n^{\\log _{b} a} \\log ^{k} n\\right), k \\geq 0 \\end{cases} $$","tags":"算法 复杂度 主定理"},{"title":"反悔贪心","url":"/2023/06/24/fan-hui-tan-xin/","text":"算法简介 反悔贪心是对贪心策略的一种优化，有些时候贪心策略是错的，但如果可以撤销之前的操作，那么就会变为正确的。 反悔贪心主要有两种。一种是反悔堆，即将之前没有选择的操作加入一个（类）堆中，保证每次取出的堆顶都是当前没有选择的策略中最优的，若由于当前操作，则将其替换。还有一种是反悔自动机，可以设计一个自动机来决策当前的操作。 另外，有一种观点认为反悔贪心的本质是贪心模拟费用流，我认为是有一定道理的，这种观点也有利于解释反悔贪心的正确性。 经典例题 [USACO09OPEN] Work Scheduling G 反悔贪心板子题。 按任务按截止时间排序，若当前这个工作做得了（即已经做的件数小于这个工作的截止日期），那么直接做，并把它的价值放进优先队列中。若当前这个工作没时间做了，我们发现如果把前面一个工作去除，这个工作就做得了，于是对比小根堆顶的价值与他的价值，谁大就保留谁。 时间复杂度 $\\Theta(n\\log n)$。 [JSOI2007] 建筑抢修 反悔贪心板子题 $\\times 2$。 我们发现每个建筑的贡献都是一样的。按建筑的 $T2$ 排序，一个个枚举，若当前建筑可以修（即之前已经选的建筑的 $T1$ 之和加上当前这个建筑的 $T1$ 不大于当前建筑的 $T2$），那么就直接将这个建筑的 $T1$ 加上并放进优先队列，并把答案 $+1.$ 若不能修，考虑到价值一样的情况下最小化总修理时间，那么将大根堆的堆顶取出，若其大于当前点的 $T1$，更新花费总时间。 时间复杂度 $\\Theta(n\\log n)$。 [P2107] 小 Z 的 AK 计划 反悔贪心板子题 $\\times 3$。 首先按机房位置升序考虑，假设你有一种到了机房就必须 $\\rm AK$ 的欲望（实际上是因为如果不 $\\rm AK$ 这个机房，就没必要走到这里，而是在之前停下），那么如果当前的总用时加上 $\\rm AK$ 这个机房的用时不到 $m$ 的时候，你就可以直接 $\\rm AK$，并将这个机房的 $\\rm AK$ 用时加入大根堆。若当前时间不够，就不断弹出堆顶，直到剩下的时间足够 $\\rm AK.$ 一边枚举一边记录当前最优答案即可。 时间复杂度 $\\Theta(n\\log n)$。 [CF865D] Buy Low Sell High 首先考虑一个贪心，对每个数选择它后面第一个比他大并且还没被选择的数，容易发现这样是错的，$\\rm Hack$ 数据如下 ： 4 1 2 3 4 于是我们考虑给上面那个贪心加上反悔操作，每次将当前值放入小根堆中，若当前枚举的这个数大于小根堆堆顶，那么就将其卖掉，获得 a[i] - Q.top() 的贡献。同时，为了之后能够反悔，我们还要将它也加入堆中，我们发现，如果后面还有一个数将其卖出，那么其等价于直接将此时的堆顶卖出。这样一来，如果我们认为某个点要卖出，那么它就要入堆两次。 时间复杂度 $\\Theta(n\\log n)$。 [国家集训队] 种树 考虑选了一个数以后会发生什么，它两边的数都不能选了。于是考虑在选了一个点之后，把它两边的数标为不能选，然后在原处加入一个权值为 $a_{i-1}+a_{i+1}-a_i$ 的点。每次取最大的点，若已标为不能选，就跳过，否则选他，然后将两边的点删去，更新链表顺序。 容易证明这样做是对的，并且可以用优先队列维护，时间复杂度 $\\Theta(n\\log n)$。","tags":"算法 oi 贪心 反悔贪心"},{"title":"线段树相关杂题","url":"/2023/06/24/xian-duan-shu/","text":"[LG5490] 扫描线 扫描线模板题，从小到大枚举横线的纵坐标，枚举到矩形下界就给这条边的左右端点构成的区间 $+1$，否则 $-1$，用线段树维护，当前线段树有值的结点个数就是这个纵坐标的贡献。 怎么维护线段树中不为 $0$ 的位置数量呢？我们发现在做扫描线的时候权值不会小于 $0$，于是我们考虑维护区间最小值和最小值的数量，这个在合并的时候，如果左右儿子的最小值相同，则将其最小值数量加起来，否则继承最小值更小的那个的最小值数量。 当然，本题还需要动态开点，所以需要维护区间内有效点的数量。 时间复杂度 $\\Theta(n\\log n)$。 [SPOJ] GSS-I 先求出前缀和，发现答案为区间最大值减最小值，但需要满足最小值在最大值右边。 对线段树的每个节点维护最小值，最大值和答案，发现答案可以从两棵子树的答案更新，也可以更新为右子树中的最大值减去左子树中的最小值。 于是直接用线段树即可维护，时间复杂度 $\\Theta(n\\log n)$。 [SPOJ] GSS-III 发现这题是带修版的 $\\rm GSS1$，但是由于前缀和无法动态修改，于是考虑直接维护区间和。 显然要维护区间和以及最大子段和，发现最大子段和需要通过左儿子的最大后缀和和右儿子的最大前缀和更新，于是再记最大前后缀和，而最大前后缀和是可以通过区间和和子节点的最大前后缀和计算的，于是这题就可以用线段树做了。 时间复杂度 $\\Theta(n\\log n)$。 [SPOJ] GSS-IV 我们发现，一个区间内如果全都是 $1$ 或 $0$，那么对它开方是没有意义的，所以记录最大值，如果最大值为 $0$ 或 $1$，那么直接跳过这个区间。 我们发现这样做每个点最多被修改 $7$ 次，故时间复杂度 $\\Theta(n\\log n)$。 [SPOJ] GSS-V 我们发现这个问题和 $\\rm GSS-I$ 很像，唯一的区别是左右两边限定了区间。我们发现如果两个区间不重合，那就是右区间最大值减左区间最小值。 若两区间重合，令从左到右三个区域分别为 $\\rm I,II,III$，首先用 $\\rm \\max\\{II\\cup III\\}-\\min\\{I\\}$ 更新答案，然后用 $\\rm \\max\\{III\\}-\\min\\{I\\cup II\\}$ 更新答案，最后只剩下两个端点都在 $\\rm II$ 内的答案，这个就是 $\\rm GSS-I$。 时间复杂度 $\\Theta(n\\log n)$。 [LG4198] 楼房重建 首先肯定将每个楼房的信息转化为斜率。显然要维护区间最大值和从这个区间左端点开始能看到多少栋楼。 现在考虑将左右区间合并，显然要先将左区间的答案加上，然后考虑右区间能看到多少个点。 如果左区间的最大值小于右区间的左区间的最大值，那么肯定对右区间的右区间没有影响，将右区间的右区间的答案加上，左区间递归。 如果左区间的最大值大于右区间的左区间的最大值，那么右区间的左区间肯定一个都看不到，直接将右区间的右区间递归下去。 单次合并时间复杂度 $\\Theta(n\\log n)$，总时间复杂度 $\\Theta(n\\log ^2n)$。 $\\quad\\rm PS:$ 这题有个坑点，计算右区间的右儿子的答案的时候不能写成 ans[RS]，而是要写成 ans[p] - ans[LS]，因为右儿子的答案可能会被左儿子挡掉一些，这些还是不能算进去。 [LG1502] 窗口的星星 考虑将每颗行星变成一个带权矩形，我们发现最大亮度和就是最大矩形交的权值之和。 考虑用扫描线，维护区间最大值即可。 坑点 $1:$ 由于边界上的点不用算，所以矩形右上角为 $(x+w-1,y+h-1).$ 坑点 $2:$ 我们在每次修改过后都统计了一遍答案，所以当线段纵坐标相同的时候，删除要排在前面，防止统计了一个不合法的大的答案。 [CF240F] TorCoder 考虑一次操作干了什么事情，若存在一个以上字母出现了奇数次，则无法重排，否则将出现奇数次的字母放在最中间，然后将所有字母按照从小到大再从大到小的顺序放在这个字母的两边。 于是可以对每个字母开一颗线段树，维护区间赋值操作和区间求数量操作即可。 时间复杂度 $\\Theta(n\\log n|\\Sigma|)$。 [CF242E] XOR on Segment 考虑对每一位开一颗线段树，问题就变成了维护一个 $0/1$ 序列，支持区间取反和区间求和。 时间复杂度 $\\Theta(n\\log^2n)$。 [CF414C] Mashmokh and Reverse Operation 我们发现这个题目中区间的结构很像一颗线段树，于是考虑它的性质。 发现交换一个翻转一个区间等价于将它的两个子区间交换，然后递归操作。而一个区间的逆序对数量为两个子区间之间的逆序对数量加上两个子区间内部的逆序对数量。 于是考虑维护每一层每一个结点的两个子区间之间的逆序对数量之和。这样，修改操作就变成了将某一层下面的所有区间翻转，由于层数只有 $20$，所以直接维护每一层是否被翻转即可。求当前的答案只需要预处理每一层的所有节点的两个子区间之间的答案之和即可，发现一层区间一定是一起翻转，于是每一层只有两种状态，分别预处理即可。 时间复杂度 $\\Theta[(2^n+m)n]$。 [CF446C] DZY Loves Fibonacci Numbers 我们知道 $F_{n}=\\frac{\\sqrt{5}}{5}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n}-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}\\right].$ 于是可以发现只需要分别维护两个序列，在一个序列中公比相同。 故我们只需要维护首项，后面的数可以直接算出来。下传的时候给左子区间直接加上这个首项，右子区间加首项乘上 $q^{\\frac{r-l+1}{2}}$ 即可。 时间复杂度 $\\Theta(n\\log n)$。 [CF522D] Closest Equals 我们发现，如果记 $p_i$ 表示距离 $i$ 最近的在 $i$ 之前的与 $i$ 颜色相同的点与 $i$ 的距离，那么对于一个询问 $[l,r]$，其答案为所有满足 $i-p_i\\geqslant l$ 和 $i\\leqslant r$ 的点中，$p_i$ 最小的那个。 于是考虑将坐标离散化，然后将询问离线下来，按右端点排序，一个个枚举 $i$，若 $p_i\\not =0$，则将 $C_{i-p_i}$ 的值与 $p_i$ 取 $\\min$，可以发现，$C$ 中区间 $[l,r]$ 内的最小值就是这个区间的答案。 单点修改，区间查询，可以使用线段树维护。可以发现 $[l,r]$ 的答案和 $[l,n]$ 的答案是相同的，于是也可以使用树状数组维护后缀和。 时间复杂度 $\\Theta(n\\log n)$。","tags":"oi 数据结构 题解 线段树"},{"title":"数列分块","url":"/2023/06/24/shu-lie-fen-kuai/","text":"基本思想 考虑一些在序列上的区间操作，如区间加和区间求和。 直接暴力做单次操作复杂度是 $\\Theta(n)$，总时间复杂度 $\\Theta(qn)$. 如果将序列分成 $\\sqrt{n}$ 块，每块长度为 $\\sqrt{n}$，并且对每个块维护里面所有元素的和，即可在 $\\Theta(\\sqrt{n})$ 的复杂度内进行单次操作。 具体实现如下： 令块的数量为 $num=\\sqrt{n}$，单个块的长度为 $siz=\\lceil\\frac{n}{num}\\rceil$. 记 $bel_i$ 表示 $i$ 号节点属于第几个块。 可以记录一些题目需要用到的信息，如 $sum_i$ 表示第 $i$ 个块内所有元素的和。 数列分块入门 9 题 T1 区间修改, 单点查询 对每个块维护整块加的值，查询的时候加上即可。 时间复杂度 $\\Theta(n\\sqrt{n})$。 T2 区间修改, 查区间内小于某个数的个数 对每个块内的元素排序，区间修改时整块大小顺序不变，散块暴力排序，查询时二分即可。 时间复杂度 $\\Theta(n\\sqrt{n}\\log n)$。 排序使用归并可以将复杂度优化到 $\\Theta(n\\sqrt{n\\log n})$。 T3 区间修改, 区间查前驱 同样是排序后在块内二分，只不过是把求比他小的数的数量改成求比它小的数中最大的那个。 时间复杂度 $\\Theta(n\\sqrt{n}\\log n)$。 排序使用归并可以将复杂度优化到 $\\Theta(n\\sqrt{n\\log n})$。 T4 区间修改, 区间求和 维护每个块的和以及加的数，用类似 $\\rm T1$ 的方法维护。 时间复杂度 $\\Theta(n\\sqrt{n})$。 T5 区间开方, 区间求和 我们发现开方操作是没办法全局维护的，于是考虑寻找开方操作的性质。 观察到每个数被开方很少的次数以后就会变成 $1$（或者它本身就是 $0$，但这部分显然没有贡献，可以直接删去），于是对每个块记录一下里面 $1$ 的个数，如果全都是 $1$，就不对它进行开方，否暴力开方即可。 求区间和还是维护一下每个块的和。 时间复杂度 $\\Theta(n\\sqrt{n})$。 T6 单点插入, 单点查询 我们发现暴力做的时候需要将所有数向后移一位，单次时间复杂度 $\\Theta(n)$。 于是考虑分块，给每个块预留 $\\sqrt{n}$ 的剩余空间用来后移，记一下当前块的长度即可。查询的时候每访问一个块就把查询编号减去当前块的长度。不难发现这样做单次操作时间复杂度 $\\Theta(\\sqrt{n}).$ 但是我们发现一个问题，如果插入全在一个块内的话复杂度很快就会变成 $\\Theta(n)$，于是考虑每进行插入操作 $\\sqrt{n}$ 次就重构分块即可。 时间复杂度 $\\Theta(n\\sqrt{n})$。 T7 区间修改(包含加和乘), 单点查询 考虑对每个块记 $\\rm add$ 和 $\\rm mul$，表示块内元素的真实值为 $a\\times \\rm mul+add$，区间加的时候，给 $\\rm add$ 加上 $k$ 即可，区间乘的时候，不仅需要给 $\\rm mul$ 乘上 $k$，还需要给 $\\rm add$ 乘上 $k.$ 时间复杂度 $\\Theta(n\\sqrt{n})$。 T8 区间查询数的个数并全部修改成这个数 我们发现如果询问区间小的话查询和修改都很容易，如果询问区间大的话会把很长一段都变成相同的数。如果记录一个块是否都是同一个数的话就很容易维护了。 不难发现这样做复杂度是 $\\Theta(n\\sqrt{n})$ 的。 T9 询问区间最小众数 记 $s_{i,j}$ 表示前 $i$ 个块中 $j$ 出现的次数，$p_{i,j}$ 表示第 $i$ 个块到第 $j$ 个块的众数。 我们发现，对于一次询问，答案一定是整块的众数或散块的众数，这个只需要对比一下即可。 时间复杂度 $\\Theta(n\\sqrt{n})$。 经典例题 [TJOI2009] 开关 记 $c_i$ 表示第 $i$ 盏灯是否开着，$sum_i$ 表示第 $i$ 个块中有多少盏灯开着，$d_i$ 表示第 $i$ 个块的状态是否整体改变。 对于区间取反操作，零散操作直接修改 $c_i$，并根据 $c_i$ 和 $d_i$ 决定 $sum_i+1$ 或 $-1$. 整块操作不用改变 $c$，直接令 $sum_i=R_i-L_i+1-sum_i$，并且将 $d_i$ 取反。 对于区间求和操作，零散点求和直接加上 $c_i\\oplus d_i$，整块求和则加上 $sum_i$。 单次操作复杂度 $\\Theta(\\sqrt{n})$，总时间复杂度 $\\Theta(q\\sqrt{n})$。 [LG3396] 哈希冲突 转化题意，设计一种数据结构，支持： 单点修改 求从某一点 $pos(pos\\leqslant d)$ 开始，以步长 $d$ 遍历数列，求所经过的所有数之和。 考虑根号分治。 对于 $d\\geqslant \\sqrt{n}$ 的询问，直接暴力查询。 对于 $d \\leqslant \\sqrt{n}$ 的询问，记 $sum_{i,j}$ 表示从 $i(i\\leqslant \\sqrt{n})$ 开始，步长为 $j(j\\leqslant \\sqrt{n})$ 的答案。预处理的时候直接枚举计算即可，时间复杂度 $\\Theta(n\\sqrt{n})$。 对于修改操作 $a[pos]\\leftarrow x$，先直接在原数列上进行修改，再考虑其对 $sum$ 数组造成了什么影响。易知，对于步长为 $d$ 的预处理数组，只会对 $sum_{pos\\%d,d}$ 造成影响，于是对每个 $d(d\\leqslant \\sqrt{n})$ 修改一下即可，单次修改时间复杂度 $\\Theta(\\sqrt{n})$。 总时间复杂度 $\\Theta[(n+q)\\sqrt{n}]$。 [LG2801] 教主的魔法 考虑分块。 记原数列为 $A$，将 $A$ 复制一份记为 $B$，将 $B$ 分块，块内排序。 对于修改操作，整块直接打标记，散点修改完后再块内排序，这样完成操作后仍能保持分块数列的性质，单次操作复杂度 $\\Theta(\\sqrt{n}\\log\\sqrt{n})$。 对于查询操作，二分查找第 $i$ 个块内有多少个元素不小于 $k-add_i$，单次操作复杂度 $\\Theta(\\sqrt{n}\\log \\sqrt{n})$。 总时间复杂度 $\\Theta[(n+q\\sqrt{n})\\log n]$。 考虑再对复杂度做一些优化，令块的大小为 $s$，则修改操作若采用归并排序，单次操作复杂度为 $\\Theta(s+\\frac{n}{s})$，同时单次查询复杂度为 $\\Theta(s+\\frac{n}{s}\\log s)$。当询问次数为 $q$ 时，总复杂度为 $\\Theta[q(s+\\frac{n}{s}\\log n)]\\geqslant \\Theta(q\\sqrt{n\\log n})$，取最小值当且仅当 $s=\\sqrt{n\\log n}$。 [国家集训队] 排队 分块 $+$ 树状数组。 考虑交换两个数 $a_u$ 和 $a_v$ 的贡献： 显然 $u$ 左边的数和 $v$ 右边的数没有贡献。 对于 $a_u$ 来说，贡献为 $u$ 到 $v$ 之间比它大的数的数量减去比它小的数的数量。 对于 $a_v$ 来说，贡献为 $u$ 到 $v$ 之间比它小的数的数量减去比它大的数的数量。 至于如何计算 $u$ 到 $v$ 之间比某个数大或小的值的数量，分块后散块直接暴力，整块建两颗树状数组即可。 令块大小为 $siz$，则时间复杂度为 $\\Theta[nlogn+q(siz+\\frac{n}{siz}logn)]\\geqslant nlogn+q\\sqrt{nlogn}$，取最小值当且仅当 $siz=\\sqrt{nlogn}$，此时块的数量 $num=\\sqrt{\\frac{n}{logn}}$。 [LG4168] Violet 蒲公英 考虑分块，记 $s_{i,j}$ 表示前 $i$ 个块中颜色为 $j$ 的数量，$p_{i,j}$ 表示第 $i$ 个块到第 $j$ 个块的众数。 对于一次询问，先求出整块中的众数、众数的出现次数和所有在零散块中出现了的颜色的数量。显然，如果零散块中出现的颜色没有一个比众数出现的次数多，那么要求的众数就是整块的众数，否则是出现次数最多的颜色。 时间复杂度 $\\Theta(n\\sqrt{m})$。此时块大小 $B=\\frac{n}{\\sqrt{m}}$。","tags":"算法 oi 数据结构 分块"},{"title":"(带权)并查集","url":"/2023/06/24/dai-quan-bing-cha-ji/","text":"用途 并查集可以用来维护一类具有传递性的关系，维护形如将 $x$ 与 $y$ 所在集合合并和询问 $x$ 和 $y$ 是否在同一个集合的操作。 实现 查询祖先节点 对于普通并查集来说，有路径压缩和按秩合并等优化，路径压缩一般实现如下 ： int Find (int x) &#123; if (x != fa[x]) fa[x] = Find(fa[x]); return fa[x]; &#125; 按秩合并则取点数小的连向点数大的即可。 而对于带边权的并查集，我们需要在路径压缩的时候考虑加上其父亲的权值以维护其到根的差值，有路径压缩优化的带权并查集一般实现如下 ： int Find (int x) &#123; if (x != fa[x]) &#123; int mark = fa[x]; fa[x] = Find(fa[x]), val[x] += val[mark]; &#125; return fa[x]; &#125; 由于路径压缩后 $x$ 的父亲就是根节点了，所以需要记录其父亲到根的总权值并加到它的边权上。 另外，如果要查询某个点 $x$ 到根的权值和，由于一次路径压缩以后 $x$ 的父亲会变成根，而此时的 $val_x$ 就是路径和，所以可以先调用一次 Find(x)，此时的 $val_x$ 即为答案。 合并两个结点所在集合 对于普通并查集来说，两个集合合并直接将其中一个根节点接到另一个根节点上即可。 而对于带权并查集而言，我们必须求出需要连接的两个根节点之间连边的权值，而这个权值是可以直接确定的，假设现在要给 $x\\to y$ 连一条长度为 $w$ 的边，设 $x$ 的祖先为 $Rx$，则 $val_{Rx}=val_y+w-val_x.$ 另外，如果 $x$ 和 $y$ 已经在同一个集合中，并且 $val_{Rx}+val_x-val_y\\not = w$，则这条连边不合法。实现如下 ： bool Merge (int x, int y, int w) &#123; int Rx = Find(x), Ry = Find(y); if (Rx != Ry) fa[Rx] = Ry, val[Rx] = val[y] + w - val[x]; return val[Rx] + val[x] - val[y] == w; &#125; Code 带路径压缩和按秩合并优化的普通并查集 : int Find (int x) &#123; if (x != fa[x]) fa[x] = Find(fa[x]); return fa[x]; &#125; bool Merge (int x, int y) &#123; int Rx = Find(x), Ry = Find(y); if (x != y) &#123; if (pnum[Rx] &lt; pnum[Ry]) fa[Rx] = Ry, pnum[Ry] += pnum[Rx]; else fa[Ry] = Rx, pnum[Rx] += pnum[Ry]; &#125; return Rx != Ry; &#125; 带路径压缩和按秩合并优化的带权并查集 ： int Find (int x) &#123; if (x != fa[x]) &#123; int mark = fa[x]; fa[x] = Find(fa[x]), val[x] += val[mark]; &#125; return fa[x]; &#125; bool Merge (int x, int y, int w) &#123; int Rx = Find(x), Ry = Find(y); if (Rx == Ry) return (val[x] - val[y] == w); if (pnum[Rx] &lt; pnum[Ry]) fa[Rx] = Ry, pnum[Ry] += pnum[Rx], val[Rx] = val[y] + w - val[x]; else fa[Ry] = Rx, pnum[Rx] += pnum[Ry], val[Ry] = val[x] - w - val[y]; return true; &#125; 不带任何优化的并查集复杂度是 $\\Theta(n ^ 2)$ 的。 带路径压缩的并查集时间复杂度 $\\Theta(n \\log n)$，期望复杂度 $\\Theta(n \\alpha(n))$。 再加上按秩合并可以做到严格 $\\Theta(n \\alpha(n))$。","tags":"算法 oi 数据结构 并查集 c++"},{"title":"线性同余方程","url":"/2023/06/24/xian-xing-tong-yu-fang-cheng/","text":"考虑如何求解以下方程 ： $$ax\\equiv 1\\pmod b $$显然可以转化为 ： $$ax+by=1 $$有裴蜀定理 : 对于不定方程 $ax+by=c$，其有解当且仅当 $\\gcd(a,b)|c$。 可以发现上述方程有解当且仅当 $\\gcd(a,b)=1$，故可以转化为 ： $$ax+by=\\gcd(a,b) $$观察到当 $b=0$ 时方程有特解 $x=1,y=0$，于是考虑如何递归求解。 因为上式中有辗转相除的影子，于是尝试构造 ： $$bx'+(a~mod~b)y'=\\gcd(b,a~mod~b) $$有 $a~mod~b=a-\\lfloor\\frac{a}{b}\\rfloor b$，化简可得 ： $$ay'+b\\left(x'-\\lfloor\\frac{a}{b}\\rfloor y'\\right)=\\gcd(b,a~mod~b)= \\gcd(a,b) $$于是我们发现，如果求出了方程 $bx'+(a~mod~b)y'=\\gcd(b,a~mod~b)$ 的解 $x'$ 和 $y'$，那么方程 $ax+by=\\gcd(a,b)$ 的解为 ： $$x=y',y=x'-\\lfloor\\frac{a}{b}\\rfloor y' $$于是这样就可以在辗转相除的过程中递归求解了，时间复杂度 $\\Theta(\\log n)$。 #include&lt;bits/stdc++.h&gt; using namespace std; int a, b, x, y; void Exgcd (int a, int b) &#123; if (b == 0) &#123; x = 1 , y = 0; return; &#125; Exgcd(b, a % b); int tmp = x; x = y, y = tmp - a / b * y; &#125; int main () &#123; cin &gt;&gt; a &gt;&gt; b; Exgcd(a, b); cout &lt;&lt; (x + b) % b &lt;&lt; endl; return 0; &#125;","tags":"算法 oi c++ 数论 线性同余方程 裴蜀定理 类欧几里得算法"},{"title":"线性筛","url":"/2023/06/24/xian-xing-shai/","text":"筛素数 考虑如何筛出 $n$ 以内的所有素数，显然有一个最简单的想法，即将所有已求出的质数的倍数标记，表示它们不为质数，并且从小到大遍历到数 $i$ 时，若它没有被标记，则 $i\\in Prime$。 在此算法中，每个数都被自己所有本质不同的质因子筛了一次，所以总复杂度为 $\\Theta(n\\ln \\ln n)$。 对于上面的算法，算力的浪费主要在于很多数被多个质数筛过，我们考虑让每个数都只被自己的最小质因子筛。当遍历到 $i$ 时，枚举已经筛出来的所有质数，若当前枚举的质数为 $p_j$，显然 $i\\times p_j$ 不为质数。另一方面，若 $p_j|i$，则 $i$ 中有一个质因子 $p_j$，那么后面枚举到 $p_{j+1}$ 的时候，$p_{j+1}$ 就一定不是 $i\\times p_{j+1}$ 的最小质因子，所以此时要停止枚举质数。这样，每个数都只被自己的最小质因子筛过，所以总复杂度为 $\\Theta(n)$。 for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) p[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= n; j++) &#123; vis[i * p[j]] = true; if (i % p[j] == 0) break; &#125; &#125; 筛欧拉函数 考虑到 $\\varphi$ 函数有如下性质： $$\\begin{cases}\\varphi(p)=p-1~~~~~~~~~~~~~~~~~~p\\in Prime\\\\\\varphi(ap)=\\varphi(a)\\times p~~~~~~~~~~p\\in Prime\\\\\\varphi(ab)=\\varphi(a)\\times \\varphi(b)~~~~\\gcd(a,b)=1\\end{cases} $$ 对于 $\\varphi(p),p\\in Prime$，直接在筛出质数的同时求解即可。 对于 $\\varphi(ap),p\\in Prime$，在 $p_j|i$ 时，$\\varphi(i\\times p_j)=\\varphi(i)\\times p_j$。 对于 $\\varphi(ab),\\gcd(a,b)=1$，直接在筛去合数的时候 $\\varphi(i\\times p_j)=\\varphi(i)\\times \\varphi(p_j)$。 for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) p[++cnt] = i, phi[i] = i - 1; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= n; j++) &#123; vis[i * p[j]] = true; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; phi[i * p[j]] = phi[i] * phi[p[j]]; &#125; &#125; 筛不同质因子的个数 令 $\\alpha(x)$ 表示 $x$ 不同质因子的个数，$\\beta(x)$ 表示 $x$ 的所有最小质因子的乘积，考虑到 $\\alpha$ 函数有如下性质： $$\\begin{cases}\\alpha(p^k)=1~~~~~~~~~~~~~~~~~~~~~~p\\in Prime \\\\\\alpha(ab)=\\alpha(a)+\\alpha(b)~~~\\gcd(a,b)=1\\\\\\alpha(ap)=\\alpha(\\frac{a}{\\beta(a)})+1~~~~p为a的最小质因子\\end{cases} $$于是用与筛欧拉函数相似的方法： for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) p[++cnt] = g[i]= i, f[i] = 1; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt; N; j++) &#123; vis[i * p[j]] = true; if (i % p[j] == 0) &#123; g[i * p[j]] = g[i] * p[j]; f[i * p[j]] = f[i / g[i]] + 1; break; &#125; g[i * p[j]] = p[j]; f[i * p[j]] = f[i] + 1; &#125; &#125;","tags":"算法 oi c++ 数论 欧拉函数 线性筛"},{"title":"生成函数","url":"/2023/06/24/sheng-cheng-han-shu/","text":"普通生成函数 序列 $a$ 的普通生成函数 $\\rm (Ordinary~Generating~Function,OGF)$ 被定义为形式幂级数 ： $$F(x) = \\sum _n a_n x ^ n \\tag{1.0.1} $$$a$ 既可以是有穷序列也可以是无穷序列，$x$ 不具有实际意义，仅作为一个形式上的变量参与运算。 两种基本形式 加法与乘法 假设两个序列 $a,b$ 的 $\\rm OGF$ 分别为 $F(x),G(x)$。 加减不必多说 ： $$F(x) \\pm G(x) = \\sum _n (a_n \\pm b_n) x ^ n \\tag{1.1.1} $$乘法用卷积定义 ： $$F(x)G(x) = \\sum _n x ^ n \\sum _{i = 0} ^n a_ib_{n - i} \\tag{1.1.2} $$封闭形式 在使用生成函数的过程中，我们不会一直使用形式幂级数形式，有时候会为了计算方便将其替换成封闭形式。 $F(x) = \\sum _n x ^ n$ $$F(x) - xF(x) = 1 $$$$F(x) = \\frac{1}{1 - x} \\tag{1.2.1} $$ $F(x) = \\sum _n q^n x ^ n$ $$F(x) - qxF(x) = 1 $$$$F(x) = \\frac{1}{1 - qx} \\tag{1.2.2} $$ $F(x) = \\sum _n (n + 1)x ^ n$ $$\\begin{aligned} F(x) &amp;= \\sum _{n \\geqslant 1} nx ^ {n - 1}\\\\ &amp;= \\sum _ {n} (x ^ n)'\\\\ &amp;= \\left(\\frac{1}{1 - x}\\right)' \\end{aligned} $$$$F(x) = \\frac{1}{(1 - x) ^ 2} \\tag{1.2.3} $$ $F(x) = \\sum _n \\binom{m}{n} x ^ n$ $$F(x) = (1 + x) ^ m \\tag{1.2.4} $$ $F(x) = \\sum _ n \\binom{n + m}{n} x ^ n$ $$F(x) = \\frac{1}{(1 - x) ^ {m + 1}} \\tag{1.2.5} $$考虑归纳证明 ： 显然当 $m = 0$ 时，有 $F(x) = \\sum _n \\binom{n}{n} x ^ n = \\frac{1}{1 - x}$。 当 $m &gt; 0$ 时 ： $$\\begin{aligned} \\frac{1}{(1 - x) ^ {m + 1}} &amp;= \\frac{1}{(1 - x) ^ m}\\frac{1}{1 - x}\\\\ &amp;= \\left[\\sum _ n \\dbinom{m + n - 1}{n} x ^ n\\right] \\left(\\sum _n x ^ n\\right)\\\\ &amp;= \\sum _ n x ^ n \\sum _ {i = 0} ^ n \\dbinom{m + i - 1}{i}\\\\ &amp;= \\sum _ n \\dbinom{m + n}{n} x ^ n \\end{aligned} $$关于上述推导过程中最后一步用到的组合恒等式 ： $$\\sum _ {i = 0} ^ n \\dbinom{m + i - 1}{i} = \\dbinom{m + n}{n} \\tag{1.2.6} $$考虑其组合意义，左边相当于将 $i$ 个无标号石子放进 $m$ 个有标号盒子里，盒子允许为空的方案数。 考虑将 $n$ 个石子放进 $m + 1$ 个盒子中的方案数，规则同上，显然方案数为 $\\binom{m + n}{n}$。 假设从 $m + 1$ 个盒子中取出一个，枚举要将 $n$ 个石子中的多少个放入剩下的 $m$ 个盒子中，剩余的石子就只能放进取出的盒子中了，则方案数为 $\\sum _ {i = 0} ^ n \\binom{m + i - 1}{i}$。 故组合恒等式 $(1.2.6)$ 得证。 还有另一种仅通过组合意义证明式 $(1.2.5)$ 的方法 ： 可以发现 $\\frac{1}{(1 - x) ^ {m + 1}} = \\left(\\frac{1}{1 - x}\\right) ^ {m + 1}$，相当于将初始仅有 $a _ 0 = 1$ 的序列做了 $m + 1$ 遍前缀和。又因为每做一遍前缀和的组合意义是一个位置可以走到任意一个不在自己左边的位置，所以实际上 $\\frac{1}{(1 - x) ^ {m + 1}}$ 的第 $n$ 项系数即为从 $0$ 开始，每次向右走非负整数步，走 $m + 1$ 步到达 $n$ 的方案数。归约到一个更加经典的问题，就是不定方程 $\\sum _ {i = 1} ^ {m + 1} x _ i = n$ 的非负整数解数量，众所周知，其值为 $\\binom{m + n}{n}$。 部分分式定理 在上文中，我们已经知道了形如 $F(x) = \\frac{1}{(1 - qx) ^ m}$ 的部分分式可以简单地被转换为形式幂级数形式，于是我们想找到一种方法能够将形如 $\\frac{P(x)}{Q(x)}$ 的一般分式拆成若干个部分分式之和。 部分分式定理指出，如果 $\\deg P &lt; \\deg Q$，那么可以先将 $Q(x)$ 因式分解，然后使用待定系数法构造若干个形如 $\\frac{A}{(1 - ax) ^ p}$ 的式子，使它们的和为 $\\frac{P(x)}{Q(x)}$。 例如 $F(x) = \\frac{P(x)}{(x - 1) ^ 2 (x + 2)}$，那么构造 $\\frac{A}{x - 1} + \\frac{B}{(x - 1) ^ 2} + \\frac{C}{x + 2} = \\frac{P(x)}{(x - 1) ^ 2 (x + 2)}$。 两个经典数列的生成函数 斐波那契数列 斐波那契数列 $\\rm (Fibonacci~Sequence)$ 被定义为 $a_0 = 0, a_1 = 1,a _ n = a _ {n - 1} + a _ {n - 2}(n &gt; 1)$。 设 $F(x) = \\sum _ n a _ n x ^ n$，显然有 ： $$F(x) = xF(x) + x ^ 2 F(x) - a_0x + a_1x + a_0 $$解得 ： $$F(x) = \\frac{x}{1 - x - x ^ 2} \\tag{1.3.1} $$考虑使用部分分式定理，观察到分母多项式次数为 $2$，那么设 ： $$\\frac{A}{1 - ax} + \\frac{B}{1 - bx} = \\frac{x}{1 - x - x ^ 2} $$解得 ： $$\\begin{aligned} F(x) &amp;= \\frac{x}{1 - x - x ^ 2}\\\\ &amp;= \\frac{\\frac{\\sqrt{5}}{5}}{1 - \\frac{1 + \\sqrt{5}}{2}x} + \\frac{-\\frac{\\sqrt{5}}{5}}{1 - \\frac{1 - \\sqrt{5}}{2}x}\\\\ &amp;= \\sum _ n x ^ n \\frac{\\sqrt{5}}{5}\\left[\\left(\\frac{1 + \\sqrt{5}}{2}\\right) ^ n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right) ^ n\\right] \\end{aligned} $$于是上式即为斐波那契数列的形式幂级数形式和通项。 卡特兰数 首先引入牛顿二项式定理。 让我们重定义组合数的运算 ： $$\\dbinom{r}{k} = \\frac{r ^ {\\underline{k}}}{k!}~~(r \\in \\mathbb{C}, k \\in \\mathbb{N}) \\tag{1.3.3} $$在这种情况下，对于 $\\alpha \\in \\mathbb{C}$，有 ： $$(1 + x) ^ {\\alpha} = \\sum _n \\dbinom{\\alpha}{n} x ^ n \\tag{1.3.4} $$对于卡特兰数序列，令 $a_0 = a_1 = 1, a_n = \\sum\\limits_{i = 0} ^ {n - 1} a_i \\times a_{n - i - 1}(n &gt; 1)$ 令其 $\\rm OGF$ 为 $F(x) = \\sum\\limits_{n} a ^ n x ^ n$。 不难发现其递推式是一个卷积的形式，于是有： $$xF ^ 2(x) + 1 = F(x) $$解之得： $$F(x) = \\frac{1 \\pm \\sqrt{1 - 4x}}{2x} \\tag{1.3.5} $$要保留哪个根呢？ 求解上式在 $x \\to 0$ 时的极限可以发现，当 $F(x) = \\dfrac{1 + \\sqrt{1 - 4x}}{2x}$ 时不收敛。 原因是： $$F(x) = \\dfrac{1 + \\sqrt{1 - 4x}}{2x} = \\frac{2}{1 - \\sqrt{1 - 4x}} $$则有： $$\\lim\\limits_{x \\to 0 ^ {+}} \\frac{2}{1 - \\sqrt{1 - 4x}} = \\infty $$$$\\lim\\limits_{x \\to 0 ^ {-}} \\frac{2}{1 - \\sqrt{1 - 4x}} = -\\infty $$故此时 $x \\to 0$ 时极限不存在。 因此可以得到： $$F(x) = \\dfrac{1 - \\sqrt{1 - 4x}}{2x} \\tag{1.3.6} $$将分子部分单独拿出来考虑，令 $G(x) = 1 - \\sqrt{1 - 4x} = 1 - (1 - 4x) ^ {\\frac{1}{2}}$，使用牛顿二项式定理展开： $$\\begin{aligned} G(x) &amp;= 1 - \\sum\\limits_{n \\geqslant 0} \\dbinom{\\frac{1}{2}}{n} (-4x) ^ n \\\\ &amp;= 1 - \\sum\\limits_{n \\geqslant 0} \\frac{\\frac{1}{2} ^ {\\underline n}}{n!} (-4x) ^ n \\\\ &amp;= 1 - \\sum\\limits_{n \\geqslant 0} \\frac{\\frac{1}{2} \\times (-\\frac{1}{2}) \\times (-\\frac{3}{2}) \\times \\cdots \\times (-\\frac{2n - 3}{2})}{n!} (-4x) ^ n \\\\ \\end{aligned} $$特别要注意的是 $\\binom{\\frac{1}{2}}{0} = \\frac{\\frac{1}{2} ^ 0}{0!} = 1$ 但是用上面那个式子是不正确的，因此需要特别考虑： $$\\begin{aligned} G(x) &amp;= \\sum\\limits_{n \\geqslant 1} (-1) ^ {2n - 1} \\frac{(2n - 3)!!}{n!2 ^ n} (4x) ^ n \\\\ &amp;= \\sum\\limits_{n \\geqslant 1} \\frac{(2n - 2)!}{n!(2n - 2)!!2 ^ n} (4x) ^ n \\\\ &amp;= \\sum\\limits_{n \\geqslant 1} \\frac{2(2n - 2)!}{n!(n - 1)!} x ^ n \\\\ &amp;= \\sum\\limits_{n \\geqslant 1} \\frac{\\binom{2n - 1}{n}}{2n - 1} 2x ^ n \\end{aligned} $$带回原式有： $$\\begin{aligned} F(x) &amp;= \\frac{\\sum\\limits_{n \\geqslant 1} \\frac{\\binom{2n - 1}{n}}{2n - 1} 2x ^ n}{2x} \\\\ &amp;= \\sum\\limits_{n \\geqslant 0} \\frac{\\binom{2n + 1}{n + 1}}{2n + 1} x ^ n \\\\ &amp;= \\sum\\limits_{n \\geqslant 0} \\frac{\\binom{2n}{n}}{n + 1} x ^ n \\end{aligned} \\tag{1.3.9} $$因此可知 $a_n = \\dfrac{\\binom{2n}{n}}{n + 1}$。 欧拉变换 考虑求解形如下式的 $\\rm OGF$ ： $$F_i(x) = \\left(\\sum _ j x ^ {ji}\\right) ^ {f _ i} = \\left(\\frac{1}{1 - x ^ i}\\right) ^ {f _ i} \\tag{2.3.1} $$$$\\varepsilon\\circ F(x) = \\prod _ i F_i(x) = \\prod _ i \\left(\\frac{1}{1 - x ^ i}\\right) ^ {f _ i} \\tag{2.3.2} $$这个 $\\rm OGF$ 的组合意义是将 $n$ 个互不区分的小球分进若干个非空集合，大小为 $i$ 的集合有 $f_i$ 种方案的总方案数。 注意到式 $(2.3.2)$ 右边是连乘，于是对其取 $\\ln :$ $$\\begin{aligned} \\ln \\varepsilon \\circ F(x) &amp;= \\sum _ i \\ln \\left(\\frac{1}{1 - x ^ i}\\right) ^ {f _ i}\\\\ &amp;= \\sum _ i f_i \\times \\ln\\left(\\frac{1}{1 - x ^ i}\\right)\\\\ &amp;= -\\sum _ i f_i \\times \\ln (1 - x ^ i)\\\\ &amp;= \\sum _ i \\sum _ j \\frac{f_i}{j + 1} x ^ {i(j + 1)} \\end{aligned} $$关于上式中化简 $\\ln (1 - x ^ i)$ 的步骤可以参考后文中式 $(2.1.5)$。 由于我们一般只需求生成函数的前 $n$ 项，观察到 $i$ 和 $j$ 的枚举构成了调和级数的关系，可以直接暴力计算。 最后将求出的幂级数 $\\rm exp$ 回去即可得到 $\\varepsilon \\circ F(x)$。 时间复杂度 $\\Theta(n \\log n)$。 指数型生成函数 序列 $a$ 的指数型生成函数 $\\rm (Exponential~Generating~Function,EGF)$ 被定义为形式幂级数 ： $$\\hat{F}(x) = \\sum _n a_n \\frac{x ^ n}{n!}\\tag{2.0.1} $$两种基本形式 加法与乘法 形式幂级数形式的加减法与 $\\rm OGF$ 基本相同，也是对应系数相加。 乘法被定义为 ： $$\\begin{aligned} \\hat{F}(x)\\hat{G}(x) &amp;= \\sum _ i a _ i \\frac{x ^ i}{i!} \\sum _ j b _ j \\frac{x ^ j}{j!}\\\\ &amp;= \\sum _ n x ^ n \\sum _ {i = 0} ^ n a _ i b _ {n - i} \\frac{1}{i!(n - i)!}\\\\ &amp;= \\sum _ n \\frac{x ^ n}{n!} \\sum _ {i = 0} ^ n\\dbinom{n}{i} a _ i b _ {n - i} \\end{aligned} $$麦克劳林级数 众所周知有泰勒展开 ： $$F(x) = \\sum _ n \\frac{F^{(n)}(x _ 0)}{n!}(x - x _ 0) ^ n \\tag{2.1.2} $$取 $x_0 = 0$ 时的特殊情况可以得到麦克劳林级数 ： $$F(x) = \\sum _ n F^{(n)}(0)\\frac{x ^ n}{n!} \\tag{2.1.3} $$有 $\\exp(0) = 1$，故 $e ^ x$ 的 $\\rm EGF$ 为 ： $$\\hat{\\exp}(x) = \\sum _ n \\frac{x ^ n}{n!} \\tag{2.1.4} $$常见幂级数的封闭形式 $$\\begin{aligned} e ^ {qx} &amp;= \\sum _ n q ^ n \\frac{x ^ n}{n!}\\\\ \\frac{e^{x}+e^{-x}}{2}&amp;=\\sum_{n}\\frac{x^{2 n}}{(2 n) !} \\\\ \\frac{e^{x}-e^{-x}}{2}&amp;=\\sum_{n}\\frac{x^{2 n+1}}{(2 n+1) !} \\\\ \\ln (1-x)&amp;=-\\sum_{n} \\frac{x ^ {n + 1}}{n + 1}\\\\ \\ln (1+x)&amp;=\\sum_{n}(-1)^{n} \\frac{x^{n+1}}{n+1} \\\\ (1+x)^{\\alpha}&amp;=\\sum_{n} \\alpha^{\\underline{n}} \\frac{x^{n}}{n !} \\end{aligned} $$组合意义 结论：设 $\\hat{G}(x)$ 表示集合内部分配方案数关于集合大小的 $\\rm EGF$，$\\hat{F}(x)$ 表示将问题划分成若干个无标号非空子问题，子问题的方案数为 $\\hat{G}(x)$ 的关于问题总规模的方案数的 $\\rm EGF$。那么有关系式 ： $$\\hat{F}(x) = \\exp \\hat{G}(x) \\tag{2.2.1} $$考虑证明上述结论，设 $f_{i, j}$ 表示将 $j$ 个有标号小球放进 $i$ 个有标号盒子中的方案数，$g_i$ 表示集合内有 $i$ 个元素的方案数，显然有 ： $$f_{i, j} = \\sum _{k = 1} ^ {j - i + 1} \\dbinom{j}{k} f_{i - 1, j - k} \\times g_k $$考虑到 $f_{i - 1, j - k}$ 在 $k &gt; j - i + 1$ 时的值为 $0$，所以可以将 $k$ 的枚举上界换成 $j$，发现有 ： $$\\hat{F}_i(x) = \\hat{F}_{i - 1}(x)\\hat{G}(x) $$化简得到并根据 $\\hat{F}_i(x)$ 的定义得到 ： $$\\hat{F}_i(x) = \\sum _ j f_{i, j} \\frac{x ^ j}{j!} = \\hat{G}^i(x) \\tag{2.2.2} $$于是有 ： $$\\begin{aligned} \\exp \\hat{G}(x) &amp;= \\sum_n \\frac{\\hat{G}^n(x)}{n!}\\\\ &amp;= \\sum _ n \\frac{1}{n!} \\sum _ i f_{n, i} \\frac{x ^ i}{i!}\\\\ &amp;= \\sum _ i \\left(\\sum _ n \\frac{f _ {n, i}}{n!}\\right) \\frac{x ^ i}{i!} \\end{aligned} $$这恰好对应了 $\\hat{F}(x)$ 的定义，于是 $\\hat{F}(x) = \\exp \\hat{G}(x)$。","tags":"算法 组合数学 生成函数 指数型生成函数 斐波那契数列 卡特兰数 欧拉变换 部分分式定理"},{"title":"简单的代数反演","url":"/2023/06/24/jian-dan-de-dai-shu-fan-yan/","text":"二项式反演 数列形式 $$g(x)=\\sum_{i=x}^n\\dbinom{i}{x}f(i)\\iff f(x)=\\sum_{i=x}^n (-1)^{i-x}\\dbinom{i}{x}g(i) $$$\\large\\rm Proof:$ 将上式带入下式得 $:$ $$f(x)=\\sum_{i=x}^n (-1)^{i-x}\\dbinom{i}{x}\\sum_{j=i}^n\\dbinom{j}{i}f(j) $$整理得 $:$ $$f(x)=\\sum_{i=x}^n\\sum_{j=i}^n(-1)^{i-x}\\dbinom{j}{i}\\dbinom{i}{x}f(j) $$根据组合恒等式 $\\dbinom{i}{j}\\dbinom{j}{k}=\\dbinom{i}{k}\\dbinom{i-k}{j-k}$ 得 $:$ $$f(x)=\\sum_{i=x}^n\\sum_{j=i}^n(-1)^{i-x}\\dbinom{j}{x}\\dbinom{j-x}{i-x}f(j) $$交换枚举顺序得 $:$ $$f(x)=\\sum_{j=x}^n\\sum_{i=x}^j(-1)^{i-x}\\dbinom{j}{x}\\dbinom{j-x}{i-x}f(j) $$改变代表字母，整理得 $:$ $$f(x)=\\sum_{i=x}^n\\dbinom{i}{x}f(i)\\sum_{j=x}^i(-1)^{j-x}\\dbinom{i-x}{j-x} $$将靠后的 $\\sum$ 枚举的 $j$ 替换成 $j+x$ 得 $:$ $$f(x)=\\sum_{i=x}^n\\dbinom{i}{x}f(i)\\sum_{j=0}^{i-x}(-1)^{j}\\dbinom{i-x}{j} $$$$\\because \\sum_{i=0}^k(-1)^i\\dbinom{k}{i}=(1-1)^k $$$$\\therefore \\sum_{i=0}^k(-1)^i\\dbinom{k}{i}=[k=0] $$所以此式不为 $0$ 当且仅当 $i=x$，故 $:$ $$f(x)=\\sum_{i=x}\\dbinom{x}{x}f(i)=f(x) $$原式得证。 我们来看看二项式反演的数列形式有什么应用： 乱序排列问题： 求有多少种不同的长度为 $n$ 的排列 $p$，使得 $\\forall i\\in [1,n],p_i\\not = i$。 令 $g(i)$ 表示钦定有 $i$ 个数一定在自己的位置上，剩下的随便排的方案数，显然有 : $$g(i)=\\dbinom{n}{i}(n-i)! $$令 $f(i)$ 表示恰好有 $i$ 个数在自己的位置上的方案数，考虑到 $f(i)$ 会被 $g(j)~(j\\leqslant i)$ 计算 $\\dbinom{i}{j}$ 次，于是有 $:$ $$g(i)=\\sum_{j=i}^n\\dbinom{j}{i}f(j) $$根据二项式反演 $:$ $$f(i)=\\sum_{j=i}^n(-1)^{j-i}\\dbinom{j}{i}g(j) $$将 $g(i)=\\dbinom{n}{i}(n-i)!$ 带入得 $:$ $$f(i)=\\sum_{j=i}^n(-1)^{j-i}\\dbinom{j}{i}\\dbinom{n}{j}(n-j)! $$根据组合恒等式 $\\dbinom{i}{j}\\dbinom{j}{k}=\\dbinom{i}{k}\\dbinom{i-k}{j-k}$，整理得 $:$ $$f(i)=\\dbinom{n}{i}\\sum_{j=i}^n(-1)^{j-i}\\dbinom{n-i}{j-i}(n-j)! $$考虑到当 $i=0$ 时为答案，所以 $:$ $$\\begin{aligned} Ans=f(0)&amp;=\\sum_{i=0}^n(-1)^i\\dbinom{n}{i}(n-i)!\\\\&amp;=\\sum_{i=0}^n(-1)^i\\dfrac{n!}{i!}\\\\&amp;=(n+1)!\\sum_{i=0}^n(-1)^i(i!)^{-1} \\end{aligned} $$集合形式 $$f(S)=\\sum_{S\\subseteq T}g(T)\\iff g(S)=\\sum_{S\\subseteq T} (-1)^{|T|-|S|}f(T) $$$\\large\\rm Proof:$ 同样考虑带入证明 ： $$\\begin{aligned} f(S)&amp;=\\sum_{S\\subseteq T}\\sum_{T\\subseteq R}(-1)^{|R|-|T|}f(R)\\\\&amp;=\\sum_{S\\subseteq R}f(R)\\sum_{S\\subseteq T\\subseteq R}(-1)^{|R|-|T|} \\end{aligned} $$考虑枚举 $T-S$ 的大小 ： $$\\begin{aligned} f(S)&amp;=\\sum_{S\\subseteq R}f(R)\\sum_{i=0}^{|R|-|S|}\\dbinom{|R|-|S|}{i}(-1)^{|R|-(|S|+i)}\\\\&amp;=\\sum_{S\\subseteq R}[|S|=|R|]\\\\&amp;=f(S) \\end{aligned} $$原式得证。 我们来看看二项式反演的集合形式有什么应用： 有向图无环子图计数： 给定一张 $n$ 个点的有向图，求其无环子图的数量。 考虑动态规划，设 $f_S$ 表示点集 $S$ 导出子图的答案。 由于是 $\\rm DAG$ 计数，所以我们可以很自然地想到枚举入度为 $0$ 的点，假设 $T$ 是 $S$ 的子集，并且其中的每个点都没有入边，那么显然有转移 ： $$f_S=\\sum_{T\\subseteq S,T\\not = \\varnothing}2^{cnt_{T,S-T}}\\times f_{S-T} $$其中 $cnt_{S,T}$ 表示集合 $S$ 到集合 $T$ 的连边总数。 但我们发现这样做实际上是错的，因为 $T$ 不一定包含了 $S$ 中所有入度为 $0$ 的点，我们考虑容斥。 设 $q_T=2^{cnt_{T,S-T}}\\times f_{S-T}$，$p_T$ 表示 $S$ 中恰好有 $T$ 作为入度为 $0$ 的点的方案数，有 $q_T=\\sum\\limits_{T\\subseteq S} p_S$。 由二项式反演的集合形式可以得到 ： $$p_S=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}q_T $$回到原本的 $\\rm DP$，我们需要求 ： $$\\begin{aligned} f_S&amp;=\\sum_{T\\subseteq S,T\\not= \\varnothing}p_T\\\\&amp;=\\sum_{T\\subseteq S,T\\not= \\varnothing}\\sum_{T\\subseteq R\\subseteq S}(-1)^{|R|-|T|}q_R\\\\&amp;=\\sum_{R\\subseteq S,R\\not= \\varnothing}q_R \\sum_{T\\subseteq R,T\\not=\\varnothing}(-1)^{|R|-|T|}\\\\&amp;=\\sum_{R\\subseteq S,R\\not= \\varnothing}q_R (-1)^{|R|}\\left(\\sum_{T\\subseteq R}(-1)^{-|T|}-1\\right)\\\\&amp;=\\sum_{T\\subseteq S,T\\not= \\varnothing}(-1)^{|T|-1}q_T \\end{aligned} $$于是转移方程为 ： $$f_S=\\sum_{T\\subseteq S,T\\not= \\varnothing}(-1)^{|T|-1}2^{cnt_{T,S-T}}f_{S-T} $$现在只需要 $\\Theta(1)$ 计算 $cnt_{T,S-T}$ 即可做到 $\\Theta(3^n)$ 计算计算答案，考虑预处理。 可以在枚举了每个 $S$ 做转移的时候再算这个东西，此时只需要记 $cnt_T~(T\\subseteq S,T\\not=\\varnothing)$ 表示 $T$ 恰好作为 $S$ 中没有入度的点集的路径数。考虑在进行所有计算之前预处理 $A_{i,S}$ 表示 $i$ 到 $S$ 中的边数，$D_{i,S}$ 表示 $S$ 中的点到 $i$ 的边数和，这两个数组都可以 $\\Theta(n2^n)$ 预处理。 计算 $cnt$ 时考虑从小到大枚举每个 $T$ 计算答案，可以发现 $T$ 的每个真子集的答案都已经被计算出来了，于是任取一个点从 $T$ 中移到 $S-T$ 即可算出答案，这里考虑 $\\Theta(1)$ 枚举 lowbit. 可以发现，转移式为 ： $$cnt_T=cnt_{T-\\{u\\}}+A_{u,S-T}-D_{T-\\{u\\},u} $$于是本题到此，可以做到时间复杂度 $\\Theta(3^n)$，空间复杂度 $\\Theta(n2^n)$。 子集反演 $$f(S)=\\sum_{T\\subseteq S}g(T)\\iff g(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}f(T) $$$\\large\\rm Proof:$ 还是考虑带入证明，与二项式反演的集合形式类似 $:$ $$\\begin{aligned} f(S)&amp;=\\sum_{T\\subseteq S}\\sum_{R\\subseteq T}(-1)^{|T|-|R|}f(R)\\\\&amp;=\\sum_{R\\subseteq S}f(R)\\sum_{R\\subseteq T\\subseteq S}(-1)^{|T|-|R|}\\\\&amp;=\\sum_{R\\subseteq S}f(R)\\sum_{i=0}^{|S|-|R|}\\dbinom{|S|-|R|}{i}(-1)^{(|S|-i)-|R|}\\\\&amp;=\\sum_{R\\subseteq S}[|R|=|S|]\\\\&amp;=f(S) \\end{aligned} $$原式得证。 斯特林反演 第二类斯特林数 定义 定义 $\\begin{Bmatrix}n \\\\ m\\end{Bmatrix}$ 为将 $n$ 个有标号小球放入 $m$ 个无标号盒子，每个盒子不能为空的方案。 递推式 $$\\begin{Bmatrix}n \\\\ m\\end{Bmatrix} = \\begin{Bmatrix}n - 1 \\\\ m - 1\\end{Bmatrix} + m \\times \\begin{Bmatrix}n - 1 \\\\ m\\end{Bmatrix} $$根据组合意义不难证明。 求一行第二类斯特林数 考虑以下第二类斯特林数的组合意义，我们考虑使用容斥描述第二类斯特林数的答案。 首先我们求出将 $n$ 个有标号小球放入 $m$ 个有标号盒子，盒子不能为空的方案，根据这个问题的特殊性，任意一种无标号盒子的方案恰好双向对应 $m!$ 中有标号盒子的方案，最后除 $m!$ 即可。 对于盒子是否为空进行容斥： $$\\begin{Bmatrix}n \\\\ m\\end{Bmatrix} = \\frac{1}{m!} \\sum\\limits_i ^ m (-1) ^ i \\dbinom{m}{i}(m - i) ^ n $$显然是一个卷积的形式，$\\rm NTT$ 即可做到 $\\mathcal{O(n \\log n)}$。 求一列第二类斯特林数 不难发现第二类斯特林数的定义与 $\\exp$ 的组合意义很相似，于是我们考虑 $\\rm EGF:$ $\\widehat F(x) = \\sum\\limits_{i = 1} ^ \\infty \\frac{x ^ i}{i!} = e ^ x - 1$。 那么根据 $\\rm EGF$ 相乘的组合意义，$[\\dfrac{x ^ n}{n!}]\\widehat F ^ m(x) = [\\dfrac{x ^ n}{n!}](e ^ x - 1) ^ m = \\begin{Bmatrix}n \\\\ m\\end{Bmatrix}$。 使用多项式快速幂即可做到 $\\mathcal{O(n \\log n)}$。 第一类斯特林数 定义 定义 $\\begin{bmatrix}n \\\\ m\\end{bmatrix}$ 为将 $n$ 个数划分成 $m$ 个互不区分的非空置换的方案数。 递推式 $$\\begin{bmatrix}n \\\\ m\\end{bmatrix} = \\begin{bmatrix}n - 1 \\\\ m - 1\\end{bmatrix} + (n - 1) \\times \\begin{bmatrix}n - 1 \\\\ m\\end{bmatrix} $$由组合意义不难证明。 求一行第一类斯特林数 因为第一类斯特林数不具有较好的组合意义，因此不能像第二类斯特林数那样使用另一种方式来描述其，因此我们直接考虑第一类斯特林数的 $\\rm OGF$： $$\\begin{aligned} F_i(x) &amp;= \\sum\\limits_j ^ \\infty \\begin{bmatrix}i \\\\ j\\end{bmatrix} x ^ j \\\\ &amp;= x \\times F_{i - 1}(x) + (i - 1) F_{i - 1}(x) \\\\ &amp;= (i + x - 1) F_{i - 1}(x) \\\\ &amp;= \\prod\\limits_j ^ {i - 1} (x + j) \\end{aligned} $$那么就有： $$F_n(x) = \\prod\\limits_i ^ {n - 1} (x + i) $$当然可以直接使用启发式合并做到 $\\mathcal{O(n \\log ^ 2n)}$，但还存在一个更加优秀的方法：倍增法。 $$F_{2n}(x) = F_n(x) \\times F_n(x + n) $$只需快速计算 $F_n(x + n)$ 即可，令 $F_n(x) = \\sum\\limits_i ^ \\infty f_i x ^ i$： $$\\begin{aligned} F_n(x + n) &amp;= \\sum\\limits_i ^ n f_i(x + n) ^ i \\\\ &amp;= \\sum\\limits_i ^ n f_i\\sum\\limits_j ^ i x ^ j n ^ {i - j} \\end{aligned} $$后者很明显是一个卷积的形式，直接计算即可，根据倍增的复杂度，可以做到 $\\mathcal{O(n \\log n)}$。 求一列第一类斯特林数 类似于求一列第二类斯特林数的方法，考虑 $\\rm EGF:$ $\\widehat F(x) = \\sum\\limits_i ^ \\infty \\dfrac{(i - 1)!x ^ i}{i!} = \\sum\\limits_i ^ \\infty \\dfrac{x ^ i}{i} = \\ln\\left(\\dfrac{1}{1 - x}\\right)$ 那么就有： $$\\begin{bmatrix}n \\\\ m\\end{bmatrix} = [\\frac{x ^ n}{n!}]\\widehat F ^ m(x) $$使用多项式快速幂即可，复杂度 $\\mathcal{O(n \\log n)}$。 普通幂, 上升幂, 下降幂的转换 先介绍两个最简单的：上升幂和下降幂的转换： $$x ^ {\\underline{n}} = (-1) ^ n (-x) ^ {\\overline n} $$$$x ^ {\\overline{n}} = (-1) ^ n (-x) ^ {\\underline n} $$再根据我们求一行斯特林数的方法，可以得到上升幂转普通幂公式： $$x ^ {\\overline n} = \\sum\\limits_i ^ n \\begin{bmatrix} n \\\\ i \\end{bmatrix} x ^ i $$而根据第二类斯特林数的组合意义，再根据普通幂 $x ^ n$ 的组合意义，可以得到普通幂转下降幂公式： $$x ^ n = \\sum\\limits_i ^ x \\dbinom{x}{i} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} i! = \\sum\\limits_i ^ x \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x ^ {\\underline{i}} $$再利用最开始提到的下降幂转上升幂公式变形，我们可以得到普通幂转上升降幂公式： $$\\begin{aligned} (-x) ^ n &amp;= \\sum\\limits_i ^ x \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} (-x) ^ {\\underline{i}} \\\\ &amp;= \\sum\\limits_i ^ x \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} (-1) ^ i x ^ {\\overline{i}} \\end{aligned} $$$$\\Longleftrightarrow x ^ n = \\sum\\limits_i ^ x (-1) ^ {n - i}\\begin{Bmatrix} n \\\\ i \\end{Bmatrix}x ^ {\\overline{i}} $$同理可得下降幂转普通幂公式： $$x ^ {\\underline{n}} = \\sum\\limits_i ^ x (-1) ^ {n - i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} x ^ i $$总结一下四个公式，普通幂转出去使用第二类斯特林数，转回来使用第一类斯特林数。阶数上升（下转普，普转上）加 $-1$。 通过这四个公式，我们也能完成一般多项式和上升幂下降幂多项式的互相转化。 我们来看看这几个式子有什么应用： 例题： 给定 $k$ 次多项式 $f(x)$ 的各项系数和一个整数 $n$，求以下式子对 $998244353$ 取模后的值 ： $$\\sum_{i=0}^n\\dbinom{n}{i}2^{n-i}f(i) $$我们发现带 $f(x)$ 的式子没有前途，于是将其拆开 ： $$\\sum_{i=0}^n\\dbinom{n}{i}2^{n-i}\\sum_{j=0}^ka_ji^j $$这里有个套路是将整数幂转第二类斯特林数 ： $$\\begin{aligned} m^n&amp;=\\sum_{k=0}^m\\dbinom{m}{k}\\begin{Bmatrix}n\\\\m-k\\end{Bmatrix}(m-k)!\\\\&amp;=\\sum_{k=0}^m\\begin{Bmatrix}n\\\\k\\end{Bmatrix}m^{\\underline{k}} \\end{aligned} $$转化的含义是将 $m^n$ 看作 $\\rm LLA$ 问题的方案数，我们发现 $\\small\\begin{Bmatrix}n\\\\m\\end{Bmatrix}$ 是 $\\rm LUB$ 问题的方案数，于是枚举 $m$ 个集合中有 $k$ 个 $0$，然后用第二类斯特林数将 $\\rm LUA$ 算出来后乘上 $(m-k)!$ 得到 $\\rm LLA$ 的方案数。 于是就可以开始推式子了 ： $$\\begin{aligned} &amp;\\quad~\\sum_{i=0}^n\\dbinom{n}{i}2^{n-i}f(i)\\\\&amp;=\\sum_{i=0}^n\\dbinom{n}{i}2^{n-i}\\sum_{j=0}^ka_ji^j\\\\&amp;=\\sum_{i=0}^n\\dbinom{n}{i}2^{n-i}\\sum_{j=0}^ka_j\\sum_{p=0}^i\\dbinom{i}{p}\\begin{Bmatrix}j\\\\p\\end{Bmatrix}p!\\\\&amp;=\\sum_{i=0}^n\\sum_{j=0}^k\\sum_{p=0}^i\\dbinom{n}{i}\\dbinom{i}{p}2^{n-i}a_j\\begin{Bmatrix}j\\\\p\\end{Bmatrix}p!\\\\&amp;=\\sum_{j=0}^ka_j\\sum_{p=0}^n\\begin{Bmatrix}j\\\\p\\end{Bmatrix}p!\\sum_{i=p}^n\\dbinom{n}{i}\\dbinom{i}{p}2^{n-i}\\\\&amp;=\\sum_{j=0}^ka_j\\sum_{p=0}^n\\begin{Bmatrix}j\\\\p\\end{Bmatrix}p!\\sum_{i=p}^n\\dbinom{n}{p}\\dbinom{n-p}{i-p}2^{n-i}\\\\&amp;=\\sum_{j=0}^ka_j\\sum_{p=0}^n\\dbinom{n}{p}\\begin{Bmatrix}j\\\\p\\end{Bmatrix}p!\\sum_{i=0}^{n-p}\\dbinom{n-p}{i}2^{n-p-i}\\\\&amp;=\\sum_{j=0}^k\\sum_{p=0}^na_j\\begin{Bmatrix}j\\\\p\\end{Bmatrix}\\dbinom{n}{p}p!3^{n-p}\\\\&amp;=\\sum_{j=0}^k\\sum_{p=0}^j\\begin{Bmatrix}j\\\\p\\end{Bmatrix}a_j\\times n^{\\underline{p}}\\times 3^{n-p} \\end{aligned} $$最后这个式子可以通过预处理第二类斯特林数，$3$ 的次幂和 $n$ 的 $p$ 阶下降幂做到 $\\Theta(k^2)$。 斯特林反演 非常类似二项式反演的形式，有： $$f_n = \\sum\\limits_i ^ n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} g_i \\Longleftrightarrow g_n = \\sum\\limits_i ^ n (-1) ^ {n - i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} f_i $$我们首先需要了解斯特林反演基于的恒等式 $-$ 反转公式： $$\\sum\\limits_{i = m} ^ n (-1) ^ {n - i} \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} \\begin{bmatrix} i \\\\ m \\end{bmatrix} = [n = m] $$$$\\sum\\limits_{i = m} ^ n (-1) ^ {n - i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} \\begin{Bmatrix} i \\\\ m \\end{Bmatrix} = [n = m] $$不难发现两式的形式非常类似，我们只证明第一条式子，第二条式子是类似的。 $$\\begin{aligned} x ^ n &amp;= \\sum\\limits_i ^ n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} x ^ {\\underline{i}} \\\\ &amp;= \\sum\\limits_i ^ n \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} (-1) ^ i (-x) ^ {\\overline{i}} \\\\ &amp;= \\sum\\limits_i ^ n (-1) ^ i \\begin{Bmatrix} n \\\\ i \\end{Bmatrix} \\sum\\limits_j ^ i (-1) ^ j \\begin{bmatrix} i \\\\ j \\end{bmatrix} x ^ j \\\\ &amp;= \\sum\\limits_i ^ n \\left( \\sum\\limits_{j = i} ^ n (-1) ^ {i - j} \\begin{Bmatrix} n \\\\ j \\end{Bmatrix} \\begin{bmatrix} j \\\\ i \\end{bmatrix}\\right) x ^ i \\end{aligned} $$根据多项式恒等原理即可证明第一条反转公式。 有了这两条反转公式，就可以直接将斯特林反演左式带入右式以及右式带入左式来证明正确性了，过程是不难的。 Min-Max 反演 令 $\\max\\limits_k(S)$ 表示有限集 $S$ 中的最大值，$\\min\\limits_k(S)$ 表示有限集中的最小值。 基本形式 $$\\max(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-1}\\min(T) $$可以发现，对于所有 $T\\subseteq S-\\{\\max(S)\\}$，均存在 $T+\\max(S)\\subseteq S$ 与之一一对应，且 $\\min(T)=\\min(T+\\max(S))$。 由于它们的大小恰好相差 $1$，故对每个集合 $S$ 配上 $(-1)^{|S|}$ 的系数可以恰好它们消掉，最后仅剩下集合 $\\{\\max(S)\\}$，它的最小值恰好等于 $\\max(S)$。 同理 ： $$\\min(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-1}\\max(T) $$拓展形式 $$\\max_k(S)=\\sum_{T\\subseteq S,|T|\\geqslant k}(-1)^{|T|-k}\\dbinom{|T|-1}{k-1}\\min(T) $$考虑 $S$ 中的第 $i$ 大数，它作为最小值被包含在大小为 $|T|$ 的集合中共 $\\binom{i-1}{|T|-1}$ 次，每次出现会乘上 $\\binom{|T|-1}{k-1}$ 的权值，故一个数 $\\max\\limits_i(S)$ 的总贡献为 ： $$\\begin{aligned} val_i&amp;=\\max_i(S)\\sum_{|T|=k}^i(-1)^{|T|-k}\\dbinom{i-1}{|T|-1}\\dbinom{|T|-1}{k-1}\\\\&amp;=\\max_i(S)\\dbinom{i-1}{k-1}\\sum_{|T|=k}^i(-1)^{|T|-k}\\dbinom{i-k}{|T|-k}\\\\&amp;=\\max_i(S)\\dbinom{i-1}{k-1}[i=k] \\end{aligned} $$所有数的贡献之和即为 $\\sum\\limits_{i=1}^{|S|}val_i=\\max\\limits_k(S)$，故原式成立。 另外，由于期望具有线性性，所以上面的式子在期望意义下也成立。 我们来看看 $\\rm Min-Max$ 反演有什么应用： 重返现世 ：你需要收集 $n$ 种物品中的任意 $k$ 种，每个时刻会有一种物品被生成，第 $i$ 种物品被生成的概率为 $\\frac{p_i}{m}$，如果你还没有收集这种物品则可以收集它，求你收集到这 $n$ 个物品中任意 $k$ 个的期望时间。 保证 $k\\leqslant n\\leqslant 10^3,|n-k|\\leqslant 10,0\\leqslant p_i\\leqslant m,\\sum p=m,m\\leqslant 10^4$。 首先可以发现所有物品出现的时间不重，故构成一个集合，所以题目要求的为 $E\\left(\\max (S)_{k}\\right)$。 套用拓展 $\\rm Min -Max$ 得到: $$E\\left(\\max (S)_{k}\\right)=\\sum_{T \\subseteq S}\\left(\\begin{array}{c} |T|-1 \\\\ k-1 \\end{array}\\right)(-1)^{|T|-k} E(\\min (T)) $$我们知道原来要求的是全集合中出现时间排第 $k$ 的元素，由于变成了正过来看，此时的 $k$ 变成了 $n-k+ 1$ ，它的值非常小。 我们知道一个集合每次操作出现一个属于它的元素的概率为: $$e(S)=\\sum_{i \\in S} \\frac{p_{i}}{m} $$于是我们知道期望时间为: $$\\sum_{i=1}^{\\infty} e(S)(1-e(S))^{i-1}=\\frac{1}{e(S)} $$于是现在我们得到了一个复杂度为 $\\Theta\\left(2^{n}\\right)$ 的做法，暴力枚举子集，对于每个集合求出此式子并计算贡献。 然后我们来看这个式子: $$E\\left(\\max (S)_{k}\\right)=\\sum_{T \\subseteq S}\\left(\\begin{array}{c} |T|-1 \\\\ k-1 \\end{array}\\right)(-1)^{|T|-k} E(\\min (T)) $$考虑一个固定的集合大小 $|T|$ ，其分配的系数相同均为 $\\left(\\begin{array}{c}|T|-1 \\\\ k-1\\end{array}\\right)(-1)^{|T|-k}$ 则我们只需要求出 $\\sum_{|T|=x} E(\\min (T))$ 注意到 $E(\\min (T))=\\frac{1}{e(S)}$，于是我们可以给 $d p$ 加一个维度记录 $\\sum p=e(S)$, 这样只需要统计有多少 个点满足 $\\sum p=i,|T|=j$。 于是不妨记 $d p_{i, j, k}$ 表示考虑到前 $i$ 个数，满足 $|T|=j, \\sum p=k$ 的集合数，则可以得到转移: $$d p_{i, j, k}=d p_{i-1, j, k}+d p_{i-1, j-1, k-p_{i}} $$这样便可以得到一个复杂度为 $\\Theta\\left(n^{2} m\\right)$ 的做法了。 现在问题在于如何优化复杂度 $?$ 我们发现转移已经是最优了，不能从这里下手，于是只能从状态下手。由于 $k$ 这一维附带了一个 $\\frac{1}{k}$，于是肯定定是不能省略的，唯一的办法是把记录中的 $|T|$ 给去掉试试。 换而言之我们只统计到第 $i$ 个数，任意放满足 $\\sum p=k$ 的数前面安排的系数之和。考虑系数为: $$\\sum\\left(\\begin{array}{c} |T|-1 \\\\ k-1 \\end{array}\\right)(-1)^{|T|-k} $$拆开试试 ? $$\\sum \\frac{(|T|-1) !}{(k-1) !(|T|-k) !}(-1)^{|T|-k} $$好像还是不行…… 但是这个时候可以得到转移大致为： $$d p_{i, j}=d p_{i-1, j}+\\ldots $$这个奇怪的东西应该表示为: 对于 $d p_{i-1, j-p i}$ 的: $$\\sum\\left(\\begin{array}{c} |T|-1 \\\\ k-1 \\end{array}\\right)(-1)^{|T|-k} $$首先可以注意到所有 $|T| \\rightarrow|T|+1$ 于是整体需要乘一个 $-1$，注意到 $|T| \\rightarrow|T|+1$，于是组合数变成了: $$\\left(\\begin{array}{c} |T| \\\\ k-1 \\end{array}\\right) $$但是我们知道组合数可以递推所以有: $$\\left(\\begin{array}{c} |T| \\\\ k-1 \\end{array}\\right)=\\left(\\begin{array}{c} |T|-1 \\\\ k-1 \\end{array}\\right)+\\left(\\begin{array}{c} |T|-1 \\\\ k-2 \\end{array}\\right) $$然而真正有趣的是这个式子可以放在一起一起递推，因为考虑计算 $dp$ 时强制放入一个数则等价于 $|T|$ 必然变大 $1$，于是我们可以给 $dp$ 增加一个维度 $k$ 来计算 $dp$ 系数 $$d p_{i, j, k}=d p_{i-1, j, k}+(-1) \\times d p_{i-1, j-p i, k}+(-1)^{2} \\times d p_{i-1, j-p i, k-1} $$即: $$d p_{i, j, k}=d p_{i-1, j, k}-d p_{i-1, j-p i, k}+d p_{i-1, j-p i, k-1} $$接下来考虑边界条件，这个好像有点难，因为我们的 $dp$ 是按照转移的需求设计，所以它存在的实际意义也是为了方便转移而存在的。 我们知道 $d p_{0, j, k}$ 的意义应该是: $\\sum_{\\sum p=j}\\left(\\begin{array}{c}|T|-1 \\\\ k-1\\end{array}\\right)$，于是考虑前面的数，唯一的一个 $\\sum p=j$ 是空集，即 $\\sum p=0$，此时有 $|T|=0$ 求的则是: $$dp_{0,0, k}=\\dbinom{-1}{k-1} $$这个时候我们需要拓宽组合数的意义, 你可以认为 $\\binom{-1}{-1}=1$ 而 $\\binom{x}{y}$ 在 $x&lt;y$ 的时候为 $0$，$x=y$ 的时候为 $1$。 所以 $dp$ 的边界为 $dp_{0,0,0}=1$。 转移的时候可以用滚动数组，总时间复杂度为 $\\Theta(nm(n-k))$。 Gcd-Lcm 反演 一般地，求 $\\rm lcm$ 通常转化为求解 $\\gcd$，因为 $\\gcd$ 的性质更为优秀，也可以借助莫比乌斯反演。 通用形式为： $$\\mathrm{lcm}(S) = \\prod\\limits_{T \\subseteq S, T \\ne \\varnothing} \\gcd(T) ^ {(-1) ^ {|T| - 1}} $$证明考虑使用 $\\rm Min-Max$ 容斥，考虑每个质因子 $p$ 对左右的贡献： $$\\begin{aligned} p ^ {\\max(p, S)} &amp;= p ^ {\\sum\\limits_{T \\subseteq S, T \\ne \\varnothing} (-1) ^ {|T| - 1} \\min(p, T)} \\\\ &amp;= \\prod\\limits_{T \\subseteq S, T \\ne \\varnothing} p ^ {(-1) ^ {|T| - 1} \\min(p, T)} \\\\ &amp;= \\prod\\limits_{T \\subseteq S, T \\ne \\varnothing} \\left(p ^ {\\min(p, T)}\\right) ^ {(-1) ^ {|T| - 1} } \\end{aligned} $$那么有： $$\\begin{aligned} \\mathrm{lcm}(S) &amp;= \\prod\\limits_p p ^ {\\max(p, S)} \\\\ &amp;= \\prod\\limits_{p} \\prod\\limits_{T \\subseteq S, T \\ne \\varnothing} \\left(p ^ {\\min(p, T)}\\right) ^ {(-1) ^ {|T| - 1} } \\\\ &amp;= \\prod\\limits_{T \\subseteq S, T \\ne \\varnothing} \\left(\\prod\\limits_p p ^ {\\min(p, T)}\\right) ^ {(-1) ^ {|T| - 1} } \\\\ &amp;= \\prod\\limits_{T \\subseteq S, T \\ne \\varnothing} \\gcd(T) ^ {(-1) ^ {|T| - 1}} \\end{aligned} $$我们来看看 $\\rm Gcd-Lcm$ 反演有什么应用： 前路（出题人：本校学长 @$\\rm remoon$）: 给定 $A,B,C$，求 ： $$\\sum_{i=1}^A\\sum_{j=1}^B\\sum_{k=1}^C\\mathrm{lcm}(i,j,k) $$保证 $A,B,C\\leqslant 5\\times 10^4$，答案对 $10^9+7$ 取模。 首先给出一个复杂度估界为 $\\Theta(n^2)$ 的做法，但实测非常快。 请注意，以下的推导遵循一个原则，对 $i, j, k$ 做相同变换，不会先处理一部分再处理一部分。 $$\\begin{aligned} Ans &amp;= \\sum\\limits_{i = 1} ^ A \\sum\\limits_{j = 1} ^ B \\sum\\limits_{k = 1} ^ C \\mathrm{lcm}(i, j, k) \\\\ &amp;= \\sum\\limits_{i = 1} ^ A \\sum\\limits_{j = 1} ^ B \\sum\\limits_{k = 1} ^ C \\frac{ijk(i, j, k)}{(i, j)(j, k)(k, i)} \\qquad (\\mathrm{Min-Max} ~ for ~ index) \\\\ &amp;= \\sum\\limits_{i = 1} ^ A \\sum\\limits_{j = 1} ^ B \\sum\\limits_{k = 1} ^ C \\frac{ijk}{(i, j)(j, k)(k, i)} \\left( f \\times \\mu \\times I \\left((i, j, k)\\right)\\right) \\qquad (f(i) = i)\\\\ &amp;= \\sum\\limits_{d = 1} ^ A f \\times \\mu (d) \\sum\\limits_{i = 1} ^ {A / d} \\sum\\limits_{i = 1} ^ {B / d} \\sum\\limits_{i = 1} ^ {C / d} \\frac{ijk}{(i, j)(j, k)(k, i)} \\end{aligned} $$令 $F(A, B, C) = \\sum\\limits_{i = 1} ^ A \\sum\\limits_{i = 1} ^ B \\sum\\limits_{i = 1} ^ C \\dfrac{ijk}{(i, j)(j, k)(k, i)}, g(i) = \\dfrac{1}{i}, h = g \\times \\mu$ 则： $$\\begin{aligned} F(A, B, C) &amp;= \\sum\\limits_{i = 1} ^ A \\sum\\limits_{i = 1} ^ B \\sum\\limits_{i = 1} ^ C ijk ( f \\times \\mu \\times I ((i, j)))( f \\times \\mu \\times I ((j, k)))( f \\times \\mu \\times I ((k, i))) \\\\ &amp;= \\sum\\limits_{i = 1} ^ A \\sum\\limits_{i = 1} ^ B \\sum\\limits_{i = 1} ^ C ijk \\sum\\limits_{x \\mid (i, j)} g \\times \\mu(x) \\sum\\limits_{y \\mid (j, k)} g \\times \\mu(y) \\sum\\limits_{z \\mid (k, i)} g \\times \\mu(z) \\\\ &amp;= \\sum\\limits_{x = 1} ^ A \\sum\\limits_{y = 1} ^ B \\sum\\limits_{z = 1} ^ C h(x) h(y) h(z) \\sum\\limits_{x, z \\mid i} i \\sum\\limits_{x, y \\mid j} j \\sum\\limits_{y, z \\mid k} k \\\\ &amp;= \\sum\\limits_{x = 1} ^ A \\sum\\limits_{y = 1} ^ B \\sum\\limits_{z = 1} ^ C h(x) h(y) h(z) \\sum\\limits_{i = 1} ^ {A / \\mathrm{lcm}(x, z)} i \\times \\mathrm{lcm}(x, z) \\sum\\limits_{j = 1} ^ {B / \\mathrm{lcm}(x, y)} j \\times \\mathrm{lcm}(x, y) \\sum\\limits_{k = 1} ^ {C / \\mathrm{lcm}(y, z)} k \\times \\mathrm{lcm}(y, z) \\\\ &amp;= \\sum\\limits_{x = 1} ^ A \\sum\\limits_{y = 1} ^ B \\sum\\limits_{z = 1} ^ C h(x) h(y) h(z) S(A, \\mathrm{lcm}(x, z)) S(B, \\mathrm{lcm}(x, y)) S(C, \\mathrm{lcm}(y, z)) \\end{aligned} $$可以发现，后者 $x \\rightarrow y \\rightarrow z \\rightarrow x$ 构成了一个三元环，我们可以大概给出估界为 $\\mathcal{O(n \\log n \\log \\log n)}$。 因此暴力找出所有三元环的复杂度为：$\\mathcal{O(n \\log n \\log \\log n\\sqrt{n \\log n \\log \\log n})}$。 同时，因为这个在 $n = 5000$ 时与 $n ^ 2$ 无区别，因此连边可以使用暴力。但也可以枚举 $\\mathrm{Lcm}$ 再枚举其约数，使用 $\\mathcal{O(n \\log ^ 3n)}$ 连边。 此时我们算完了 $F$，可知总共需要算的 $F$ 只有 $\\sqrt{n}$ 种，若将单次复杂度看作 $n ^ 2$，因此总复杂度： $$\\mathcal{O(n ^ 2\\sum\\limits_{i = 1} ^ {n} \\frac{1}{i ^ 2})} = O(n ^ 2) $$经过卡常之后，效率提升大约五倍多，以下是如何卡常的： 我写了一个大范围内的打表程序，发现实际原做法的连边数量大约是 $n \\log n \\log \\log n$ 级别的，因此这个做法很有卡常前途。 我们把暴力连边换掉，枚举其约数，使用 $\\mathcal{O(n \\log ^ 3n)}$ 连边。连边暴力判断时不要求 $\\rm lcm$ 只需要求 $\\gcd(i / d_j, i / d_k)$ 具体参见代码。如果你想要过本题，是一定要优化连边的。 可以发现我们需要调用的 $\\rm lcm$ 只有每条边的两个端点，而在枚举 $\\rm Lcm$ 时是可以 $\\mathcal{O(1)}$ 得知的，因此我们在连边时记录这个值。 可以发现，$S$ 函数有很多是无用的，有用的第一维只有 $\\sqrt{A}$ 个，因此可以只预处理 $A \\sqrt{A}$ 个值。 $\\gcd$ 请不要暴力求，我们记忆化 $a, b \\leqslant 2e4$ 的部分，并用 $\\rm short$ 类型存储，减少空间消耗。 然后我们再给出一个复杂度为 $\\Theta(n^{1.5})$ 的正解做法。 方便起见用 $(x, y)$ 代指 $\\operatorname{gcd}(x, y)$ $$\\sum_{i=1}^{A} \\sum_{j=1}^{B} \\sum_{k=1}^{C} \\frac{(i, j, k) i j k}{(i, j)(j, k)(i, k)} $$枚举 $d$, 设 $F(A, B, C)=\\sum_{i=1}^{A} \\sum_{j=1}^{B} \\sum_{k=1}^{C} \\frac{i j k}{(i, j)(j, k)(i, k)}$ 考虑计算: $$\\sum_{d} \\varphi(d) F\\left(\\frac{A}{d}, \\frac{B}{d}, \\frac{C}{d}\\right) $$令 $n=\\max (A, B, C)$, 假定我们可以在 $\\mathcal{O}\\left(n^{c} \\log ^{k} n\\right)$ 的复杂度计算一组 $F(A, B, C)$, 则当 $c&gt;1$ 时，恒有 $\\sum \\frac{1}{d^{c}}$ 是收敛的，可以认为其为常数。 (不过比较大) 只需要考虑快速计算一组 $F(A, B, C)$, $\\rm remoon$ 给出的做法是同时反演三组，然后考虑通过三元环计数来计算答案，这里给出略为不同的思路: $$\\begin{aligned} &amp;F(A, B, C)=\\sum_{i=1}^{A} \\sum_{j=1}^{B} \\sum_{k=1}^{C} \\frac{i j k}{(i, j)(j, k)(i, k)} \\\\ &amp;=\\sum_{k} k \\sum_{d}(f * \\mu)(d) \\sum_{d \\mid i}^{A} \\frac{i}{\\operatorname{gcd}(i, k)} \\sum_{d \\mid j}^{B} \\frac{j}{\\operatorname{gcd}(j, k)} \\\\ &amp;=\\sum_{k} k \\sum_{d}(f * \\mu)(d) \\frac{d^{2}}{\\operatorname{gcd}(k, d)^{2}}\\left(\\sum_{i=1}^{A / d} \\frac{i}{\\operatorname{gcd}\\left(i, \\frac{k}{\\operatorname{gcd}(k, d)}\\right)}\\right)\\left(\\sum_{i=1}^{B / d} \\frac{i}{\\operatorname{gcd}\\left(i, \\frac{k}{\\operatorname{gcd}(k, d)}\\right)}\\right) \\end{aligned} $$不妨设 $F(t, x)=\\sum_{i \\leq t} \\frac{i}{\\operatorname{gcd}(i, x)}$, 记 $g(d)=(f * \\mu)(d) d^{2}$ 答案等价于： $$\\sum_{k}^{C} k \\sum_{d} \\frac{g(d)}{\\operatorname{gcd}(k, d)^{2}} F\\left(\\frac{A}{d}, \\frac{k}{\\operatorname{gcd}(k, d)}\\right) F\\left(\\frac{B}{d}, \\frac{k}{\\operatorname{gcd}(k, d)}\\right) $$枚举 $\\frac{k}{\\operatorname{gcd}(k, d)}$ 为 $x$, 此时考虑到我们只需要计算 $\\mathcal{O}(n \\sqrt{n})$ 组 $F(n, x)$ 考虑到 $F(n, x)$ 事实上就是: $$\\begin{aligned} &amp;\\sum_{i=1}^{n} \\frac{i}{\\operatorname{gcd}(i, x)} \\\\ &amp;=\\sum_{d \\mid x}(f * \\mu)(d) \\times d S\\left(\\frac{n}{d}\\right) \\end{aligned} $$枚举这 $\\sqrt{A}$ 种 $n$, 可以发现后式就是一个高维前缀和的形式，可以在 $\\mathcal{O}\\left(n^{1.5} \\log \\log n \\sim n^{1.5} \\log n\\right)$ 的复杂度完成计算。 考虑前半部分，不妨枚举 $d, \\operatorname{gcd}(k, d)$ （设为 $t$ ) 以及 $x$, 此时我们知道: $k=x t$, 故 $x t \\leq C$ $t \\mid d$ $\\operatorname{gcd}\\left(\\frac{d}{t}, x\\right)=1$ 固定了 $\\frac{A}{d}, \\frac{B}{d}$ 之后，我们可以发现 $d$ 属于区间 $[l, r]$, 此时我们考虑将答案差分，简而言之，我们的任务是计算 $n \\sqrt{n}$ 次下式: $$\\begin{aligned} &amp;x \\sum_{d \\leq R} g(d) \\sum_{t \\mid d} \\frac{1}{t}[x t \\leq C]\\left[\\operatorname{gcd}\\left(x, \\frac{d}{t}\\right)=1\\right] \\\\ &amp;=x \\sum_{c \\mid x} \\mu(c) \\sum_{c \\mid d, d \\leq R} g(d) \\sum_{t \\mid \\frac{d}{\\epsilon}} \\frac{1}{t}\\left[t \\leq \\frac{C}{x}\\right] \\end{aligned} $$首先，我们不难考虑到本质不同的 $\\frac{C}{x}$ 只有 $\\sqrt{n}$ 种，可以考虑枚举每种 $\\frac{C}{x}=m$ ，并在此时预处理: $$g(d) \\sum_{t \\mid d} \\frac{1}{t}[t \\leq m] $$对于某个 $m$ ，这可以在 $\\mathcal{O}(n \\log \\log n)$ 的复杂度完成计算，总体而言，此部分可以在 $\\mathcal{O}\\left(n^{1.5} \\log \\log n \\sim n^{1.5} \\log n\\right)$ 完成预处理，设其为 $G\\left(d, \\frac{C}{x}\\right)$ 最后，让我们为每个 $c$ 考虑，穷举可能的 $\\sqrt{n}$ 种 $m$ ，并为每个 $c$ 建立大小为 $\\frac{\\max R}{c}$ 的表格，显然表格的总大小为 $n \\log n$, 此时单组查询显然可以做到 $\\mathcal{O}(1)$, 由于 $x$ 穷举 $1 \\sim n$ ，考察其约数个数和显然为 $\\mathcal{O}(n \\log n)$, 总体而言我们可以在 $\\mathcal{O}\\left(n^{1.5} \\log n\\right)$ 解决此问题。 一点新的思路: 我们考虑枚举 $c$, 并为每个 $c$, 对 $\\frac{C / c}{x}$ 的所有可能的取值进行预处理，不难发现这个部分的复杂度为 $\\sum\\left(\\frac{n}{c}\\right)^{1.5}$ 通过积分不难证明这部分等效于 $n^{1.5}$ 莫比乌斯反演 一些定义和性质 $\\rm Dirichlet$ 卷积 : $\\sum\\limits_{d|n}f(d)g(\\frac{n}{d})$ 被定义为 $\\rm Dirichlet$ 卷积。 莫比乌斯 $(\\mu)$ 函数 : $$\\mu(n)= \\begin{cases}1 &amp; n=1 \\\\ 0 &amp; n \\text { 含有平方因子 } \\\\ (-1)^{k} &amp; k \\text { 为 } n \\text { 的本质不同质因子个数 }\\end{cases} $$显然，$\\mu$ 是积性函数，且它还有一些更加巧妙的性质，其中最常用的一个是 $\\mu \\times 1=\\varepsilon$。 $\\large\\rm Proof:$ 此处的乘号表示 $\\rm Dirichlet$ 卷积，$1$ 表示常数函数 $\\forall x\\in [1,+\\infty),f(x)=1$，$\\varepsilon$ 表示单位函数 $\\forall x\\in [1,+\\infty),f(x)=[x=1]$。 设 $n=\\prod_{i=1}^{k} p_{i}^{c_{i}}, n^{\\prime}=\\prod_{i=1}^{k} p_{i}$。 那么 $\\sum\\limits_{d \\mid n} \\mu(d)=\\sum\\limits_{d \\mid n^{\\prime}} \\mu(d)=\\sum\\limits_{i=0}^{k}\\tbinom{k}{i}\\cdot(-1)^{i}=(1+(-1))^{k}$。 根据二项式定理，易知该式子的值在 $k=0$ 即 $n=1$ 时值为 $1$ 否则为 $0$，这也同时证明了 $\\sum\\limits_{d \\mid n} \\mu(d)=[n=1]=\\varepsilon(n)$ 以及 $\\mu * 1=\\varepsilon$。 两个反演式子 $$[n=1]=\\sum_{d|n}\\mu(d) $$$\\large\\rm Proof:$ $$[n=1]=\\varepsilon(n)=\\mu \\times 1(n)=\\sum_{d|n}\\mu(d) $$我们来看看这个式子有什么应用： 例题 : 给定一个长度为 $n$ 的序列 $a$，给定 $m$ 个询问 $l,r,x$，求 $a_l,a_{l+1}......a_r$ 中有多少个数与 $x$ 互质。 保证 $n,m,a_i,x\\leqslant 10^5$。 考虑莫比乌斯反演: $\\left[\\left(a_{i}, x\\right)=1\\right]=\\sum\\limits_{\\left.d \\mid a_{i}, x\\right)} \\mu(d)=\\sum\\limits_{d\\left|a_{i}, d\\right| x} \\mu(d)$。 由于答案求 $\\sum\\limits_{i=l}^{r}\\left[\\left(a_{i}, x\\right)=1\\right]=\\sum\\limits_{i=l}^{r} \\sum\\limits_{d\\left|a_{i}, d\\right| x} \\mu(d)=\\sum\\limits_{d \\mid x} \\mu(d) \\sum\\limits_{i=l}^{r}\\left[d \\mid a_{i}\\right]_{\\text {.}}$ 考虑对于每一个数, 预处理出它的倍数出现在哪些位置, 然后询问时枚举所有 $x$ 的因数, 二分一下即可求出 $[l, r]$ 内它的倍数有多少个。时间复杂度 $\\Theta(n \\sigma(\\operatorname{maxa}) \\log n)$。 考虑对上述算法进行优化 ： 我们可以只考虑 $\\mu$ 值不等于 $0$ 的因数。 考虑预处理出小于 $\\sqrt{maxa}$ 的所有因数的前缀和，这样对于这些因数的询问是 $\\Theta(1)$ 的。 考虑我们相当于要求 $q$ 个询问不大于 $x$ 的为某个数的倍数的方案数。先将这些点排个序，然后就可以直接 $\\rm two~pointers$ 求。时间复杂度可以降到 $\\Theta(n\\sigma(maxa))$。 三者实现其一即可通过本题。 $$f(n)=\\sum_{d|n}g(d)\\iff g(n)=\\sum_{d|n}\\mu(d)f\\left(\\frac{n}{d}\\right) $$$\\large\\rm Proof:$ $$\\because f=g\\times I $$$$\\therefore f\\times \\mu=g\\times I \\times \\mu $$$$\\therefore f\\times \\mu=g\\times \\varepsilon = g $$我们来看看这个式子有什么应用： $\\rm [HAOI2011]Problem~B$ : 给出 $n$ 个询问，每个询问给定 $5$ 个整数 $a,b,c,d,k$，求 ： $$\\sum_{i=a}^{b}\\sum_{j=c}^d[\\gcd(i,j)=k] $$保证 $n,a,b,c,d,k\\leqslant 5\\times 10^4$。 根据容斥原理, 原式可以分成 $4$ 块来处理，每一块的式子都形如 ： $$\\sum_{i=1}^{n} \\sum_{j=1}^{m}[\\operatorname{gcd}(i, j)=k] $$考虑化简该式子 ： $$\\sum_{i=1}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor} \\sum_{j=1}^{\\left\\lfloor\\frac{m}{k}\\right\\rfloor}[\\operatorname{gcd}(i, j)=1] $$因为 $\\operatorname{gcd}(i, j)=1$ 时对答案才有贡献，于是我们可以将其替换为 $\\varepsilon(\\operatorname{gcd}(i, j))$，故原式化为 ： $$\\sum_{i=1}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor} \\sum_{j=1}^{\\left\\lfloor\\frac{m}{k}\\right\\rfloor} \\varepsilon(\\operatorname{gcd}(i, j)) $$将 $\\varepsilon$ 函数展开得到 ： $$\\sum_{i=1}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor} \\sum_{j=1}^{\\left\\lfloor\\frac{m}{k}\\right\\rfloor} \\sum_{d \\mid \\operatorname{gcd}(i, j)} \\mu(d) $$变换求和顺序, 先枚举 $d \\mid \\operatorname{gcd}(i, j)$ 可得 ： $$\\sum_{d=1}^{\\min \\left(\\left\\lfloor\\frac{n}{k}\\right\\rfloor,\\left\\lfloor\\frac{m}{k}\\right\\rfloor\\right)} \\mu(d) \\sum_{i=1}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor}[d \\mid i] \\sum_{j=1}^{\\left\\lfloor\\frac{m}{k}\\right\\rfloor}[d \\mid j] $$易知 $1 \\sim\\left\\lfloor\\frac{n}{k}\\right\\rfloor$ 中 $d$ 的倍数有 $\\left\\lfloor\\frac{n}{k d}\\right\\rfloor$ 个, 故原式化为 ： $$\\sum_{d=1}^{\\min \\left(\\left\\lfloor\\frac{n}{k}\\right\\rfloor,\\left\\lfloor\\frac{m}{k}\\right\\rfloor\\right)} \\mu(d)\\left\\lfloor\\frac{n}{k d}\\right\\rfloor\\left\\lfloor\\frac{m}{k d}\\right\\rfloor $$很显然，式子可以数论分块求解。 时间复杂度 $\\Theta(W+n\\sqrt{W})$。 莫比乌斯反演的非卷积形式 对于数论函数 $f,g$ 和完全积性函数 $t$，满足 $t(1)=1$，有 ： $$f(n)=\\sum_{i=1}^nt(i)g\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)\\\\ \\iff g(n)=\\sum_{i=1}^n\\mu(i)t(i)f\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right) $$$\\large\\rm Proof:$ $$\\begin{aligned} g(n)&amp;=\\sum_{i=1}^n\\mu(i)t(i)f\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)\\\\ &amp;=\\sum_{i=1}^n\\mu(i)t(i) \\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}t(j) g\\left(\\left\\lfloor\\frac{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}{j}\\right\\rfloor\\right)\\\\ &amp;=\\sum_{i=1}^n\\mu(i)t(i) \\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}t(j) g\\left(\\left\\lfloor\\frac{n}{ij}\\right\\rfloor\\right)\\\\ &amp;=\\sum_{T=1}^n \\sum_{i=1}^n\\mu(i)t(i) \\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}[ij=T] t(j)g\\left(\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\right) &amp;\\\\ &amp;=\\sum_{T=1}^n \\sum_{i \\mid T}\\mu(i)t(i) t\\left(\\frac{T}{i}\\right)g\\left(\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\right) \\\\ &amp;=\\sum_{T=1}^ng\\left(\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\right) \\sum_{i \\mid T}\\mu(i)t(i)t\\left(\\frac{T}{i}\\right)\\\\ &amp;=\\sum_{T=1}^ng\\left(\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\right) \\sum_{i \\mid T}\\mu(i)t(T)\\\\ &amp;=\\sum_{T=1}^ng\\left(\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\right)t(T) \\sum_{i \\mid T}\\mu(i)\\\\ &amp;=\\sum_{T=1}^ng\\left(\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\right)t(T) \\varepsilon(T) &amp;\\\\ &amp;=g(n)t(1) &amp;\\\\ &amp;=g(n) &amp; \\end{aligned} $$","tags":"算法 oi 组合数学 二项式反演 斯特林反演 min-max-反演 gcd-lcm-反演 莫比乌斯反演"},{"title":"杜教筛","url":"/2023/06/24/du-jiao-shai/","text":"杜教筛被用来求积性函数的前缀和。 设有积性函数 $f(x)$，其前缀和为 $S(n) = \\sum \\limits_ {i = 1} ^ n f(i)$。 考虑构造 $h(x)$ 和 $g(x)$，满足 $h = f \\times g$。 推一下式子 ： $$\\begin{aligned} \\sum _ {i = 1} ^ n h(i) &amp;= \\sum _ {i = 1} ^ n \\sum _ {d | i} g(d) \\times f\\left(\\frac{i}{d}\\right) \\\\ &amp;= \\sum _ {d = 1} ^ n g(d) \\sum _ {i = 1} ^ {\\left\\lfloor\\frac{n}{d}\\right\\rfloor} f(i) \\\\ &amp;= \\sum _ {d = 1} ^ n g(d) S\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\right) \\end{aligned} $$众所周知有数论分块。 具体来说，观察到式子右边的 $S\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\right)$ 最多有 $2\\sqrt{n}$ 种取值。证明考虑 $\\sum \\limits_ {d = 1} ^ {\\sqrt{n}} \\left\\lfloor\\frac{n}{d}\\right\\rfloor$ 显然最多有 $\\sqrt{n}$ 种取值，$\\forall d &gt; \\sqrt{n},\\left\\lfloor\\frac{n}{d}\\right\\rfloor &lt; \\sqrt{n}$，故 $\\sum \\limits_ {d = \\sqrt{n} + 1} ^ {n} \\left\\lfloor\\frac{n}{d}\\right\\rfloor$ 也最多有 $\\sqrt{n}$ 种取值。 于是这时候只需要考虑对于一个数 $i$，满足 $\\left\\lfloor\\frac{n}{i}\\right\\rfloor = \\left\\lfloor\\frac{n}{j}\\right\\rfloor$ 的最大的 $j$ 是多少。 设 $k = \\left\\lfloor\\frac{n}{i}\\right\\rfloor$，则有 $\\left\\lfloor\\frac{n}{j}\\right\\rfloor = k$，将向下取整去掉，有 $k \\leqslant \\frac{n}{j} &lt; k + 1$，取倒数，得到 $\\frac{1}{k + 1} &lt; \\frac{j}{n} \\leqslant \\frac{1}{k}$，全部乘上 $n$ 得到 $\\frac{n}{k + 1} &lt; j \\leqslant \\frac{n}{k}$，又因为 $j$ 为整数，所以 $j_{\\max} = \\left\\lfloor\\frac{n}{k}\\right\\rfloor = \\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor$。 言归正传，求解杜教筛最终式子时可以直接递归，中间需要记忆化一下，但其实不需要用到 $\\rm map$ 系列 $\\rm STL$，因为可以证明需要求解的 $S(x)$ 中 $x \\in \\{\\left\\lfloor\\frac{n}{d}\\right\\rfloor{}|d \\in [1, n]\\}$。 稍加思考就可以发现，上式的一个充分条件为 $\\left\\lfloor\\frac{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}{j}\\right\\rfloor = \\left\\lfloor\\frac{n}{ij}\\right\\rfloor$，考虑其证明：$\\forall x \\in Z$，若有 $x \\leqslant \\left\\lfloor\\frac{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}{j}\\right\\rfloor$，那么有 $xj \\leqslant \\left\\lfloor\\frac{n}{i}\\right\\rfloor$，进一步有 $xij \\leqslant n$，再将 $ij$ 放回去有 $x \\leqslant \\left\\lfloor\\frac{n}{ij}\\right\\rfloor$，原式得证。 故我们只需要将 $\\left\\lfloor\\frac{n}{d}\\right\\rfloor~(d \\in [1, n] \\cap Z)$ 的所有取值映射到一个数组上就可以直接记忆化了。 考虑复杂度证明，记忆化以后每个 $S(x)$ 只需要算一次，而算一次 $S(x)$ 的时间复杂度为 $\\Theta(\\sqrt{x})$。 故总时间复杂度为 $\\sum\\limits_{x} \\sqrt{x}~(x \\in \\{\\left\\lfloor\\frac{n}{d}\\right\\rfloor|d \\in [1, n] \\cap Z\\})$。 对于不大于 $\\sqrt{n}$ 的 $d$，其贡献的复杂度上界为 $\\sum \\limits_{i = 1} ^ {\\sqrt{n}} \\Theta\\left(\\sqrt{\\frac{n}{i}}\\right)$，而对于大于 $\\sqrt{n}$ 的 $d$，$\\left\\lfloor\\frac{n}{d}\\right\\rfloor$ 的取值不大于 $\\sqrt{n}$，所以其贡献的上界为 $\\sum \\limits_{i = 1} ^ {\\sqrt{n}} \\Theta(\\sqrt{i})$，其和为 $T(n) = \\sum \\limits_{i = 1} ^ {\\sqrt{n}} \\Theta\\left(\\sqrt{\\frac{n}{i}}\\right) + \\sum \\limits_{i = 1} ^ {\\sqrt{n}} \\Theta(\\sqrt{i})$，积分求个近似可以得到 $T(n) \\approx \\int_{1}^{\\sqrt{n}} \\Theta\\left(\\sqrt{\\frac{n}{x}}\\right) dx + \\int_{1}^{\\sqrt{n}} \\Theta(\\sqrt{x}) dx = \\Theta(n ^ {\\frac{3}{4}})$。 事实上还可以做到更优，线性预处理 $f$ 的前 $m$ 项，易知复杂度变成了 $\\Theta(m) + \\Theta\\left(\\sum \\limits_{i = 1} ^ {\\frac{n}{m}} \\sqrt{\\frac{n}{i}}\\right)$，跟之前一样积分近似一下可以得到复杂度即为 $\\Theta(m + nm ^ {-\\frac{1}{2}})$，易知其下界为 $\\Theta(n ^ {\\frac{2}{3}})$。 在此列举一些常见的构造（其证明需要用到迪利克雷生成函数，略过）： $(id ^ k \\cdot \\mu) \\times id ^ k = \\varepsilon$ $(id ^ k \\cdot \\varphi) \\times id ^ k = id ^ {k + 1}$ $(id ^ k \\cdot \\sigma _ k) \\times (id ^ k \\cdot \\mu) = id ^ {2k}$","tags":"算法 oi c++ 数论 复杂度 杜教筛 欧拉函数 积性函数 莫比乌斯函数"},{"title":"多项式","url":"/2023/06/24/duo-xiang-shi/","text":"拉格朗日插值 插值问题形如 ：给定 $n$ 个点的坐标 $(x, y)$，要求出一个经过所有点的最低次多项式。 一般插值 容易构造出 $f(x)$ 即为下式 ： $$f(x) = \\sum _{i = 1} ^{n} y_i \\prod _{j \\not= i} \\frac{x - x_j}{x_i - x_j}\\tag{1.1.1} $$正确性显然。 容易证明多项式次数至少为 $n - 1$ 才可以确保穿过 $n$ 个点，故最优性得证。 时间复杂度 $\\Theta(n^ 2)$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 2e3 + 10, mod = 998244353; int n, k, x[N], y[N], ans; int Pow (int a, int k) &#123; int res = 1; for ( ; k; a = 1ll * a * a % mod, k &gt;&gt;= 1) if(k &amp; 1) res = 1ll * res * a % mod; return res; &#125; int main () &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); rep(i, 1, n) scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]); rep(i, 1, n) &#123; int S1 = 1, S2 = 1; rep(j, 1, n) if (j != i) &#123; S1 = 1ll * S1 * (k - x[j]) % mod; S2 = 1ll * S2 * (x[i] - x[j]) % mod; &#125; ans = (ans + 1ll * y[i] * S1 % mod * Pow(S2, mod - 2)) % mod; &#125; printf(&quot;%d\\n&quot;, (ans + mod) % mod); return 0; &#125; 点值连续的插值 当给定的点值连续时，式子可以改写为 ： $$\\begin{aligned} f(x) = \\sum _{i = 1} ^{n} y_i \\prod _{j \\not= i} \\frac{x - j}{i - j} = \\sum _{i = 1} ^{n} y_i \\frac{\\prod \\limits _{j \\not= i}(x - j)}{\\prod \\limits_{j \\not= i}(i - j)} \\end{aligned} $$考虑计算分子，记 $pre_i = \\prod _{j = 1} ^{i} (x - j), suf_i = \\prod _{j = i} ^{n} (x - j)$，显然 $\\prod _{j \\not= i}(x - j) = pre_{i - 1}\\times suf_{i + 1}$。 考虑计算分母，记 $sym(x) = 1 - 2[x \\equiv 1 \\pmod 2]$，显然 $\\prod _{j \\not= i}(i - j) = (i - 1)!\\times sym(n - i)(n - i)!$。 全部带入可将式 $(1.2.1)$ 改写为 ： $$f(x) = \\sum _{i = 1} ^n y_i \\frac{pre_{i - 1}\\times suf_{i + 1}}{(i - 1)!\\times sym(n - i)(n - i)!} \\tag{1.2.2} $$时间复杂度 $\\Theta(n)$。 int F (int n, int k) &#123; fac[0] = 1; rep(i, 1, k + 2) fac[i] = fac[i - 1] * i % mod; inv[k + 2] = Pow(fac[k + 2], mod - 2); dep(i, k + 1, 0) inv[i] = inv[i + 1] * (i + 1) % mod; pre[0] = suf[k + 3] = 1; rep(i, 1, k + 2) pre[i] = pre[i - 1] * (n - i) % mod; dep(i, k + 2, 1) suf[i] = suf[i + 1] * (n - i) % mod; rep(i, 1, k + 2) y[i] = (y[i - 1] + Pow(i, k)) % mod; int res = 0; rep(i, 1, k + 2) res = (res + y[i] * pre[i - 1] % mod * suf[i + 1] % mod * inv[i - 1] % mod * inv[k + 2 - i] * (((k + 2 - i) &amp; 1) ? -1 : 1)) % mod; return (res + mod) % mod; &#125; 重心拉格朗日插值法 考虑一般插值的优化。 观察式 $(1.1.1)$，设 : $$G = \\prod _{i = 1} ^n (x - x_i) \\tag{1.3.1} $$$$T_i = \\frac{y_i}{\\prod \\limits_{j \\not= i} (x_i - x_j)} \\tag{1.3.2} $$将式 $(1.3.1)$ 和 $(1.3.2)$ 带入式 $(1.1.1)$ 可得 ： $$f(x) = G \\sum _{i = 1} ^{n} \\frac{T_i}{x - x_i} \\tag{1.3.3} $$如此一来，新加入一个点就只需要计算它的 $T$ 值了，时间复杂度为 $\\Theta(n)$。 还原插值多项式的系数 考虑对式 $(1.1.1)$ 作变形 ： $$f(x) = \\sum _{i = 1} ^{n} \\frac{y_i}{\\prod \\limits_{j \\not= i}(x_i - x_j)} \\prod _{j \\not= i} (x - x_j)\\tag{1.4.1} $$可以 $\\Theta(n^2)$ 预处理 $\\prod_{i = 1}^n (x - x_i)$，然后在需要求 $\\prod _{j \\not= i} (x - x_j)$ 时将预处理出的多项式除以 $(x - x_i)$ ，可以做到单次 $\\Theta(n)$ 的时间复杂度。 还原插值多项式系数的时间复杂度为 $\\Theta(n^2)$。 自然数幂前缀和 有定理：不大于 $n$ 的自然数 $k$ 次幂和是一个关于 $n$ 的 $k + 1$ 次多项式。 $\\rm Proof :$ 设 $f_k(n) = \\sum \\limits _{i = 1} ^n i ^ k$。 当 $k = 1$ 时，$f_k(n) = \\sum \\limits _{i = 1} ^n i = \\frac{1}{2}n ^ 2 + \\frac{1}{2} n$，是一个 $k + 1$ 次多项式。 假设 $f_{k - 1}(n)$ 是一个关于 $n$ 的 $k$ 次多项式。 即 $f_{k - 1}(n) = a_0 + a_1 n + a_2 n ^ 2 + \\cdots + a_k n ^ k$。 $$\\begin{aligned} f_k(n) &amp;= \\sum _{i = 1} ^n i\\times i ^ {k - 1}\\\\ &amp;= \\sum _{i = 0} ^{n - 1} f_{k - 1}(n) - f_{k - 1}(i)\\\\ &amp;= nf_{k - 1}(n) - \\sum _{i = 1} ^{n - 1} f_{k - 1}(i)\\\\ &amp;= a_0 n + a_1 n ^ 2 + \\cdots + a_k n ^ {k + 1} - \\sum _{i = 1} ^{n - 1} f_{k - 1}(i) \\end{aligned} $$容易发现，由于 $f_{k - 1}(i)$ 中次数最高的项为 $k$ 次项，并且 $f_k(n)$ 中含有关于 $n$ 的 $k + 1$ 次项，所以 $f_k(n)$ 是关于 $n$ 的 $k + 1$ 次多项式。 归纳可得 ：$\\forall k\\geqslant 1,~f_k(n)$ 是关于 $n$ 的 $k$ 次多项式。 于是可以使用点值连续的拉格朗日插值计算 $\\sum \\limits_{i = 1} ^n i^k$，时间复杂度 $\\Theta(k)$。 快速傅里叶变换 快速傅里叶变换 $\\rm (Fast~Fourier~Transformation,FFT)$ 被用来在 $\\Theta(n\\log n)$ 的时间复杂度下求两个多项式的乘积（和卷积）。 若称 $h(x) = f(x) \\times g(x)$，则应满足关系式 ： $$h(k) = \\sum _{i + j = k} f(i) \\times g(j) \\tag{2.0.1} $$单位根 众所周知，有欧拉公式 ： $$e^{i\\theta} = \\cos \\theta + i\\sin \\theta \\tag{2.1.1} $$根据高中课本上所讲的，我们知道任意一个复数可以被表示成 $r(\\cos \\theta + i\\sin \\theta)$ 的形式，根据式 $(2.1.1)$，可以发现其等价于 $r \\cdot e^{i\\theta}$，所以两个复数相乘，模长 $(r)$ 相乘，幅角 $(\\theta)$ 相加。 考虑方程 $x ^ n = 1$，容易发现它在复数域内有 $n$ 个解，解集为 $\\{e^{i\\theta}~|~\\theta = \\frac{2k\\pi}{n},k = 0,1,2, \\cdots, n - 1 \\}$，将其简记为 $\\omega_n^0,\\omega_n^1,\\cdots,\\omega_n^{n - 1}$，进一步观察可以发现，它们是复平面中单位圆上的 $n$ 等分点。 之所以会在 $\\rm FFT$ 中用到单位根，主要是因为它具有以下性质 ： 折半性质 ： $$\\omega_{2n} ^ {2k} = \\omega _n ^k \\tag{2.1.2} $$$\\rm Proof :$ 显然有 $\\omega_n ^k = (\\omega _n ^1) ^k$ 和 $\\omega _n ^ 1 = \\omega _{2n} ^2$。 对称性质 ： $$\\omega _{2n} ^ {k + n} = -\\omega _{2n} ^{k} \\tag{2.1.3} $$$\\rm Proof :$ 这里定义 $-z$ 为 $z$ 关于原点的对称点，显然有 $\\omega _{2n} ^n = -1$，$\\omega _{2n} ^{k + n} = \\omega _{2n} ^k\\times \\omega _{2n} ^n = -\\omega _{2n} ^k$。 求和性质 ： $$\\sum _{i = 0} ^{n - 1} \\left(\\omega_{n} ^k\\right) ^i = n[k = 0] \\tag{2.1.4} $$$\\rm Proof :$ 首先使用等比数列求和公式 ： $$\\sum _{i = 0} ^{n - 1} \\left(\\omega_{n} ^k\\right) ^i = \\frac{1 - \\left(\\omega_{n} ^k\\right)^n}{1 - \\omega_n^k} \\tag{2.1.5} $$考虑分类讨论 ： 当 $k = 0$ 时，原式显然等于 $n$。 当 $k \\not = 0$ 时，$1 - \\omega_n^k \\not = 0$，$1 - \\left(\\omega_{n} ^k\\right)^n = 0$，故原式等于 $0$。 离散傅里叶变换 离散傅里叶变换 $\\rm (Discrete~Fourier~Transform,DFT)$ 被用于求出多项式的 $n$ 个点值，其中 $n$ 为多项式的项数，$\\rm DFT$ 是 $\\rm FFT$ 的前半部分。 对于一个多项式 $F(x) = a_0 + a_1 x + a_2 x^2 + \\cdots + a_{n - 1} x ^ {n - 1}$，不妨设 ： $$\\begin{aligned} F_1(x) = a_0 + a_2x + a_4x^2 + \\cdots + a_{n - 2}x^{\\frac{n}{2} - 1}\\\\ F_2(x) = a_1 + a_3x + a_5x^2 + \\cdots + a_{n - 1}x^{\\frac{n}{2} - 1} \\end{aligned} $$于是有 $F(x) = F_1(x^2) + xF_2(x^2)$。 将 $\\omega_n^k$ 带入可得 ： $$F(\\omega_n^k) = F_1(\\omega_n^{2k}) + \\omega_n^k F_2(\\omega_n^{2k}) \\tag{2.2.1} $$根据式 $(2.1.2)$ 可得 ： $$F(\\omega_n^k) = F_1(\\omega_{n/2}^{k}) + \\omega_n^k F_2(\\omega_{n/2}^{k}) \\tag{2.2.2} $$考虑分类讨论 ： 对于 $k &lt; \\frac{n}{2} $，只需要直接递归处理 $F_1$ 和 $F_2$ 即可。 对于 $k \\geqslant \\frac{n}{2}$，我们不妨它为 $k + \\frac{n}{2}~(k &lt; \\frac{n}{2})$，于是有 ： $$F(\\omega_n^{k + n/2}) = F_1(\\omega_n^{2k + n}) + \\omega_n^{k + n/2} F_2(\\omega_n^{2k + n}) \\tag{2.2.3} $$根据式 $(2.1.2)$ 和 $(2.1.3)$ 可得 ： $$F(\\omega _ n ^ k) = F_1(\\omega_{n / 2} ^ k) - \\omega _ n ^ k F_2(\\omega_{n/2}^k) \\tag{2.2.4} $$观察发现，式 $(2.2.2)$ 和 $(2.2.4)$ 之间仅相差一个符号，这意味着我们只需要递归求出 $F_1$ 和 $F_2$ 的 $\\frac{n}{2}$ 个点值就可以在 $\\Theta(n)$ 的时间复杂度下求出 $F$ 的 $n$ 个点值。 因为最多递归 $\\log n$ 次，每一层的总时间复杂度为 $\\Theta(n)$，所以 $\\rm DFT$ 过程的时间复杂度为 $\\Theta(n\\log n)$。 离散傅里叶逆变换 离散傅里叶逆变换 $\\rm (Inverse~Discrete~Fourier~Transform,IDFT)$ 被用于将多项式的点值表示还原成系数表示，是 $\\rm FFT$ 的后半部分。 在 $\\rm DFT$ 过程中我们已经将待乘函数 $f(x)$ 和 $g(x)$ 的点值表示分别求了出来，易知它们卷积的点值序列为它们点值序列各处分别相乘的结果。 设 $\\{G_n\\}$ 为 $F(x)$ 在 $\\rm DFT$ 过程中求出的点值序列，$\\{F_n\\}$ 是 $F(x)$ 的系数序列，则根据定义有 ： $$G_k = \\sum _{i = 0} ^{n - 1} \\left(\\omega_{n}^{k}\\right) ^ i F_i \\tag{2.3.1} $$此处有反演结论 ： $$nF_k = \\sum_{i = 0} ^{n - 1} \\left(\\omega_{n}^{-k}\\right) ^ i G_i \\tag{2.3.2} $$$\\rm Proof :$ $$\\begin{aligned} nF_k &amp;= \\sum_{i = 0} ^ {n - 1} \\sum _{j = 0} ^ {n - 1} \\left(\\omega_{n} ^{-k}\\right) ^ i \\left(\\omega_{n} ^{i}\\right) ^ j F_j\\\\ &amp;= \\sum_{i = 0} ^ {n - 1} \\sum _{j = 0} ^ {n - 1} \\omega_{n} ^{i(j - k)} F_j \\end{aligned} $$将式 $(2.1.4)$ 带入 $(2.3.3)$ 可得 ： $$\\begin{aligned} nF_k &amp;= \\sum _{j = 0} ^ {n - 1} \\sum_{i = 0} ^ {n - 1} \\left(\\omega_{n} ^{j - k}\\right)^i F_j\\\\ &amp;= \\sum_{j = 0} ^ {n - 1} n[j = k] F_j\\\\ &amp;= nF_k \\end{aligned} $$故利用式 $(2.3.2)$ 将 $\\{G_n\\}$ 带入 $\\rm DFT$ 过程，以 $\\omega_n^{-1}$ 作为一次单位根得出的点值即为 $F(x)$ 的系数序列。 $\\rm IDFT$ 过程的时间复杂度为 $\\Theta(n\\log n)$。 至此，我们已经推导出了一个时间复杂度为 $\\Theta(n\\log n)$，可以递归实现的 $\\rm FFT$ 算法，需要注意的是，由于递归时需要两边长度相等，所以 $F(x)$ 的长度必须是 $2$ 的幂，少了的部分通过在高次项以 $0$ 作为系数来补齐。 位逆序置换 位逆序置换 $\\rm (Bit-Reversal~Permutation)$ 是 $\\rm FFT$ 中一个较大的优化，在国内又称蝴蝶变换。 它的优化主要在于将原本的递归实现变成了迭代实现。 在递归实现中，我们每一次都会把整个多项式的奇数次项和偶数次项系数分开，一直分到只剩下一个系数。但是我们也可以先把这些系数在原数组中拆分，然后再倍增地去合并这些算出来的值。 以 $8$ 项多项式为例，模拟拆分的过程 : 初始序列为 : $\\left\\{x_{0}, x_{1}, x_{2}, x_{3}, x_{4}, x_{5}, x_{6}, x_{7}\\right\\}$。 一次二分之后 : $\\left\\{x_{0}, x_{2}, x_{4}, x_{6}\\right\\},\\left\\{x_{1}, x_{3}, x_{5}, x_{7}\\right\\}$。 两次二分之后 : $\\left\\{x_{0}, x_{4}\\right\\}, \\left\\{x_{2}, x_{6}\\right\\},\\left\\{x_{1}, x_{5}\\right\\},\\left\\{x_{3}, x_{7}\\right\\}$。 三次二分之后 : $\\left\\{x_{0}\\right\\}, \\left\\{x_{4}\\right\\}, \\left\\{x_{2}\\right\\}, \\left\\{x_{6}\\right\\}, \\left\\{x_{1}\\right\\}, \\left\\{x_{5}\\right\\}, \\left\\{x_{3}\\right\\}, \\left\\{x_{7}\\right\\}$。 可以发现，只要把最后一层每个位置对应的坐标求出来，然后每次迭代时插空合并相邻两项即可。 记 $R(x)$ 表示 $x$ 在全部分治完后去到的位置，观察发现 $R(x)$ 是 $x$ 在二进制意义下翻转后的值。 首先有 $R(0) = 0$，剩下的考虑从小到大求解，显然有 ： $$R(x) = \\left\\lfloor\\frac{R\\left(\\left\\lfloor\\frac{x}{2}\\right\\rfloor\\right)}{2}\\right\\rfloor+(x \\bmod 2) \\times 2^{k - 1} \\tag{2.4.1} $$求解 $R(x)$ 并将每个数换到应该去的位置时间复杂度为 $\\Theta(n)$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 3e6; const double Pi = acos(-1.0); struct Complex &#123; double x, y; &#125; F[N], G[N]; Complex operator + (Complex a, Complex b) &#123; return (Complex)&#123;a.x + b.x, a.y + b.y&#125;; &#125; Complex operator - (Complex a, Complex b) &#123; return (Complex)&#123;a.x - b.x, a.y - b.y&#125;; &#125; Complex operator * (Complex a, Complex b) &#123; return (Complex)&#123;a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x&#125;; &#125; int n, m, len, ln, R[N]; void FFT (Complex *F, int type) &#123; rep(i, 0, len - 1) if (i &lt; R[i]) swap(F[i], F[R[i]]); for (int k = 1; k &lt; len; k &lt;&lt;= 1) &#123; Complex eps = (Complex)&#123;cos(Pi / k), type * sin(Pi / k)&#125;; for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) &#123; Complex w = (Complex)&#123;1, 0&#125;; for (int j = i; j &lt; i + k; j++, w = w * eps) &#123; Complex tmp1 = F[j], tmp2 = w * F[j + k]; F[j] = tmp1 + tmp2, F[j + k] = tmp1 - tmp2; &#125; &#125; &#125; &#125; int main () &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); rep(i, 0, n) scanf(&quot;%lf&quot;, &amp;F[i].x); rep(i, 0, m) scanf(&quot;%lf&quot;, &amp;G[i].x); for (len = 1, ln = 0; len &lt;= n + m; len &lt;&lt;= 1, ln++); rep(i, 0, len - 1) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); FFT(F, 1), FFT(G, 1); rep(i, 0, len - 1) F[i] = F[i] * G[i]; FFT(F, -1); rep(i, 0, n + m) printf(&quot;%d &quot;, (int)round(F[i].x / len)); return 0; &#125; 快速数论变换 由于 $\\rm FFT$ 对单位根的依赖，所以该算法必须使用浮点数保存，进而引发精度问题。糟糕的是，数学家已经证明了在复数域内仅有单位根满足所需性质。 值得庆幸的是，大多数计数问题是在模意义下完成的，于是我们希望为 $\\rm FFT$ 找一个模意义下的替代品，最终方案为快速数论变换 $\\rm (Number~Theoretic~Transform,NTT)$。 原根 原根的定义如下 ： 如果有 $a^n \\equiv 1 \\pmod p$，则称满足此条件最小的 $n$ 为 $a$ 在模 $p$ 意义下的阶。若一个数 $g$ 在模 $p$ 意义下的原根为 $\\varphi(p)$，那么称 $g$ 为 $p$ 的原根。 我们尝试用原根代替单位根进行运算，所以需要先证明以下几条性质 ： 不重性质： $$\\forall 0\\leqslant i &lt; j &lt; \\varphi (p),g^i \\not \\equiv g^j \\pmod p \\tag{3.1.1} $$$\\rm Proof :$ 若存在 $0\\leqslant i &lt; j &lt; \\varphi (p)$ 满足 $g^i \\equiv g^j \\pmod p$，那么 $0\\leqslant j - i &lt; \\varphi (p)$ 且 $g^{j - i} \\equiv 1 \\pmod p$，与原根的定义矛盾，故原命题得证。 折半性质： 定义 $g_n^1 = g^{\\frac{p - 1}{n}},g_n^k = (g_n^1)^k$ 则 ： $$g_{2n}^{2k} \\equiv g_n^k \\pmod p \\tag{3.1.2} $$$\\rm Proof :$ 由式 $(3.1.1)$ 可得 $g_n^0,g_n^1,g_n^2,\\cdots,g_n^{n - 1}$ 互不相同。将 $g_n^k$ 的定义带入易证式 $(3.1.2)$。 对称性质： $$g_{2n}^{k + n} \\equiv -g_{2n}^k \\pmod p \\tag{3.1.3} $$$\\rm Proof :$ 参照式 $(2.1.3)$ 的证明方法，我们只需要证明 $g_{2n}^n \\equiv -1 \\pmod p$ 即可。 $$(g_{2n}^n) ^ 2 \\equiv (g^{\\frac{p - 1}{2}}) ^ 2 \\equiv g^{p - 1} \\equiv 1 \\pmod p \\tag{3.1.4} $$所以 $g_{2n}^n \\equiv 1~or-1 \\pmod p$。 根据式 $(3.1.1)$，我们知道 $g_{2n}^n \\not \\equiv g^{p - 1} \\pmod p$，又因为 $g^{p - 1} \\equiv 1 \\pmod p$，故 $g_{2n}^n \\equiv -1 \\pmod p$。 求和性质： $$\\sum _{i = 0} ^{n - 1} \\left(g_{n} ^k\\right) ^i \\equiv n[k = 0] \\pmod p \\tag{3.1.5} $$$\\rm Proof :$ 参照式 $(2.1.4)$ 的证明。 有了以上 $4$ 条性质，我们就可以直接将原根带入 $\\rm DFT$ 运算了。 另外，由于 $\\rm DFT$ 运算中的多项式长度 $n$ 均为 $2$ 的幂，并且我们取的模数 $p$ 需要满足 $p - 1$ 能整除足够大的 $n$，所以 $p - 1$ 要包含一个较大的因子是 $2$ 的幂。 比较常用的 $\\rm NTT$ 模数是 $998244353 = 119 \\times 2 ^ {23} + 1$，它的最小原根是 $3$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 3e6, mod = 998244353; int n, m, len, ln, F[N], G[N], rev[N]; int Pow (int a, int k) &#123; int res = 1; for ( ; k; a = 1ll * a * a % mod, k &gt;&gt;= 1) if(k &amp; 1) res = 1ll * res * a % mod; return res; &#125; void NTT (int *F, bool type) &#123; rep(i, 0, len) if (i &lt; rev[i]) swap(F[i], F[rev[i]]); for (int k = 1; k &lt; len; k &lt;&lt;= 1) &#123; int eps = Pow(type ? 3 : 332748118, (mod - 1) / (k &lt;&lt; 1)); for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i, g = 1; j &lt; i + k; j++, g = 1ll * g * eps % mod) &#123; int tmp1 = F[j], tmp2 = 1ll * g * F[j + k] % mod; F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2; F[j + k] = tmp1 - tmp2 &lt; 0 ? tmp1 - tmp2 + mod : tmp1 - tmp2; &#125; &#125; &#125; int main () &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); rep(i, 0, n) scanf(&quot;%d&quot;, &amp;F[i]); rep(i, 0, m) scanf(&quot;%d&quot;, &amp;G[i]); for (len = 1, ln = 0; len &lt;= n + m; len &lt;&lt;= 1, ln++); rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(F, true), NTT(G, true); rep(i, 0, len - 1) F[i] = 1ll * F[i] * G[i] % mod; NTT(F, false); int Inv = Pow(len, mod - 2); rep(i, 0, n + m) printf(&quot;%lld &quot;, 1ll * F[i] * Inv % mod); return 0; &#125; $\\rm Chirp~Z$ 变换 $\\rm Chirp~Z-Transform$ 又称 $\\rm Bluestein$ 算法，与 $\\rm DFT$ 类似，它被用于在 $\\Theta[(n + m) \\log n]$ 的时间复杂度内求解如下问题 ： 给定 $n$ 次多项式 $F(x)$，求出 $F(1),F(c),F(c^2),\\cdots,F(c^m)$，$c \\in \\mathbb{C}$。 考虑组合恒等式 ： $$ik = \\dbinom{i + k}{2} - \\dbinom{i}{2} - \\dbinom{k}{2} \\tag{3.2.1} $$$\\rm Proof :$ $$\\begin{aligned} ik &amp;= \\frac{2ik}{2}\\\\ &amp;= \\frac{(i ^ 2 + 2ik + k ^ 2 - i - k) - (i ^ 2 - i) - (k ^ 2 - k)}{2}\\\\ &amp;= \\dbinom{i + k}{2} - \\dbinom{i}{2} - \\dbinom{k}{2} \\end{aligned} $$于是有 ： $$\\begin{aligned} F(c ^ k) &amp;= \\sum _{i = 0} ^ {n - 1} a_i c ^ {ik}\\\\ &amp;= \\sum _{i = 0} ^ {n - 1} a_i c ^ {\\binom{i + k}{2} - \\binom{i}{2} - \\binom{k}{2}}\\\\ &amp;= c ^ {-\\binom{k}{2}} \\sum _{i = 0} ^{n - 1} \\left[a_i c ^ {-\\binom{i}{2}} \\right] \\left[c ^ {\\binom{i + k}{2}} \\right] \\end{aligned} $$设 $f(x) = c ^ {\\binom{x}{2}}, g(x) = a_xc^{-\\binom{x}{2}}$，则有 ： $$\\frac{F(c ^ k)}{c ^ {-\\binom{k}{2}}} = \\sum _ {i - j = k} f(i) \\times g(j) \\tag{3.2.4} $$可以使用减法卷积来计算，时间复杂度 $\\Theta[(n + m) \\log n]$。 具体来说，计算减法卷积时一般将 $g(x)$ 翻转，即 $g'(i) = g(m - i)$，于是有 ： $$\\begin{aligned} \\frac{F(c ^ k)}{c ^ {-\\binom{k}{2}}} &amp;= \\sum _ {i - j = k} f(i) \\times g(j)\\\\ &amp;= \\sum _ {i + j = m + k} f(i) \\times g'(j) \\end{aligned} $$计算式 $(3.2.5)$ 时可以先对 $f(x)$ 和 $g(x)$ 求和卷积，称得到的多项式为 $F(x)$。 假设 $f(x)$ 的次数为 $n$，$g(x)$ 的次数为 $m$，那么 $F(x)$ 有 $n + m + 1$ 项。可以发现，现在 $F(x)$ 的第 $k$ 个位置实际上为答案的第 $m + k$ 项，所以要将多项式向左平移 $m$ 位，即 $F'(k) = F(k + m)$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 3e6, mod = 998244353; int n, m, c, len, ln, inv, tmp, a[N], p[N], R[N], F[N], G[N]; int Pow (int a, int k) &#123; int res = 1; for ( ; k; a = 1ll * a * a % mod, k &gt;&gt;= 1) if(k &amp; 1) res = 1ll * res * a % mod; return res; &#125; void NTT (int *F, bool type) &#123; rep(i, 0, len - 1) if (i &lt; R[i]) swap(F[i], F[R[i]]); for (int k = 1; k &lt; len; k &lt;&lt;= 1) &#123; int E = Pow(type ? 3 : 332748118, (mod - 1) / (k &lt;&lt; 1)); for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i, G = 1; j &lt; i + k; j++, G = 1ll * G * E % mod) &#123; int tmp1 = F[j], tmp2 = 1ll * G * F[j + k] % mod; F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2; F[j + k] = tmp1 - tmp2 &lt; 0 ? tmp1 - tmp2 + mod : tmp1 - tmp2; &#125; &#125; &#125; int main () &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;c, &amp;m), n--, m--; rep(i, 0, n) scanf(&quot;%d&quot;, &amp;a[i]); inv = Pow(c, mod - 2); for (len = 1, ln = 0; len &lt;= n + m; len &lt;&lt;= 1, ln++); rep(i, 0, len - 1) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); F[0] = F[1] = tmp = 1; rep(i, 2, n + m) tmp = 1ll * tmp * c % mod, F[i] = 1ll * F[i - 1] * tmp % mod; p[0] = p[1] = tmp = 1; rep(i, 2, max(n, m)) tmp = 1ll * tmp * inv % mod, p[i] = 1ll * p[i - 1] * tmp % mod; rep(i, 0, n) G[i] = 1ll * a[i] * p[i] % mod; reverse(G, G + n + 1); NTT(F, true), NTT(G, true); rep(i, 0, len - 1) F[i] = 1ll * F[i] * G[i] % mod; NTT(F, false); int Inv = Pow(len, mod - 2); rep(i, 0, len - 1) F[i] = 1ll * F[i] * Inv % mod; rep(i, 0, m) printf(&quot;%d &quot;, 1ll * F[n + i] * p[i] % mod); return 0; &#125; 分治多项式乘法 有些时候我们知道 $G(x)$ 的所有项，需要计算 $F(x)$，并且它们满足关系 ： $$F_k = \\sum _{i = 0} ^ {k - 1} F_iG_{k - i} \\tag{3.3.1} $$这时候可以考虑采用 $\\rm CDQ$ 分治的思想，先递归计算左边半部分，再计算左边对右边的贡献。可以发现贡献是卷积的形式，于是可以用 $\\rm FFT/NTT$ 以 $\\Theta(n \\log n)$ 的时间复杂度计算。 分治多项式乘法的时间复杂度为 $T(n) = 2T(\\frac{n}{2}) + \\Theta(n \\log n) = \\Theta(n \\log^2 n)$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 3e5, mod = 998244353; int n, F[N], G[N], rev[N], Ft[N], Gt[N]; int Pow (int a, int k) &#123; int res = 1; for (; k; a = 1ll * a * a % mod, k &gt;&gt;= 1) if (k &amp; 1) res = 1ll * res * a % mod; return res; &#125; void NTT (int len, int *F, bool type) &#123; rep(i, 0, len - 1) if (i &lt; rev[i]) swap(F[i], F[rev[i]]); for (int k = 1; k &lt; len; k &lt;&lt;= 1) &#123; int eps = Pow(type ? 3 : 332748118, (mod - 1) / (k &lt;&lt; 1)); for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i, g = 1; j &lt; i + k; j++, g = 1ll * g * eps % mod) &#123; int tmp1 = F[j], tmp2 = 1ll * g * F[j + k] % mod; F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2; F[j + k] = tmp1 - tmp2 &lt; 0 ? tmp1 - tmp2 + mod : tmp1 - tmp2; &#125; &#125; &#125; void cdq (int l, int r) &#123; if (r - l + 1 &lt;= 30) &#123; rep(i, l + 1, r) rep(j, l, i - 1) F[i] = (F[i] + 1ll * F[j] * G[i - j]) % mod; return; &#125; int mid = l + r &gt;&gt; 1; cdq(l, mid); int len = 1, ln = 0; for (; len &lt;= r + mid - 2 * l; len &lt;&lt;= 1, ln++); rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); rep(i, 0, mid - l) Ft[i] = F[i + l]; rep(i, mid - l + 1, len - 1) Ft[i] = 0; rep(i, 0, r - l) Gt[i] = G[i]; NTT(len, Ft, true), NTT(len, Gt, true); rep(i, 0, len - 1) Ft[i] = 1ll * Ft[i] * Gt[i] % mod; NTT(len, Ft, false); int Inv = Pow(len, mod - 2); rep(i, mid - l + 1, r - l) F[i + l] = (F[i + l] + 1ll * Ft[i] * Inv) % mod; cdq(mid + 1, r); &#125; int main () &#123; scanf(&quot;%d&quot;, &amp;n), n--; rep(i, 1, n) scanf(&quot;%d&quot;, &amp;G[i]); F[0] = 1, cdq(0, n); rep(i, 0, n) printf(&quot;%d &quot;, F[i]); return 0; &#125; 快速沃尔什变换 快速沃尔什变换 $\\rm (Fast~Walsh–Hadamard~Transform,FWT)$ 被用来在 $\\Theta(n\\log n)$ 的时间复杂度下求两个多项式的位运算卷积。 若称 $h(x) = f(x) \\oplus g(x)$，其中 $\\oplus$ 是 $\\rm or,and$ 或 $\\rm xor$，则应满足关系式 ： $$h(k) = \\sum _{i \\oplus j = k} f(i) \\times g(j) \\tag{4.0.1} $$构造 $\\rm FWT$ 函数 在 $\\rm FFT$ 中，我们通过将多项式转换成点值表示并进行点积的方法避开了卷积，于是我们自然也希望将位运算卷积通过某种方式转换成点积运算。 设 $F' = FWT(F)$ 表示幂级数 $F$ 经过 $\\rm FWT$ 变换后得到的幂级数。 容易发现，我们构造的 $\\rm FWT$ 变换需要满足 ： $$A \\times B = C \\iff FWT(A) \\cdot FWT(B) = FWT(C) \\tag{4.1.1} $$由于 $\\rm DFT$ 是线性变换，我们自然希望 $\\rm FWT$ 也是线性变换。 因此，考虑设 $k_{i, j}$ 表示 $F_j$ 对 $F'_i$ 的贡献系数，故有 ： $$F'_i = \\sum _{j = 0} ^ {n - 1} k_{i, j} F_j \\tag{4.1.2} $$根据 $FWT(A) \\cdot FWT(B) = FWT(C)$ 可以得到 ： $$A'_i \\times B'_i = C'_i \\tag{4.1.3} $$$$\\left(\\sum _{j = 0} ^ {n - 1} k_{i, j} A_j\\right)\\left(\\sum _{p = 0} ^ {n - 1} k_{i, p} B_p\\right) = \\sum_{j = 0} ^ {n - 1} k_{i, j} C_j \\tag{4.1.4} $$$$\\sum _{j = 0} ^ {n - 1}\\sum _{p = 0} ^ {n - 1} k_{i, j} k_{i, p} A_j B_p = \\sum_{j = 0} ^ {n - 1} k_{i, j} C_j \\tag{4.1.5} $$根据 $A \\times B = C$ 可以得到 ： $$C_p = \\sum _{i \\oplus j = p} A_i\\times B_j \\tag{4.1.6} $$$$\\sum_{p = 0} ^ {n - 1} k_{i, p} C_p = \\sum_{p = 0} ^ {n - 1} k_{i, p}\\sum _{t \\oplus j = p} A_t B_j \\tag{4.1.7} $$$$\\begin{aligned} \\sum _{j = 0} ^ {n - 1}\\sum _{p = 0} ^ {n - 1} k_{i, j} k_{i, p} A_j B_p &amp;= \\sum_{p = 0} ^ {n - 1} k_{i, p}\\sum _{t \\oplus j = p} A_t B_j \\\\ &amp;= \\sum _{p = 0} ^{n - 1} \\sum _{t \\oplus j = p} k_{i, t \\oplus j} A_t B_j\\\\ &amp;= \\sum _{t = 0} ^ {n - 1} \\sum_{j = 0} ^ {n - 1} k_{i, t \\oplus j} A_t B_j \\end{aligned} $$对比式 $(4.1.8)$ 中两边系数可以发现只需要满足 ： $$k_{i, j}k_{i, p} = k_{i, j \\oplus p} \\tag{4.1.9} $$假设我们已经求出了 $k_{0, 0},k_{0,1},k_{1,0},k_{1,1}$，那么可以构造 $k_{i, j} = \\prod_t k_{i_t,j_t}$，其中 $a_t$ 表示 $a$ 在二进制下的第 $t$ 位。这种构造方式导出的变换系数 $k$ 推导 $k_{i, j}k_{i, p} = k_{i, j \\oplus p}$ 的充分性容易证明。 求解 $\\rm FWT$ 变换 现在我们需要快速求解下式 ： $$F'_i = \\sum _{j = 0} ^{n - 1} k_{i, j} F_j \\tag{4.2.1} $$我们考虑按位折半计算，下面设 $\\hat{x}$ 表示 $x$ 去除二进制首位以后的值。 $$\\begin{aligned} F'_i &amp;= \\sum _{j = 0} ^{n / 2 - 1} k_{i, j} F_j + \\sum _{j = n / 2} ^{n - 1} k_{i, j} F_j \\\\ &amp;= \\sum _{j = 0} ^{n / 2 - 1} k_{i_0, j_0}k_{\\hat{i}, \\hat{j}} F_j + \\sum _{j = n / 2} ^{n - 1} k_{i_0, j_0}k_{\\hat{i}, \\hat{j}} F_j \\\\ &amp;= k_{i_0, 0}\\sum _{j = 0} ^{n / 2 - 1} k_{\\hat{i}, \\hat{j}} F_j + k_{i_0, 1}\\sum _{j = n / 2} ^{n - 1} k_{\\hat{i}, \\hat{j}} F_j \\end{aligned} $$设 $F^0$ 表示幂级数 $F'$ 下标的二进制首位为 $0$ 的部分，相似地定义 $F^1$。 若 $i_0 = 0$，则有 $F'_i = k_{0, 0} F^0_i + k_{0, 1} F^1_i$。 若 $i_0 = 1$，则有 $F'_{i + n/2} = k_{1, 0} F^0_i + k_{1, 1} F^1_i$。 在该算法中，每次迭代会将长度减半，合并一层的时间复杂度为 $\\Theta(n)$，所以总时间复杂度为 $\\Theta(n\\log n)$。 此外，逆变换 $\\rm (IFWT)$ 时对变换矩阵 $k$ 求个逆即可。 构造位矩阵 针对不同的位运算，我们需要构造不同的位矩阵 $k$ 以拟合 $\\rm FWT$ 变换。 或卷积 首先我们知道 ： $$k_{p, i}\\times k_{p, j} = k_{p, i | j} \\tag{4.3.1} $$首先可以观察到 $k_{p, i} \\times k_{p, i} = k_{p, i}$，故 $k_{p, i} \\in \\{0, 1\\}$。 然后可以发现 $k_{p, 0} \\times k_{p, 1} = k_{p, 1}$，所以 $k_{p, 0} = 1$。 又因为矩阵如果一列都是 $1$，那么它没有逆，故 $k$ 仅可能为以下两种之一 ： $$\\begin{bmatrix} 1&amp;0\\\\1&amp;1 \\end{bmatrix}~or~\\begin{bmatrix} 1&amp;1\\\\1&amp;0 \\end{bmatrix} \\tag{4.3.2} $$由于右边那种等价于高维前缀和，所以我选择右边那种（事实上两种都可以）。 $$\\begin{aligned} F'_i &amp;= F^0_i\\\\ F'_{i + n/2} &amp;= F^0_i + F^1_i \\end{aligned} $$对于逆变换，将矩阵求个逆就可以得到 $k^{-1} = \\begin{bmatrix} 1&amp;0\\\\-1&amp;1 \\end{bmatrix}$。 $$\\begin{aligned} IF_i &amp;= IF^{0}_i\\\\ IF_{i + n/2} &amp;= -IF^0_i + IF^1_i \\end{aligned} $$与卷积 可以发现与卷积同或卷积几乎完全一样，此处不赘述，仅给出其位矩阵和逆位矩阵 ： $$k = \\begin{bmatrix} 1&amp;1\\\\0&amp;1 \\end{bmatrix},k^{-1} = \\begin{bmatrix} 1&amp;-1\\\\0&amp;1 \\end{bmatrix} \\tag{4.3.5} $$异或卷积 首先我们知道 ： $$k_{p, i}\\times k_{p, j} = k_{p, i~xor~j} \\tag{4.3.6} $$因为 $k_{0, 0} \\times k_{x, y} = k_{x, y}$，所以 $k_{0, 0} = 1$。 因为 $k_{1, 1} \\times k_{1, 1} = k_{1, 0}$，此时若 $k_{1, 1} = k_{1, 0} = 0$，则有一行为 $0$，矩阵无逆，故 $k_{1, 1},k_{1, 0} \\not= 0$。 因为 $k_{1, 0} \\times k_{1, 1} = k_{1, 1}$，又因为 $k_{1, 1} \\not = 0$，所以 $k_{1, 0} = 1$。 因为 $k_{1, 1} \\times k_{1, 1} = k_{1, 0} = 1$，所以 $k_{1, 1} \\in \\{1, -1\\}$。 因为 $k_{0,1} \\times k_{0, 1} = k_{0, 0} = 1$，所以 $k_{0, 1} \\in \\{1, -1\\}$。 因为 $k_{0, 1}$ 和 $k_{1, 1}$ 不能相等，否则行列式为 $0$，矩阵无逆，所以 $k$ 仅可能为以下两种之一 ： $$\\begin{bmatrix} 1&amp;1\\\\-1&amp;1 \\end{bmatrix}~or~\\begin{bmatrix} 1&amp;1\\\\1&amp;-1 \\end{bmatrix} \\tag{4.3.7} $$我们采用第二种，可推知 ： $$\\begin{aligned} F'_i &amp;= F^0_i + F^1_i\\\\ F'_{i + n/2} &amp;= F^0_i - F^1_i \\end{aligned} $$对 $k$ 求逆可以得到 $k^{-1} = \\begin{bmatrix} \\frac{1}{2}&amp;\\frac{1}{2}\\\\\\frac{1}{2}&amp;-\\frac{1}{2} \\end{bmatrix}$。 $$\\begin{aligned} IF_i &amp;= \\frac{IF^0_i + IF^1_i}{2}\\\\ IF_{i + n/2} &amp;= \\frac{IF^0_i - IF^1_i}{2} \\end{aligned} $$#include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 2e5, mod = 998244353, Inv = 499122177; int n, len, a[N], b[N], F[N], G[N]; void OR (int *F, bool type) &#123; for (int k = 1; k &lt; len; k &lt;&lt;= 1) for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i; j &lt; i + k; j++) F[j + k] = (F[j + k] + (type ? F[j] : -F[j])) % mod; &#125; void AND (int *F, bool type) &#123; for (int k = 1; k &lt; len; k &lt;&lt;= 1) for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i; j &lt; i + k; j++) &#123; int tmp1 = F[j], tmp2 = F[j + k]; F[j] = ((type ? 0 : -tmp1) + tmp2) % mod; F[j + k] = (tmp1 + (type ? tmp2 : 0)) % mod; &#125; &#125; void XOR (int *F, bool type) &#123; for (int k = 1; k &lt; len; k &lt;&lt;= 1) for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i; j &lt; i + k; j++) &#123; int tmp1 = F[j], tmp2 = F[j + k]; F[j] = (type ? 2ll : 1ll) * Inv * (tmp1 + tmp2) % mod; F[j + k] = (type ? 2ll : 1ll) * Inv * (tmp1 - tmp2) % mod; &#125; &#125; int main () &#123; scanf(&quot;%d&quot;, &amp;n), len = 1 &lt;&lt; n; rep(i, 0, len - 1) scanf(&quot;%d&quot;, &amp;a[i]); rep(i, 0, len - 1) scanf(&quot;%d&quot;, &amp;b[i]); rep(i, 0, len - 1) F[i] = a[i], G[i] = b[i]; OR(F, true), OR(G, true); rep(i, 0, len - 1) F[i] = 1ll * F[i] * G[i] % mod; OR(F, false); rep(i, 0, len - 1) printf(&quot;%d &quot;, F[i] &lt; 0 ? F[i] + mod : F[i]); puts(&quot;&quot;); rep(i, 0, len - 1) F[i] = a[i], G[i] = b[i]; AND(F, true), AND(G, true); rep(i, 0, len - 1) F[i] = 1ll * F[i] * G[i] % mod; AND(F, false); rep(i, 0, len - 1) printf(&quot;%d &quot;, F[i] &lt; 0 ? F[i] + mod : F[i]); puts(&quot;&quot;); rep(i, 0, len - 1) F[i] = a[i], G[i] = b[i]; XOR(F, true), XOR(G, true); rep(i, 0, len - 1) F[i] = 1ll * F[i] * G[i] % mod; XOR(F, false); rep(i, 0, len - 1) printf(&quot;%d &quot;, F[i] &lt; 0 ? F[i] + mod : F[i]); puts(&quot;&quot;); return 0; &#125; 多项式基本操作 多项式之间除了乘法，还可以做一些其它的基本操作，但它们都是基于多项式乘法的。 多项式求逆 若两个多项式 $F(x)$ 和 $G(x)$ 满足 $F(x)G(x) = 1$，则称它们互为逆元，记作 $G(x) = F^{-1}(x)$。 求解多项式乘法逆元的时候考虑使用倍增的思想，不断扩大倍增上界。 当多项式的界为 $\\bmod~x$ 时，直接对多项式的常数项求逆元即可。 设 $G(x) = F^{-1}(x) \\pmod {x^n}$，如果我们已经求出了 $G'(x) = F^{-1}(x) \\pmod {x^{n/2}}$，那么 ： $$G(x) - G'(x) \\equiv 0 \\pmod {x^{n/2}} \\tag{5.1.1} $$为了能配出 $x ^ n$ 作为模数，考虑将式子两边同时平方，得到 ： $$G^2(x) - 2G(x)G'(x) + G'^2(x) \\equiv 0 \\pmod {x ^ n} \\tag{5.1.2} $$因为 $F(x)G(x) = 1$，所以式子两边同时乘 $F(x)$ 并整理可得 ： $$G(x) = 2G'(x) - G'^2(x)F(x) \\pmod {x ^ n} \\tag{5.1.3} $$根据式 $(5.1.3)$ 可以倍增求出 $F^{-1}(x)$，时间复杂度为 $T(n) = T(\\frac{n}{2}) + \\Theta(n \\log n) = \\Theta(n\\log n)$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 3e5, mod = 998244353; int n, len, ln, F[N], R[N], G[N], g[N]; int Pow (int a, int k) &#123; int res = 1; for ( ; k; a = 1ll * a * a % mod, k &gt;&gt;= 1) if(k &amp; 1) res = 1ll * res * a % mod; return res; &#125; void NTT (int *F, bool type) &#123; rep(i, 0, len - 1) if (i &lt; R[i]) swap(F[i], F[R[i]]); for (int k = 1; k &lt; len; k &lt;&lt;= 1) &#123; int eps = Pow(type ? 3 : 332748118, (mod - 1) / (k &lt;&lt; 1)); for (int i = 0; i &lt; len; i += k &lt;&lt; 1) for (int j = i, g = 1; j &lt; i + k; j++, g = 1ll * g * eps % mod) &#123; int tmp1 = F[j], tmp2 = 1ll * g * F[j + k] % mod; F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2; F[j + k] = tmp1 - tmp2 &lt; 0 ? tmp1 - tmp2 + mod : tmp1 - tmp2; &#125; &#125; &#125; void INV (int n, int *F) &#123; G[0] = Pow(F[0], mod - 2); for (len = 4, ln = 2; len &lt;= (n &lt;&lt; 2); len &lt;&lt;= 1, ln++) &#123; rep(i, len &gt;&gt; 1, len - 1) G[i] = g[i] = 0; rep(i, 0, (len &gt;&gt; 1) - 1) g[i] = F[i]; rep(i, 0, len - 1) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(G, true), NTT(g, true); rep(i, 0, len - 1) G[i] = 1ll * G[i] * (2 - 1ll * G[i] * g[i] % mod + mod) % mod; NTT(G, false); int Inv = Pow(len, mod - 2); rep(i, 0, (len &gt;&gt; 1) - 1) G[i] = 1ll * G[i] * Inv % mod; rep(i, len &gt;&gt; 1, len - 1) G[i] = 0; &#125; rep(i, 0, n) F[i] = G[i]; &#125; int main () &#123; scanf(&quot;%d&quot;, &amp;n), n--; rep(i, 0, n) scanf(&quot;%d&quot;, &amp;F[i]); INV(n, F); rep(i, 0, n) printf(&quot;%d &quot;, (F[i] + mod) % mod); return 0; &#125; 多项式开方 若两个多项式 $F(x)$ 和 $G(x)$ 满足 $G^2(x) = F(x)$，则称 $F(x)$ 开根后为 $G(x)$，记作 $G(x) = F^{\\frac{1}{2}}(x)$。 与多项式求逆一样，多项式开根也利用了倍增法。 当多项式的界为 $\\bmod~x$ 时，直接对常数项使用二次剩余即可。 设 $G(x) = F^{\\frac{1}{2}}(x) \\pmod {x ^ n}$，如果我们已经求出了 $G'(x) = F^{\\frac{1}{2}}(x) \\pmod {x ^ {n / 2}}$，那么 ： $$G'^2 (x) - F(x) \\equiv 0 \\pmod {x ^ {n / 2}} \\tag{5.2.1} $$对式 $(5.2.1)$ 两边同时平方并作简单变换，得到 ： $$\\left[G'^2(x) + F(x)\\right] ^ 2 \\equiv 4G'^2(x)F(x) \\pmod {x ^ n} \\tag{5.2.2} $$对式子两边同时除以 $4G'^2(x)$，可以得到 ： $$\\left[\\frac{G'^2(x) + F(x)}{2G'(x)}\\right] ^ 2 \\equiv F(x) \\pmod {x ^ n} \\tag{5.2.3} $$结合 $G(x)$ 的定义，可以发现 ： $$G(x) = \\frac{1}{2}G'(x) + \\frac{1}{2}G'^{-1}(x)F(x) \\pmod {x ^ n} \\tag{5.2.4} $$根据式 $(5.2.4)$ 可以倍增求出 $F^{\\frac{1}{2}}(x)$，时间复杂度为 $T(n) = T(\\frac{n}{2}) + \\Theta(n \\log n) = \\Theta(n\\log n)$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 3e5, mod = 998244353; int n, F[N], rev[N], GI[N], FI[N], iG[N], GS[N], FS[N]; int Pow (int a, int k) &#123; int res = 1; for ( ; k; a = 1ll * a * a % mod, k &gt;&gt;= 1) if(k &amp; 1) res = 1ll * res * a % mod; return res; &#125; void NTT (int len, int *F, bool type) &#123; rep(i, 0, len - 1) if (i &lt; rev[i]) swap(F[i], F[rev[i]]); for (int k = 1; k &lt; len; k &lt;&lt;= 1) &#123; int eps = Pow(type ? 3 : 332748118, (mod - 1) / (k &lt;&lt; 1)); for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i, g = 1; j &lt; i + k; j++, g = 1ll * g * eps % mod) &#123; int tmp1 = F[j], tmp2 = 1ll * g * F[j + k] % mod; F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2; F[j + k] = tmp1 - tmp2 &lt; 0 ? tmp1 - tmp2 + mod : tmp1 - tmp2; &#125; &#125; &#125; void INV (int n, int *F) &#123; rep(i, 0, n &lt;&lt; 2) FI[i] = GI[i] = 0; GI[0] = Pow(F[0], mod - 2); for (int len = 4, ln = 2; len &lt;= n &lt;&lt; 2; len &lt;&lt;= 1, ln++) &#123; rep(i, 0, (len &gt;&gt; 1) - 1) FI[i] = F[i]; rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(len, GI, true), NTT(len, FI, true); rep(i, 0, len - 1) GI[i] = 1ll * GI[i] * (2 - 1ll * GI[i] * FI[i] % mod + mod) % mod; NTT(len, GI, false); int Inv = Pow(len, mod - 2); rep(i, 0, (len &gt;&gt; 1) - 1) GI[i] = 1ll * GI[i] * Inv % mod; rep(i, len &gt;&gt; 1, len - 1) GI[i] = 0; &#125; rep(i, 0, n) iG[i] = GI[i]; &#125; void SQR (int n, int *F) &#123; rep(i, 0, n &lt;&lt; 2) FS[i] = GS[i] = 0; GS[0] = sqrt(F[0]); for (int len = 4, ln = 2; len &lt;= n &lt;&lt; 2; len &lt;&lt;= 1, ln++) &#123; rep(i, 0, (len &gt;&gt; 1) - 1) FS[i] = F[i]; rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); INV((len &gt;&gt; 1) - 1, GS); NTT(len, GS, true), NTT(len, FS, true), NTT(len, iG, true); rep(i, 0, len - 1) GS[i] = 499122177ll * (GS[i] + 1ll * FS[i] * iG[i] % mod) % mod; NTT(len, GS, false); int Inv = Pow(len, mod - 2); rep(i, 0, (len &gt;&gt; 1) - 1) GS[i] = 1ll * GS[i] * Inv % mod; rep(i, len &gt;&gt; 1, len - 1) GS[i] = 0; &#125; rep(i, 0, n) F[i] = GS[i]; &#125; int main () &#123; scanf(&quot;%d&quot;, &amp;n), n--; rep(i, 0, n) scanf(&quot;%d&quot;, &amp;F[i]); SQR(n, F); rep(i, 0, n) printf(&quot;%d &quot;, F[i]); return 0; &#125; 多项式带余除法 给定多项式 $F(x)$ 和 $G(x)$，若满足关系式 $Q(x)G(x) + R(x) = F(x)$，则称 $Q(x)$ 和 $R(x)$ 分别是 $F(x)$ 除以 $G(x)$ 的商和余数。 可以发现如果能消除 $R(x)$ 的影响则可以直接使用多项式求逆。 考虑构造变换 ： $$F' = x ^ {\\deg F} F\\left(\\frac{1}{x}\\right) \\tag{5.3.1} $$可以发现，其本质就是翻转多项式系数。 设 $n = \\deg F,m = \\deg G$，将多项式带余除法定义式中的 $x$ 替换成 $\\frac{1}{x}$，并将两边同时乘 $x ^ n$ 可得 ： $$x ^ n F\\left(\\frac{1}{x}\\right) = x ^ {n - m} Q\\left(\\frac{1}{x}\\right) x ^ m G\\left(\\frac{1}{x}\\right) + x ^ {n - m + 1} x ^ {m - 1} R\\left(\\frac{1}{x}\\right) \\tag{5.3.2} $$将式 $(5.3.1)$ 带入可得 ： $$F'(x) = Q'(x) G'(x) + x ^ {n - m + 1} R'(x) \\tag{5.3.3} $$注意到式 $(5.3.3)$ 中 $R'(x)$ 带了一个 $x ^ {n - m + 1}$ 作为系数，于是将上式放在 $\\bmod~x ^ {n - m + 1}$ 意义下计算即可将这一项消去。又因为 $\\deg Q' = n - m &lt; n - m + 1$，故 $Q'(x)$ 的计算不会受到影响。 综上，有 ： $$F'(x) = Q'(x)G'(x) \\pmod {x ^ {n - m + 1}} \\tag{5.3.4} $$使用多项式求逆即可计算 $Q(x)$，将其带入定义式可以得到 $R(x)$。 时间复杂度 $\\Theta(n \\log n)$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 3e5, mod = 998244353; int n, m, len, ln, F[N], G[N], rev[N], FR[N], GR[N], Q[N], R[N], FI[N], GI[N]; int Pow (int a, int k) &#123; int res = 1; for ( ; k; a = 1ll * a * a % mod, k &gt;&gt;= 1) if(k &amp; 1) res = 1ll * res * a % mod; return res; &#125; void NTT (int len, int *F, bool type) &#123; rep(i, 0, len - 1) if (i &lt; rev[i]) swap(F[i], F[rev[i]]); for (int k = 1; k &lt; len; k &lt;&lt;= 1) &#123; int eps = Pow(type ? 3 : 332748118, (mod - 1) / (k &lt;&lt; 1)); for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i, g = 1; j &lt; i + k; j++, g = 1ll * g * eps % mod) &#123; int tmp1 = F[j], tmp2 = 1ll * g * F[j + k] % mod; F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2; F[j + k] = tmp1 - tmp2 &lt; 0 ? tmp1 - tmp2 + mod : tmp1 - tmp2; &#125; &#125; &#125; void INV (int n, int *F) &#123; rep(i, 0, n &lt;&lt; 2) FI[i] = GI[i] = 0; GI[0] = Pow(F[0], mod - 2); for (int len = 4, ln = 2; len &lt;= n &lt;&lt; 2; len &lt;&lt;= 1, ln++) &#123; rep(i, 0, (len &gt;&gt; 1) - 1) FI[i] = F[i]; rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(len, GI, true), NTT(len, FI, true); rep(i, 0, len - 1) GI[i] = 1ll * GI[i] * (2 - 1ll * GI[i] * FI[i] % mod + mod) % mod; NTT(len, GI, false); int Inv = Pow(len, mod - 2); rep(i, 0, (len &gt;&gt; 1) - 1) GI[i] = 1ll * GI[i] * Inv % mod; rep(i, len &gt;&gt; 1, len - 1) GI[i] = 0; &#125; rep(i, 0, n) F[i] = GI[i]; &#125; void DIV (int n, int m, int *F, int *G) &#123; rep(i, 0, n) FR[i] = F[n - i]; rep(i, 0, m) GR[i] = G[m - i]; rep(i, n - m + 1, m) GR[i] = 0; INV(n - m, GR); for (len = 1, ln = 0; len &lt;= 2 * n - m; len &lt;&lt;= 1, ln++); rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(len, FR, true), NTT(len, GR, true); rep(i, 0, len - 1) FR[i] = 1ll * FR[i] * GR[i] % mod; NTT(len, FR, false); int Inv = Pow(len, mod - 2); rep(i, 0, n - m) Q[i] = 1ll * FR[n - m - i] * Inv % mod; rep(i, 0, n - m) printf(&quot;%d &quot;, Q[i]); puts(&quot;&quot;); for (len = 1, ln = 0; len &lt;= n; len &lt;&lt;= 1, ln++); rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(len, G, true), NTT(len, Q, true); rep(i, 0, len - 1) G[i] = 1ll * G[i] * Q[i] % mod; NTT(len, G, false); Inv = Pow(len, mod - 2); rep(i, 0, m - 1) R[i] = (F[i] - 1ll * G[i] * Inv % mod + mod) % mod; rep(i, 0, m - 1) printf(&quot;%d &quot;, R[i]); &#125; int main () &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); rep(i, 0, n) scanf(&quot;%d&quot;, &amp;F[i]); rep(i, 0, m) scanf(&quot;%d&quot;, &amp;G[i]); DIV(n, m, F, G); return 0; &#125; 多项式指对函数 两者均由麦克劳林级数定义 ： $$\\begin{aligned} \\ln F(x) &amp;= -\\sum_{i \\geqslant 1} \\frac{[1 - F(x)] ^ i}{i}\\\\ \\exp F(x) &amp;= \\sum _{i \\geqslant 0} \\frac{F^i(x)}{i!} \\end{aligned} $$之所以用麦克劳林级数这么复杂的方式，是因为这样就可以只用加法和乘法定义多项式指对函数了。 众所周知有多项式的求导 ： $$F'(x) = \\sum _{i \\geqslant 1} iF_i\\cdot x ^ {i - 1} \\tag{5.4.2} $$还有多项式的积分 ： $$F(x) = C + \\sum _{i \\geqslant 0} \\frac{F'_i}{i} \\cdot x ^ {i + 1} \\tag{5.4.3} $$多项式对数函数 首先，对于多项式 $F(x)$，若 $\\ln F(x)$ 存在，则按照其定义，必须满足 ： $$[x ^ 0]F(x) = 1 \\tag{5.4.4} $$先对 $\\ln F(x)$ 求导 ： $$\\frac{\\mathrm{d}\\ln F(x)}{\\mathrm{d} x} \\equiv \\frac{F'(x)}{F(x)} \\pmod {x ^ n} \\tag{5.4.5} $$再对其积分 ： $$\\ln F(x) \\equiv \\int \\mathrm{d}\\ln F(x) \\equiv \\int \\frac{F'(x)}{F(x)}\\mathrm{d} x \\pmod {x ^ n} \\tag{5.4.6} $$多项式的求导和积分时间复杂度均为 $\\Theta(n)$，多项式求逆和乘法的时间复杂度为 $\\Theta(n \\log n)$，所以求解多项式对数函数的时间复杂度为 $\\Theta(n \\log n)$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 4e5 + 10, mod = 998244353; int n, m, f[N], F[N], rev[N], FI[N], GI[N], iF[N], lnF[N]; int Pow (int a, int k) &#123; int res = 1; for (; k; a = 1ll * a * a % mod, k &gt;&gt;= 1) if (k &amp; 1) res = 1ll * res * a % mod; return res; &#125; void NTT (int len, int *F, bool type) &#123; rep(i, 0, len - 1) if (i &lt; rev[i]) swap(F[i], F[rev[i]]); for (int k = 1; k &lt; len; k &lt;&lt;= 1) &#123; int eps = Pow(type ? 3 : 332748118, (mod - 1) / (k &lt;&lt; 1)); for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i, g = 1; j &lt; i + k; j++, g = 1ll * g * eps % mod) &#123; int tmp1 = F[j], tmp2 = 1ll * g * F[j + k] % mod; F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2; F[j + k] = tmp1 - tmp2 &lt; 0 ? tmp1 - tmp2 + mod : tmp1 - tmp2; &#125; &#125; &#125; void INV (int n, int *F, int *iF) &#123; rep(i, 0, n &lt;&lt; 2) GI[i] = FI[i] = 0; GI[0] = Pow(F[0], mod - 2); for (int len = 4, ln = 2; len &lt;= n &lt;&lt; 2; len &lt;&lt;= 1, ln++) &#123; rep(i, 0, (len &gt;&gt; 1) - 1) FI[i] = F[i]; rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(len, GI, true), NTT(len, FI, true); rep(i, 0, len - 1) GI[i] = 1ll * GI[i] * (2 - 1ll * GI[i] * FI[i] % mod + mod) % mod; NTT(len, GI, false); int Inv = Pow(len, mod - 2); rep(i, 0, (len &gt;&gt; 1) - 1) GI[i] = 1ll * GI[i] * Inv % mod; rep(i, len &gt;&gt; 1, len - 1) GI[i] = 0; &#125; rep(i, 0, n) iF[i] = GI[i]; rep(i, n + 1, n &lt;&lt; 2) iF[i] = 0; &#125; void LN (int n, int *F, int *lnF) &#123; rep(i, 0, n - 1) lnF[i] = 1ll * (i + 1) * F[i + 1] % mod; rep(i, n, n &lt;&lt; 2) lnF[i] = 0; INV(n, F, iF); int len = 1, ln = 0; while (len &lt; n &lt;&lt; 1) len &lt;&lt;= 1, ln++; rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(len, lnF, true), NTT(len, iF, true); rep(i, 0, len - 1) lnF[i] = 1ll * lnF[i] * iF[i] % mod; NTT(len, lnF, false); int Inv = Pow(len, mod - 2); rep(i, 0, n - 1) lnF[i] = 1ll * lnF[i] * Inv % mod; rep(i, n, n &lt;&lt; 2) lnF[i] = 0; dep(i, n, 1) lnF[i] = 1ll * Pow(i, mod - 2) * lnF[i - 1] % mod; lnF[0] = 0; &#125; int main () &#123; cin &gt;&gt; n, n--; rep(i, 0, n) cin &gt;&gt; F[i]; LN(n, F, lnF); rep(i, 0, n) cout &lt;&lt; lnF[i] &lt;&lt; &quot; &quot;; return 0; &#125; 多项式指数函数 首先，对于多项式 $F(x)$，若 $\\exp F(x)$ 存在，则按照其定义，必须满足 ： $$[x ^ 0] F(x) = 1 \\tag{5.4.7} $$否则 $\\exp F(x)$ 的常数项不收敛。 对 $\\exp F(x)$ 求导可得 ： $$\\frac{\\mathrm{d} \\exp F(x)}{\\mathrm{d}x} \\equiv F'(x) \\exp F(x) \\pmod {x ^ n} \\tag{5.4.8} $$若记 $\\exp F(x)$ 为 $G(x)$，则可以得到 ： $$G'(x) \\equiv F'(x)G(x) \\pmod {x ^ n} \\tag{5.4.9} $$用系数关系表示为 ： $$G'_n = \\sum _{i = 0} ^ n F'_i G_{n - i} \\tag{5.4.10} $$将导函数积回来，可以得到 ： $$G_{n + 1} = \\frac{1}{n + 1}\\sum _{i = 0} ^ n (i + 1)F_{i + 1}G_{n - i} \\tag{5.4.11} $$上式的递推可以用分治多项式乘法优化至 $\\Theta(n \\log ^ 2 n)$。 多项式牛顿迭代 定义多项式的复合 ： $$F \\circ G (x) = \\sum _{i\\geqslant 0} F_i G^i(x) \\tag{5.5.1} $$已知函数 $G(x)$，求多项式 $F(x) \\pmod {x ^ n}$，满足 $G \\circ F(x) = 0$。 首先当多项式的界为 $\\bmod~x$ 时，可以手算出 $F(x) \\pmod x$。 假设现在已经求得 $\\bmod~x ^ {n / 2}$ 意义下的解 $F_0(x)$，要进一步求出 $\\bmod~x ^ n$ 意义下的解 $F(x)$。 众所周知有泰勒公式 ： $$f(x) = \\sum _{i = 0} ^ {\\infty} \\frac{f^{(i)}(x_0)}{i!}(x - x_0) ^ i \\tag{5.5.2} $$将 $G[F(x)]$ 在 $F_0(x)$ 处进行泰勒展开，有 ： $$\\sum _{i = 0} ^ {\\infty} \\frac{G^{(i)}[F_0(x)]}{i!}[F(x) - F_0(x)] ^ i \\equiv 0 \\pmod {x ^ n} \\tag{5.5.3} $$由于当 $i$ 取大于 $1$ 的值时 $[F(x) - F_0(x)] ^ i$ 的最低次项都会超过 $x ^ n$，所以 ： $$G[F_0(x)] + G'[F_0(x)][F(x) - F_0(x)] \\equiv 0 \\pmod {x ^ n} \\tag{5.5.4} $$化简得到牛顿迭代的经典公式 ： $$F(x) = F_0(x) - \\frac{G[F_0(x)]}{G'[F_0(x)]} \\pmod {x ^ n} \\tag{5.5.5} $$使用多项式牛顿迭代也可以解决一些其它的多项式基本操作。 多项式求逆 设需要求逆的函数为 $H(x)$，$F(x) = H^{-1}(x)$，有方程 ： $$G \\circ F(x) \\equiv \\frac{1}{F(x)} - H(x) \\equiv 0 \\pmod {x ^ n} \\tag{5.5.6} $$运用式 $(5.5.5)$ 可得 ： $$F(x) \\equiv F_0(x) - \\frac{\\frac{1}{F_0(x)} - H(x)}{-\\frac{1}{F_0^{2}(x)}} \\equiv 2F_0(x) - F_0^2(x)H(x) \\pmod {x ^ n} \\tag{5.5.7} $$时间复杂度 $T(n) = T\\left(\\frac{n}{2}\\right) + \\Theta(n \\log n) = \\Theta(n \\log n)$。 多项式开方 设需要开方的函数为 $H(x)$，$F(x) = H^{\\frac{1}{2}}(x)$，有方程 ： $$G \\circ F(x) \\equiv F^2(x) - H(x) \\equiv 0 \\pmod {x ^ n} \\tag{5.5.8} $$运用式 $(5.5.5)$ 可得 ： $$F(x) \\equiv F_0(x) - \\frac{F_0^2(x) - H(x)}{2F_0(x)} \\equiv 2F_0^{-1}(x)[F_0^2(x) + H(x)] \\pmod {x ^ n} \\tag{5.5.9} $$时间复杂度 $T(n) = T\\left(\\frac{n}{2}\\right) + \\Theta(n \\log n) = \\Theta(n \\log n)$。 多项式指数函数 设需要求 $\\exp$ 的函数为 $H(x)$，$F(x) = \\exp H(x)$，有方程 ： $$G \\circ F(x) \\equiv \\ln F(x) - H(x) \\equiv 0 \\pmod {x ^ n} \\tag{5.5.10} $$运用式 $(5.5.5)$ 可得 ： $$F(x) \\equiv F_0(x) - \\frac{\\ln F_0(x) - H(x)}{\\frac{1}{F_0(x)}} \\equiv F_0(x)[1 - \\ln F_0(x) + H(x)] \\pmod {x ^ n} \\tag{5.5.11} $$时间复杂度 $T(n) = T\\left(\\frac{n}{2}\\right) + \\Theta(n \\log n) = \\Theta(n \\log n)$。 #include &lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 3e5, mod = 998244353; int n, k, F[N], rev[N], FI[N], GI[N], iF[N], FE[N], GE[N], lnF[N]; int Pow (int a, int k) &#123; int res = 1; for (; k; a = 1ll * a * a % mod, k &gt;&gt;= 1) if (k &amp; 1) res = 1ll * res * a % mod; return res; &#125; void NTT (int len, int *F, bool type) &#123; rep(i, 0, len - 1) if (i &lt; rev[i]) swap(F[i], F[rev[i]]); for (int k = 1; k &lt; len; k &lt;&lt;= 1) &#123; int eps = Pow(type ? 3 : 332748118, (mod - 1) / (k &lt;&lt; 1)); for (int i = 0; i &lt; len; i += (k &lt;&lt; 1)) for (int j = i, g = 1; j &lt; i + k; j++, g = 1ll * g * eps % mod) &#123; int tmp1 = F[j], tmp2 = 1ll * g * F[j + k] % mod; F[j] = tmp1 + tmp2 &gt;= mod ? tmp1 + tmp2 - mod : tmp1 + tmp2; F[j + k] = tmp1 - tmp2 &lt; 0 ? tmp1 - tmp2 + mod : tmp1 - tmp2; &#125; &#125; &#125; void INV (int n, int *F) &#123; rep(i, 0, n &lt;&lt; 2) FI[i] = GI[i] = 0; GI[0] = Pow(F[0], mod - 2); for (int len = 4, ln = 2; len &lt;= n &lt;&lt; 2; len &lt;&lt;= 1, ln++) &#123; rep(i, 0, (len &gt;&gt; 1) - 1) FI[i] = F[i]; rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(len, GI, true), NTT(len, FI, true); rep(i, 0, len - 1) GI[i] = 1ll * GI[i] * (2 - 1ll * GI[i] * FI[i] % mod + mod) % mod; NTT(len, GI, false); int Inv = Pow(len, mod - 2); rep(i, 0, (len &gt;&gt; 1) - 1) GI[i] = 1ll * GI[i] * Inv % mod; rep(i, len &gt;&gt; 1, len - 1) GI[i] = 0; &#125; rep(i, 0, n) iF[i] = GI[i]; &#125; void LN (int n, int *F) &#123; INV(n, F); rep(i, 0, n - 1) F[i] = 1ll * (i + 1) * F[i + 1] % mod; F[n] = 0; int len = 1, ln = 0; for (; len &lt; n &lt;&lt; 1; len &lt;&lt;= 1, ln++); rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(len, F, true), NTT(len, iF, true); rep(i, 0, len - 1) F[i] = 1ll * F[i] * iF[i] % mod; NTT(len, F, false); int Inv = Pow(len, mod - 2); rep(i, 0, n - 1) F[i] = 1ll * F[i] * Inv % mod; rep(i, n, len - 1) F[i] = 0; dep(i, n, 1) F[i] = 1ll * Pow(i, mod - 2) * F[i - 1] % mod; F[0] = 0; &#125; void EXP (int n, int *F) &#123; rep(i, 0, (n &lt;&lt; 2)) FE[i] = GE[i] = 0; GE[0] = exp(F[0]); for (int len = 2, ln = 1; len &lt;= n &lt;&lt; 2; len &lt;&lt;= 1, ln++) &#123; rep(i, 0, (len &gt;&gt; 1) - 1) FE[i] = F[i], lnF[i] = GE[i]; LN((len &gt;&gt; 1) - 1, lnF); rep(i, 0, len - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + (i &amp; 1) * (1 &lt;&lt; ln - 1); NTT(len, GE, true), NTT(len, FE, true), NTT(len, lnF, true); rep(i, 0, len - 1) GE[i] = 1ll * GE[i] * (1 - lnF[i] + FE[i] + mod) % mod; NTT(len, GE, false); int Inv = Pow(len, mod - 2); rep(i, 0, len - 1) GE[i] = 1ll * GE[i] * Inv % mod; &#125; rep(i, 0, n) F[i] = GE[i]; &#125; void read (int &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) c = getchar(); while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = (10ll * x + (c ^ 48)) % mod, c = getchar(); &#125; int main () &#123; read(n), n--; rep(i, 0, n) read(F[i]); EXP(n, F); rep(i, 0, n) printf(&quot;%d &quot;, F[i]); return 0; &#125; 多项式三角函数 三角函数 给定多项式 $F(x)$，求模 $x^{n}$ 意义下的 $\\sin F(x), \\cos F(x)$ 与 $\\tan F(x)$。 首先由欧拉公式 $\\left(e^{i x}=\\cos x+i \\sin x\\right)$ 可以得到三角函数的另一个表达式 ： $$\\begin{aligned} &amp;\\sin x=\\frac{e^{i x}-e^{-i x}}{2 i} \\\\ &amp;\\cos x=\\frac{e^{i x}+e^{-i x}}{2} \\end{aligned} $$那么代入 $F(x)$ 就有 : $$\\begin{aligned} \\sin F(x) &amp;=\\frac{\\exp [iF(x)] - \\exp [-iF(x)]}{2i} \\\\ \\cos F(x) &amp;=\\frac{\\exp [iF(x)] + \\exp [-iF(x)]}{2} \\end{aligned} $$直接按上述表达式编写程序即可得到模 $x^{n}$ 意义下的 $\\sin F(x)$ 与 $\\cos F(x)$。 再由 $\\tan F(x)=\\frac{\\sin F(x)}{\\cos F(x)}$ 可求得 $\\tan F(x)$。 时间复杂度 $\\Theta(n \\log n)$。 反三角函数 仿照求多项式对数函数的方法，对反三角函数求导再积分可得 ： $$\\begin{aligned} \\frac{\\mathrm{d}}{\\mathrm{d} x} \\arcsin x &amp;=\\frac{1}{\\sqrt{1-x^{2}}} \\\\ \\arcsin x &amp;=\\int \\frac{1}{\\sqrt{1-x^{2}}} \\mathrm{~d} x \\\\ \\frac{\\mathrm{d}}{\\mathrm{d} x} \\arccos x &amp;=-\\frac{1}{\\sqrt{1-x^{2}}} \\\\ \\arccos x &amp;=-\\int \\frac{1}{\\sqrt{1-x^{2}}} \\mathrm{~d} x \\\\ \\frac{\\mathrm{d}}{\\mathrm{d} x} \\arctan x &amp;=\\frac \\arctan x &amp;=\\int \\frac{1}{1+x^{2}} \\mathrm{~d} x \\end{aligned} $$那么代入 $F(x)$ 就有: $$\\begin{aligned} \\frac{\\mathrm{d}}{\\mathrm{d} x} \\arcsin F(x) &amp;=\\frac{F^{\\prime}(x)}{\\sqrt{1-F^{2}(x)}} \\\\ \\arcsin F(x) &amp;=\\int \\frac{F^{\\prime}(x)}{\\sqrt{1-F^{2}(x)}} \\mathrm{d} x \\\\ \\frac{\\mathrm{d}}{\\mathrm{d} x} \\arccos F(x) &amp;=-\\frac{F^{\\prime}(x)}{\\sqrt{1-F^{2}(x)}} \\\\ \\arccos F(x) &amp;=-\\int \\frac{F^{\\prime}(x)}{\\sqrt{1-F^{2}(x)}} \\mathrm{d} x \\\\ \\frac{\\mathrm{d}}{\\mathrm{d} x} \\arctan F(x) &amp;=\\frac{F^{\\prime}(x)}{1+F^{2}(x)} \\\\ \\arctan F(x) &amp;=\\int \\frac{F^{\\prime}(x)}{1+F^{2}(x)} \\mathrm{d} x \\end{aligned} $$直接按式子求就可以了。 时间复杂度均为 $\\Theta(n \\log n)$。","tags":"算法 oi c++ 组合数学 多项式 fft ntt fwt 拉格朗日插值 多项式分治乘法 多项式基本操作"},{"title":"十二类基本组合问题","url":"/2023/06/24/shi-er-lei-ji-ben-zu-he-wen-ti/","text":"小球入盒问题是所有组合问题的基础，它计算的是形如 “$n$ 个球放进 $m$ 个盒子的方案数” 的一类问题，在这类问题中一般存在三种限制 ： 小球是否有编号。 盒子是否有编号。 盒子中球的数量是无限制，至少一个还是至多一个。 记有编号为 $L\\rm (labelled)$，无编号为 $U\\rm (unlabelled)$，盒子中球的数量限制分别为 $A,B,C$，这样我们就可以将一个问题用三个字母简记，如 $\\rm LUB$ 表示将 $n$ 个有标号小球放进 $m$ 个无标号盒子里，每个盒子中至少有一个球的方案数。 可以发现问题共有 $12$ 类，现在我们来一个个分析。 Part1 LLA 将 $n$ 个有标号的球放进 $m$ 个有标号的盒子里，每个盒子中球的数量没有限制的方案数。 可以看作每次从 $m$ 个盒子里任选一个，一共要放 $n$ 次，没有其他限制，故方案数为 ： $$\\boxed{m^n} $$Part2 ULA 将 $n$ 个无标号的球放进 $m$ 个有标号的盒子里，每个盒子中球的数量没有限制的方案数。 在这个问题中我们只关心对每个盒子里面球的数量，所以这个问题的方案数等于方程 $x_1+x_2+\\cdots +x_m=n$ 非负整数解的数量，用隔板法可以求得其为 ： $$\\boxed{\\dbinom{n+m-1}{m-1}} $$Part3 ULB 将 $n$ 个无标号的球放进 $m$ 个有标号的盒子里，每个盒子中球的数量至少为 $1$ 的方案数。 这个问题与上个问题相似，方案数等于方程 $x_1+x_2+\\cdots +x_m=n$ 正整数解的数量，用隔板法可以求得其为 ： $$\\boxed{\\dbinom{n-1}{m-1}} $$Part4 LLC 将 $n$ 个有标号的球放进 $m$ 个有标号的盒子里，每个盒子中球的数量至多为 $1$ 的方案数。 我们发现这个问题等价于依次为每个球选择一个盒子，故答案为 ： $$\\boxed{m^{\\underline{n}}} $$Part5 ULC 将 $n$ 个无标号的球放进 $m$ 个有标号的盒子里，每个盒子中球的数量至多为 $1$ 的方案数。 相当于是为每一个盒子选择数量，等价于从 $m$ 个盒子中选出 $n$ 个，让它的数量为 $1$，故方案数为 ： $$\\boxed{\\dbinom{m}{n}} $$Part6 LUC 将 $n$ 个有标号的球放进 $m$ 个无标号的盒子里，每个盒子中球的数量至多为 $1$ 的方案数。 盒子顺序可以任意交换，所以任意一种方案都等价，发现当球数超过盒子数时无解，故方案数为 ： $$\\boxed{[n\\leqslant m]} $$Part7 UUC 将 $n$ 个无标号的球放进 $m$ 个无标号的盒子里，每个盒子中球的数量至多为 $1$ 的方案数。 理由同上，方案数为 ： $$\\boxed{[n\\leqslant m]} $$Part8 LLB 将 $n$ 个有标号的球放进 $m$ 个有标号的盒子里，每个盒子中球的数量至少为 $1$ 的方案数。 考虑使用容斥原理，枚举有多少个盒子为空，剩下的盒子随便填，故方案数为 ： $$\\boxed{\\sum_{i=0}^m(-1)^i\\dbinom{m}{i}(m-i)^n} $$利用 $\\rm Part9$ 中讲到的第二类斯特林数也可以 $\\rm LLB$ 问题的方案数表示为 ： $$\\boxed{\\begin{Bmatrix}n\\\\m\\end{Bmatrix}m!} $$Part9 LUB 将 $n$ 个有标号的球放进 $m$ 个无标号的盒子里，每个盒子中球的数量至少为 $1$ 的方案数。 只需要将 $m$ 个盒子排序产生的方案去除即可，故方案数为 : $$\\boxed{\\sum_{i=0}^m\\frac{(-1)^i(m-i)^n}{i!(m-i)!}} $$$\\rm LUB$ 问题的答案被定义为 “第二类斯特林数”，递推式如下 ： $$\\boxed{\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=m\\begin{Bmatrix}n-1\\\\m\\end{Bmatrix}+\\begin{Bmatrix}n-1\\\\m-1\\end{Bmatrix}} $$其含义为考虑新加入一个有标号小球，可以将其加入之前的任意一个盒子，也可以为它单独开一个盒子，方案数相加。 Part10 LUA 将 $n$ 个有标号的球放进 $m$ 个无标号的盒子里，每个盒子中球的数量无限制的方案数。 记 $\\rm LUA$ 问题的方案数为 $B_n$，读作贝尔数。因为若某个盒子为空可以看作没有这个盒子，故 $B_n$ 表示将 $n$ 个数划分成任意个集合的方案数，有 ： $$\\boxed{B_n=\\sum_{i=1}^n\\begin{Bmatrix}n\\\\i\\end{Bmatrix}} $$同时，我们发现它也可以递推，有递推式 ： $$\\boxed{B_{n+1}=\\sum_{i=0}^n\\dbinom{n}{i}B_i} $$其含义为第 $n+1$ 个数若和之前的 $i$ 个数放在一起，方案数为 $\\tbinom{n}{i}B_{n-i}$。 Part11 UUA 将 $n$ 个无标号的球放进 $m$ 个无标号的盒子里，每个盒子中球的数量无限制的方案数。 我们发现其实这就是划分数，求法如下 ： 记 $f_{i,j}$ 表示将 $i$ 划分成不超过 $j$ 的数的方案数，当计算 $f_{i,j}$ 时，其方案数可以从 $f_{i-j,j}$ 继承，表示分出去一个大小为 $j$ 的数，其方案数也可以从 $f_{i,j-1}$ 继承，表示不选大小为 $j$ 的数。故有转移方程 ： $$f_{i,j}=f_{i-j,j}+f_{i,j-1} $$我们发现 $f$ 的转移就是一个完全背包，所以考虑将其改写为一维形式，即 ： $$f_j=\\sum_{i=1}^nf_{j-i} $$记 $g_{i,j}$ 表示将 $i$ 划分成 $j$ 个数的方案，当计算 $g_{i,j}$ 时，其方案数可以从 $g_{i-j,j}$ 继承，表示将所有数 $+1$，其方案数也可以从 $g_{i-1,j-1}$ 继承，表示新增一个大小为 $1$ 的数。我们发现后增加的数一定比前增加的数小，所以不重，这样一定能遍历到所有合法的划分，所以不漏，故有转移方程 ： $$g_{i,j}=g_{i-j,j}+g_{i-1,j-1} $$这两种方式都可以做到 $\\Theta(n^2)$。 我们分析两种方式的优劣，发现第一种算法主要依赖于划分成的数大小的上界，第二种算法主要依赖于划分成数的数量，于是考虑根号分治。将问题看成一个完全背包，物品按照占用空间小于等于 $\\sqrt{n}$ 和大于 $\\sqrt{n}$ 分类即可。 同时，由于 $g$ 计算的只有物品占用空间大于 $\\sqrt{n}$ 的情况，所以转移方程要改写成 : $$g_{i,j}=g_{i-j,j}+g_{i-\\sqrt{n},j-1} $$每次加入一个 $\\sqrt{n}$ 就可以保证所有数都大于 $\\sqrt{n}$ 了。 最后统计答案的时候直接枚举 $i$，然后将 $f_i$ 和 $g_{n-i,k}$ 乘起来即可。 时间复杂度 $\\Theta(n\\sqrt{n})$。 Part12 UUB 将 $n$ 个无标号的球放进 $m$ 个无标号的盒子里，每个盒子中球的数量 至少为 $1$ 的方案数。 我们发现只需要先在每个盒子中放 $1$ 个球就可以了，等价于 $\\rm UUA$ 问题中 $n-m$ 个球，$m$ 个盒子的情况。","tags":"数学 组合数学"},{"title":"原根和阶","url":"/2023/06/24/yuan-gen-he-jie/","text":"阶的定义及求法 称使得 $a^t\\equiv 1\\pmod p$ 成立的最小正整数 $t_{min}$ 为 $a$ 对模数 $p$ 的阶，记为 $\\delta_p(a)$。 有如下定理 ：$\\delta_p(a)~|~n\\Longleftrightarrow a^n\\equiv 1\\pmod p$。 又有 $a^{\\varphi(p)}\\equiv 1\\pmod p\\Longrightarrow \\delta_p(a)~|~\\varphi(p)$ 可得一个 $\\Theta(\\sqrt{p}+\\log^2p)$ 求阶的算法： 首先将 $\\varphi(p)$ 分解成 $\\varphi(p)=k_1^{q_1}\\times k_2^{q_2}\\times \\cdots \\times k_r^{q_r}$ 的形式，令 $\\delta_p(a)=\\varphi(p)$，然后试着用每一个质因子去除 $\\delta_p(a)$，如果除了之后 $a^{\\frac{\\delta_p(a)}{k_i}}\\equiv 1\\pmod p$ 那么 $\\frac{\\delta_p(a)}{k_i}$ 就作为新的阶，直到不能再除，此时的 $\\delta_p(a)$ 就为 $a$ 在模 $p$ 意义下真正的阶。 原根的定义及求法 原根 $g$ 是使得 $g^{1\\sim p-1}$ 在模 $p$ 意义下的值与 $[1,p-1]$ 形成一一对应关系的值。 有如下定理 ：$g$ 为 $p$ 的原根当且仅当 $\\delta_p(g)=\\varphi(p)$。 于是可以导出一个计算 $g_{min}$ 的算法，从小到大枚举 $g$，若 $\\delta_p(g)=\\varphi(p)$，则 $g$ 为 $p$ 的最小原根。 有如下定理 ：$g_{min}&lt;p^{\\frac{1}{4}}$。 所以以上算法时间复杂度为 $\\Theta(\\sqrt{p}+p^{\\frac{1}{4}}\\omega(p))$。","tags":"算法 oi 数论 原根 阶"},{"title":"Z 算法","url":"/2023/06/24/z-suan-fa/","text":"算法简介 $Z$ 算法在国内也被某些人称为 $\\rm ExKMP$（虽然我不知道它跟 $\\rm KMP$ 算法有什么关系）。 $Z$ 算法用于求字符串 $S$ 的 $Z$ 函数，其定义为 $z_i=\\rm LCP(S,S_{i\\sim n})$。 这个算法的核心在于利用之前的信息来减少计算量。 具体来说我们可以从左往右依次求每个位置的 $z$ 函数，令 $[i, i + z_i - 1]$ 为 $i$ 的匹配段，同时维护出右端点最靠右的匹配段 $[l, r]$。 那么我们知道有 $S_{1 \\sim r - l + 1} = S_{l \\sim r}, S_{i \\sim r} = S_{i - l + 1, r - l + 1}(i \\leqslant r), z_i \\geqslant \\min(r - i + 1, z_{i - l + 1})$ 在计算 $z_i$ 时，分以下三种情况： 若 $i \\leqslant r, z_{i - l + 1} &lt; r - i + 1$ 那么显然有 $z_i = z_{i - l + 1}$。 若 $i \\leqslant r, z_{i - l + 1} \\geqslant r - i + 1$，那么我们就从 $r + 1$ 开始暴力匹配前缀。 若 $i &gt; r$，那么直接从 $i$ 开始暴力匹配前缀。 不难发现复杂度来源在于 $2, 3$ 情况，但可以发现右端点最靠右的匹配段的右端点总是在这两种情况下向右移动，而总移动量不超过 $n$，因此复杂度是 $\\Theta(n)$ 的。 如果要求 $z_i = \\rm LCP(T, S_{i \\sim n})$ 话，就类似于 $\\rm KMP$ 的做法，构造一个 $T \\# S$ 的串去求 $z$ 函数即可。 经典例题 [NOI2014] 动物园 对于每个 $i$，计算后缀 $S_{i\\sim n}$ 与 $S$ 的 $\\rm LCP$，考虑在后一个 border 的左端点 $i$ 处统计答案。 令最长公共前缀的四个端点分别为 $L,R,L',R'$，分两种情况讨论： 当 $R&lt;L'$ 时，区间 $[L',R']$ 答案 $+1$。 当 $R\\geqslant L'$ 时，区间 $[L',R]$ 答案 $+1$。 区间 $+1$ 可以使用差分实现，总时间复杂度 $\\Theta(n)$。 [CF1051E] Vasya and Big Integers 记 $f_i$ 表示 $a_{1\\sim i}$ 有多少种合法的划分方案，显然有一个 $\\Theta(n^2)$ 的暴力 $\\rm DP$，即往前枚举转移点 $j$，判断转移是否合法后累加。 观察到合法的转移点是一段连续的区间，若令 $len_l$ 和 $len_r$ 分别表示两限制字符串的长度，显然对于满足 $len_l&lt;i-j&lt;len_r$ 的转移点 $j$，这个转移都是合法的，现在的问题在于判断当 $j=i-len_l$ 或 $j=i-len_r$ 的时候转移是否合法。 考虑用 $\\rm ExKMP$ 对任意一个 $i$，求 $\\rm LCP(s_{i\\sim n},l)$ 和 $\\rm LCP(s_{i\\sim n},r)$，这样就可以快速求出 $s_{i-len_l+1\\sim i}$ 与 $l$ 的最长公共前缀 $zl_{i-len_l+1}$，并通过比较 $s_{i-len_l+1+z_{i-len_l+1}}$ 与 $l_{z_{i-len_l+1}+1}$ 的大小判断当 $j=i-len_l$ 时转移是否合法，同理，当 $j=i-len_r$ 时转移是否合法也可以通过相同方式判断。 这样，合法转移点的区间就在 $\\Theta(1)$ 的时间内求出来了，剩下的用前缀和记录一下即可。需要注意的是，由于不能出现前导零，所以当转移点的后一位为 ‘$0$’ 时不能将其加入前缀和数组。 总时间复杂度 $\\Theta(n)$。","tags":"算法 字符串 oi z-算法"},{"title":"Manacher 算法","url":"/2023/06/24/manacher-suan-fa/","text":"$\\rm Manacher$ 是用于求解一个字符串中所有回文子串的算法。 首先，回文子串的数量级是 $n^2$ 的，所以要考虑如何将所有回文子串快速地表达出来，容易发现如下性质： 如果存在一个以 $p$ 为中心，半径为 $d$ 的回文子串，那所有以 $p$ 为中心，半径小于 $d$ 的子串都是回文子串，证明显然。 于是我们记 $d_i$ 表示以 $i$ 为中心的最大回文子串，而 $\\rm Manacher$ 算法的用处就是在线性复杂度下求出这个序列。 具体过程跟 $Z$ 算法类似，记 $L,R$ 表示在之前的回文子串中，右端点最靠右的子串的左右端点，转移分三种情况： 若 $i&gt;R$，令 $L=i-1,R=i+1$，暴力更新。 若 $i\\leqslant R~\\&amp;~d_{L+R-i}&lt;R-i$，$d_i=d_{L+R-i}$。 若 $i\\leqslant R~\\&amp;~d_{L+R-i}\\geqslant R-i$，令 $L=2i-R$，暴力更新。 由于 $R$ 只会往右移，且每次暴力更新必定右移一位，所以时间复杂度为 $\\Theta(n)$。 但是我们发现，上面这种方法只处理了回文子串长度为奇数的情况，而偶数的情况只需要分开考虑，奇偶性稍微改变一下即可，但还有一种更加巧妙的方式可以规避分奇偶讨论。 考虑给所有字符之间加入一个不可能出现的相同字符，如字符串 $abaca$ 变成 $\\#a\\#b\\#a\\#c\\#a\\#$，这样在奇数位上统计的就是字串长度为偶数的答案，在偶数位上统计的就是字串长度为奇数的答案。同时，这样统计出来的半径 $d$ 就是以当前点为中心的最长回文子串的长度。","tags":"算法 字符串 oi manacher"},{"title":"KMP 算法 & KMP 自动机","url":"/2023/06/24/kmp-suan-fa-kmp-zi-dong-ji/","text":"Border &amp; $\\pi$ 函数 一些定义 字符串 $S$ 的真前/后缀为非自身的前/后缀。 字符串 $S$ 的 border为 $S$ 的公共真前/后缀。 字符串 $S$ 的最长 border 为 $\\pi$，对于 $S$ 的每个前缀 $S_{1 \\sim i}$ 令 $\\pi_i$ 为其最长 border，$\\pi$ 函数就是所谓的前缀函数。 $\\pi$ 函数的性质 $\\forall i,\\pi_{i+1}\\leqslant \\pi_i+1$。 由反证法易知。 字符串 $S$ 的所有 border 可以由 $\\pi_{|S|}$ 开始不断跳 $\\pi$ 由长度从大到小遍历。 只需证明 $S_{1 \\sim \\pi_{\\pi_n}}$ 是 $S$ 的次长 border 即可。 由 $\\pi$ 的定义易知。 相邻前缀函数满足 $\\pi_{i + 1} = \\max\\limits_{T ~ is ~ the ~ border ~ of ~ S_{1 \\sim i}, S_{i + 1} = S_{|T| + 1}} |T| + 1$。 使用反证法易知。 $\\pi$ 函数的线性求法 有了上述几条性质，我们可以得到一个求解 $\\pi$ 函数的算法： pi[0] = -1; for (int i = 1; i &lt;= n; i++) for (int j = pi[i - 1]; j &gt;= 0; j = pi[j]) if (s[j + 1] == s[i]) &#123; pi[i] = j + 1; break; &#125; 直观感受上这个做法是 $\\Theta(n ^ 2)$ 的，但实际上它是线性的，复杂度证明如下： 不难发现复杂度来源在于跳 $\\pi$，下面我们将证明跳 $\\pi$ 的总次数是线性的。 注意 $\\pi_i$ 的位置变化情况，不难发现 $\\pi_i$ 只会每次 $+1$ 或往前跳若干次，但往前跳的的总距离不能超过当前 $+1$ 的次数，故总路程也是线性的。 $\\pi$ 函数的基本应用 字符串匹配 求解模式串 $T$ 在匹配串 $S$ 中的出现位置的问题。 构造一个新的字符串 $T\\circ S$，其中 $\\circ\\not\\in S\\cup T$，它仅作为一个分隔符。 对这个新的字符串求其 $\\pi$ 函数，不难发现由于分隔符的出现，$\\forall i, \\pi_i \\leqslant |T|$，于是找到 $\\pi_i = |T|$ 的位置，$i - |T| + 1 \\sim i$ 就是一个匹配。 以上即为 $\\rm KMP$ 算法。 统计每个前缀的出现次数 考虑到如果某个前缀在之后的位置里出现过，那么一定是某个前缀的 border，于是我们考虑在每个数的最大 border 处统计答案，其为更小 border 的重复次数，并且更小的 border 一定可以通过跳 $\\pi$ 遍历到，这样只需要从后往前扫一遍，复杂度 $\\Theta(n)$。 for (int i = 1; i &lt;= n; i++) ans[i] = 1; for (int i = n; i &gt;= 1; i--) ans[pi[i]] += ans[i]; 至于这个问题的加强版，统计 $S$ 中的每个前缀在 $T$ 中的出现次数，可以构造 $S\\#T$，赋初值的时候只需要将 $T$ 中的位置初始化为 $1$ 即可。 统计本质不同子串的数目 考虑迭代计算，问题转化成：在当前字符串的末尾加入一个新的字符，以这个字符结尾的后缀中有多少个是前面没有出现过的。 如果一个子串 $S_{i\\sim n}$ 在前面出现过，则 $\\forall j\\geqslant i,S_{j\\sim n}$ 都在前面出现过。 由反证法易知。 于是就只需求出加入新字符后的串的反串中的 $\\max\\pi$ 即可，而这个字符的贡献就是 $|S|+1-\\max\\pi$，时间复杂度 $\\Theta(n^2)$。 字符串周期相关性质 称 $k$ 为 $S$ 的一个周期且仅当 $\\forall i\\leqslant |S|-k, S_i = S_{i + k}$，特别地若 $k \\nmid S$ 则称 $k$ 为 $S$ 的弱周期。 若字符串 $S$ 存在一个 border $T$，当且仅当 $S$ 存在一个长度为 $|S| - |T|$ 的（弱）周期。 必要性显然，充分性递归论证即可。 字符串 $S$ 的最短（弱）周期长度为 $n - \\pi_n$。 由 $\\pi$ 函数的定义易知。 若长度不小于 $p + q$ 的字符串 $S$ 存在长度分别为 $p, q$ 的（弱）周期，那么 $\\gcd(p, q)$ 也是 $S$ 的一个（弱）周期。 下面首先证明 $p - q(p &gt; q)$ 也是 $S$ 的一个（弱）周期。 分两种情况讨论： 若 $i \\leqslant q$，则 $S_i = S_{i + p} = S_{i + p - q}$，可知 $\\forall i \\leqslant q, p - q$ 是其一个（弱）周期。 若 $i &gt; q$，则 $S_i = S_{i - q} = S_{i + p - q}$，可知 $\\forall i &gt; q, p - q$ 是其一个（弱）周期。 证明 $p - q$ 是 $S$ 的一个（弱）周期后，根据更相减损术的性质，最终可以迭代至 $\\gcd(p, q)$ 是 $S$ 的一个（弱）周期。 所有强周期的长度均为最短强周期长度的倍数。 若存在一个强周期 $x$，显然有 $x\\mid n$，若 $n-\\pi_n\\nmid x$，则 $\\gcd(n-\\pi_n,x)&lt;n-\\pi_n$ 也为一个强周期，与 $n-\\pi_n$ 是最小强周期矛盾。 字符串 $S$ 存在周期当且仅当 $n - \\pi_n$ 为一个周期。 必要性显然。若存在强周期 $x\\mid n$，又因为 $n-\\pi_n\\mid x$，则 $n-\\pi_n\\mid n$，充分性得证。 KMP 自动机 在求 $\\pi$ 函数的时候，我们发现这个做法是支持在线插入一个字符在末尾并计算函数值的。 并且在做 $\\rm KMP$ 的过程中我们发现，在匹配串每一位求 $\\pi$ 函数时，并不关心之前匹配串的字符是什么，只关心之前的 $\\pi$ 函数值和当前位的字符。 这意味着可以对一个模式串建立一个自动机，结点 $i$ 表示当前节点的 $\\pi$ 值为 $i$，新加入一个节点的出边 $c$ 指向跳 $\\pi$ 时第一个能够匹配的结点。暴力建这个自动机的复杂度为 $\\Theta(n^2|\\Sigma|)$，因为出边需要遍历 $\\Sigma$，所以不存在求 $\\pi$ 函数时指针单方向移动的性质。 但是实际上之前已经计算了从所有节点开始，以任意一个字符为出边会到哪个节点，故可以直接调用。具体规则为，记 $f_{i,c}$ 表示从 $i$ 号节点开始，字符 $c$ 会到达的节点。如果当前到达了节点 $i$ ，字符为 $c$，则如果 $c=s_{i+1}$，那么当前节点指向 $i+1$，否则指向 $f_{\\pi_i,c}$。时间复杂度 $\\Theta(n|\\Sigma|)$。 同 $\\rm KMP$ 算法一样，$\\rm KMP$ 自动机也可以用来实现若干文本串和模式串的匹配，文本串从节点 $0$ 开始走，每次走到 $|S|$ 都完成了一次匹配。若模式串长度为 $m$，文本串长度为 $n$，数量为 $t$，则时间复杂度为 $\\Theta(m+tn|\\Sigma|)$。 另一方面，$\\rm KMP$ 自动机在完成普通字符串匹配时表现并不优秀，但它可以求解一些特殊的字符串匹配问题，如： 定义 $g_1=&quot;a&quot;$，$g_2=&quot;aba&quot;$，$g_3=&quot;abacaba&quot;\\cdots \\forall i,g_i=g_{i-1}+(char)i+g_{i-1}$。 给定另一字符串 $S$ 和整数 $k$，求 $S$ 在 $g_k$ 中的匹配次数。保证 $|S|\\times k\\leqslant 10^6$。 显然题目是要求从 $0$ 号节点开始对 $g_k$ 进行匹配，经过 $|S|$ 号节点的次数是多少。 首先对 $S$ 建立 $\\rm KMP$ 自动机，记 $f_{i,j}$ 表示从 $i$ 号节点开始对 $g_j$ 进行匹配后经过 $|S|$ 号节点的次数。记 $k_{i,S}$ 表示从 $i$ 号节点开始，匹配完字符串 $S=g_i+(char)i$ 后停下来的结点，那么有 ： $$f_{i,j}=f_{i,j-1}+[k_{i,g_{j-1}+(char)(j-1)}=|S|]+f_{k_{i,g_{j-1}+(char)(j-1)},j-1} $$总时间复杂度 $\\Theta(|S|\\times k)$。 另外，由于单次添加结点的复杂度是严格 $\\Theta(|\\Sigma|)$ 的，所以可以对 $\\rm KMP$ 自动机进行可持久化处理，总时间复杂度 $\\Theta(n|\\Sigma|\\log n)$。 例题：[CF808G] Anthem of Berland 考虑对模式串建立 $\\rm KMP$ 自动机。 令 $f_{i,j}$ 表示对字符串匹配到第 $i$ 位时，跳到自动机的 $j$ 号点匹配的次数最大值，显然有转移： $$f_{i,to}=\\begin{cases}\\max\\{f_{i-1,j}+[to=m]\\}(s_i\\not =~'?')\\\\\\max\\limits_{k=0}^{25}\\{f_{i-1,j}+[to=m]\\}(s_i=~'?')\\end{cases} $$由于 $\\rm DP$ 空间开不下，需要使用滚动数组。 时间复杂度 $\\Theta(|S||T||\\Sigma|)$。","tags":"算法 字符串 oi kmp kmp-自动机"},{"title":"AC 自动机","url":"/2023/06/24/ac-zi-dong-ji/","text":"失配指针 定义 fail 为广义的 $\\pi$ 函数，即对于 $n$ 个字符串，$fail_{i,j}=\\max\\limits_{k=1}^n \\pi(S_k\\#S_{i,1\\sim j})$。 上面那个是一种定义，但事实上，在 $\\rm AC$ 自动机中，fail 是具有指向性的，它指向的是所有模式串中，前缀与当前字符串某个前缀的后缀匹配可以产生最大匹配的那个串，它与当前串匹配的最后一个结点。 构建 AC 自动机 首先对所有模式串建立 Trie 树，显然 Trie 树上的每一个结点都对应某个模式串的某个前缀。 然后将每个 fail 都指向匹配的结点，显而易见，所有的 fail 都指向一个祖先节点，这个性质后面要用到。 最后构建转移边 Auto，Auto 指向跳 fail 过程中存在字符 $c$ 的结点。 具体来说，可以以 $\\rm BFS$ 序遍历 Trie 树，在遍历的同时更新答案，转移式如下： $$\\begin{cases}fail_u=Auto_{fail_{fa_u},c}\\\\Auto_{u,c}=Auto_{fail_u,c}\\end{cases} $$建 $\\rm AC$ 自动机复杂度为 $\\Theta(|\\Sigma|n)$。 文本串匹配 遍历文本串，直接按照转移边走即可，如果要统计每个模式串出现的次数，就将所有经过的点权值 $+1$，再在 fail 树上差分即可计算。 令模式串为 $S$，文本串为 $T$，总时间复杂度为 $\\Theta(|\\Sigma||S|+|T|)$。 例题：[HNOI2004]L语言 首先有一个显然的 $\\Theta(|s|\\sum|t|)$ 暴力，枚举文本串的转移点，显然其不能超过最大串长，转移式为： $$f_i=\\bigvee_{j=i-|s|}^{i-1}\\{f_j\\wedge[t_{j+1\\sim i}\\in s]\\} $$这个式子的核心在于，$f_i=true$ 当且仅当它存在一个后缀，这个后缀是某个模式串，并且删去这个后缀以后的文本串仍合法。 于是考虑建立 $\\rm AC$ 自动机，将文本串放在自动机上跑的时候记 $f_i$ 表示当前前缀是否合法。 存在如下 $\\rm AC$ 自动机性质：如果 $v$ 可以从 $u$ 开始由跳 fail 得到，即 fail 树上 $v$ 是 $u$ 的祖先，那么 $v$ 代表的字符串是 $u$ 代表的字符串的一个后缀。 所以从 $u$ 开始遍历跳 fail 经过的结点，如果它代表的字符串长度为 $l$，且为某个模式串的结尾，则将 $g_{u,l}$ 记为 true。 由于 $|s|\\leqslant 10$，所以只有当 $l\\leqslant 10$ 的时候 $g_{u,l}$ 可能为 true，故直接状压成 $g_u$，其二进制下第 $l$ 位表示之前 $g_{u,l}$ 的值。 最后直接将文本串放在 $\\rm AC$ 自动机上跑即可，记 $now_i$ 表示文本串中当前点前 $i$ 位的 $f$ 值为多少，易知 $i\\leqslant 10$，故也可以状压成一个数 $now$。 易知 $f_i=true$ 当且仅当 $[now~or~g_u]=true$。 总时间复杂度 $\\Theta(|\\Sigma|n|s|^2+m|t|)$。","tags":"算法 字符串 oi ac-自动机"},{"title":"(可持久化) Trie 树","url":"/2023/06/24/ke-chi-jiu-hua-trie-shu/","text":"字典树 顾名思义，字典树就是支持像字典一样加入和查询字符串的树形数据结构，实现如下： namespace Trie &#123; int Next[N][K], cnt, tag[N]; void Insert (char *s) &#123; int n = strlen(s + 1), now = 0; for (int i = 1; i &lt;= n; i++) &#123; int c = s[i] - &#x27;a&#x27;; if (!Next[now][c]) Next[now][c] = ++cnt; now = Next[now][c]; &#125; tag[now]++; &#125; int Find (char *s) &#123; int n = strlen(s + 1), now = 0; for (int i = 1; i &lt;= n; i++) &#123; int c = s[i] - &#x27;a&#x27;; if (!Next[now][c]) return false; now = Next[now][c]; &#125; return tag[now]; &#125; &#125; 0/1 Trie 在很多问题中，字符串仅由 $0$ 和 $1$ 构成，这些问题存在一定的共性。 维护异或极值 考虑如下问题，给定一颗带边权的树，求 $\\max\\limits_{i,j\\in[1,n]} \\oplus Path(i,j)$。 由异或的性质，可知 $\\oplus Path(i,j)=\\oplus Path(root,i)\\oplus Path(root,j)$。 所以可以把所有从根开始的路径的异或和表示成一个数字，这样就将问题转化成了求任意两个数字的异或的最大值，可以用 $\\rm 0/1~Trie$ 解决。 维护异或和 考虑如下问题，给一些数，维护它们的异或和，支持插入，删除和全局 $+1$。 对于异或和的维护，发现 $sum=\\sum_{i=0}^k2^i\\times [num_i\\equiv 1\\pmod 2]$。 其中 $sum$ 表示异或和，$num_i$ 表示所有数中二进制的第 $i$ 位为 $1$ 的数量。这个式子体现在 $\\rm 0/1~Trie$ 上就是对于所有以父亲边为 $1$ 的结点为根的子树中有多少个 $\\rm Tag$，令 $\\rm Tag$ 的数量为 $num$，这些结点的深度为 $k$，它们对答案的贡献即为 $num\\%2\\times 2^k$。 对于实现全局 $+1$ 操作，从低位到高维建 $\\rm 0/1~Trie$，考虑将一个二进制数 $+1$ 的一般操作，即找到从低位到高位的第一个 $0$，将它变成 $1$，数位比它低的 $1$ 全部变成 $0$。 而这个做法体现在 $\\rm 0/1~Trie$ 上可以将一个结点的两条指向儿子的出边交换，再递归向交换后的 $0$ 边迭代操作。 $0/1$ Trie 合并 与线段树合并类似，实现如下： void Merge (int &amp;p, int k) &#123; if (!p || !k) &#123; p = p + k; return; &#125; tag[p] += tag[k]; Merge(l[p], l[k]), Merge(r[p], r[k]); Push_up(); &#125; 需要注意的是，Trie 树合并和线段树合并一样，只有当每次合并的集合没有交集的时候复杂度才是 $\\Theta(n\\log n)$ 的。 可持久化 Trie 树 可持久化 Trie 的实现方式和可持久化线段树的方式是相似的，即每次只修改被添加或值被修改的节点，而保留没有被改动的节点，在上一个版本的基础上连边，使最后每个版本的 Trie 树的根遍历所能分离出的 Trie 树都是完整且包含全部信息的。实现如下： namespace Trie &#123; int rt[N &lt;&lt; 5], Next[N &lt;&lt; 5][2], cnt, tag[N &lt;&lt; 5]; void Build (int &amp;x, int y, int k, int pos) &#123; if (pos &lt; 0) return; x = ++cnt; if (!pos) tag[x]++; tag[x] += tag[y]; int d = (k &amp; (1 &lt;&lt; pos)) != 0; Next[x][d ^ 1] = Next[y][d ^ 1]; Build(Next[x][d], Next[y][d], k, pos - 1); &#125; int Query (int x, int y, int k, int pos) &#123; if (!x) return 0; int d = (k &amp; (1 &lt;&lt; pos)) != 0; return tag[x] - tag[y] + Query(Next[x][d], Next[y][d], k, pos - 1); &#125; &#125; 经典例题 [LG4735] 最大异或和 可持久化 $0/1$ Trie 模板题。 考虑记所有的前缀和，答案变为统计 $x\\oplus sum_n$ 在 $[l-1,r-1]$ 这个区间的 $0/1$ Trie 中的最大异或值。 [CF455B] A Lot of Games 显然直接建立 Trie 树，每次相当于向 Trie 树的子树内走一步，不能走者为负。 考虑设 $f$ 表示是否存在必胜策略，$g$ 表示是否存在必败策略，转移显然。 对 $f_{root}$ 和 $g_{root}$ 分四种情况讨论，每种情况下的答案易得。需要注意的是，如果先手既存在必胜策略又存在必败策略，那他可以故意输以获得下一局的先手，然后在最后一局获得胜利。 [CF888G] Xor-MST $\\rm Trie+Boruvka$。 考虑将所有树插入一个 Trie 中，枚举到某个连通块时将其中所有点从 Tire 中删除，再用连通块中每个结点从 Trie 中查找出最小边权，完成后再将连通块中的点权加回去。 发现一个性质，每次合并的连通块都是 Trie 中某个节点的左右子树，再由 Trie 的性质，我们甚至不需要把 Trie 建出来，只需要将 A 排序，二分 Trie 的左右儿子，再将其中一个儿子的所有结点建 Trie，用另一个儿子中的所有结点在其中查找连通块之间的最小边权即可。 由于每个结点最多被加进 Trie 树 $\\log n$ 次，每次复杂度为 $\\log W$，所以总时间复杂度为 $\\Theta(n\\log n\\log W)$。","tags":"算法 字符串 trie 可持久化-trie-树 oi"},{"title":"虚树","url":"/2023/06/24/xu-shu/","text":"虚树 在一些问题中，我们只关心关键点的信息，同时我们需要维护他们之间的树形结构，于是可以想到将它们和它们之间的 $\\rm LCA$ 拉出来建一颗树，这棵树就被称作虚树。 有一个朴素的想法，就是对它们两两求 $\\rm LCA$，并且对求出的 $\\rm LCA$ 再求 $\\rm LCA$，中途判重，最后按照祖先关系连边。 经过观察可以发现，我们只需要按照 $\\rm dfs$ 虚从小到大的顺序枚举每个点，将相邻两点求 $\\rm LCA$ 即可。具体来说，我们可以维护一个栈，这个栈中存的是当前点在虚树上的所有祖先。设当前栈顶为 $v$，对于新加入的结点 $u$，我们对它进行分类讨论 ： 若 $\\rm LCA(u,v)=v$，那么直接将 $u$ 入栈。 若 $\\rm LCA(u,v)$ 是栈中某个不为 $v$ 的点，则弹栈直到 $\\rm LCA(u,v)$，每弹一个就向栈中比它深度多 $1$ 的结点连边，最后并把 $u$ 入栈。 若 $\\rm LCA(u,v)$ 不在栈中，那么弹栈直到栈顶的 $\\rm dfs$ 序小于 $\\rm LCA(u,v)$ 的 $\\rm dfs$ 序，每弹一个就向栈中比它深度多 $1$ 的结点连边，并把最后一个弹出的结点向 $\\rm LCA(u,v)$ 连边，最后把 $\\rm LCA(u,v)$ 和 $u$ 入栈。 不难发现这样一定是对的，并且设关键点数量为 $k$，则虚树内点数不超过 $2k$。 在一棵有 $n$ 个点的树上建立一颗有 $k$ 个点的虚树的时间复杂度为 $\\Theta(k\\log n)$。 经典例题 [SDOI2011] 消耗战 首先有一个暴力 $\\rm DP$，设 $dp_u$ 表示将 $u$ 的子树内所有关键点与 $u$ 的联系断开所需要的最小代价。转移时枚举 $u$ 的所有子节点，分类讨论： 若 $v$ 为关键点，那么必须切断这条边，有 $dp_u=dp_u+w_{u,v}$ 若 $v$ 不为关键点，那么可以切断这条边也可以从 $dp_v$ 转移，故有 $dp_u=dp_u+min\\{dp_v,w_{u,v}\\}$ 最终答案就是 $dp_1$，这个暴力的时间复杂度是 $\\Theta(qn)$。 观察到 $\\sum k\\leqslant 5e5$，所以考虑对每次询问建虚树。 建虚树之前需要记 $M_u$ 表示从 $1$ 到 $u$ 的路径上最短的边权，因为只需要切掉最短的边权就可以让点 $u$ 与 $1$ 不连通，而切上面的边是更优的，所以可以用 $M_u$ 直接替换转移方程中的 $w_{u,v}$。 时间复杂度 $\\Theta(\\sum k\\log n)$。 [HEOI2014] 大工程 首先建虚树。 对于两两之间距离之和，可以计算每条边的贡献。 对于最大$/$最小值，可以树形 $\\rm DP$ 或点分治。 时间复杂度 $\\Theta(\\sum k\\log n)$。 [SDOI2015] 寻宝游戏 我们发现如果将虚树建出来，那么答案就是虚树上所有边权之和的两倍。 于是我们考虑动态维护虚树的边权之和。先把所有点的 $\\rm dfs$ 序求出来，然后我们发现边权之和等于 $\\rm dfs$ 序相邻两点的距离之和加上最左边和最右边两点的距离，于是我们可以使用 $\\rm set$ 维护，树剖求 $\\rm LCA$。 时间复杂度 $\\rm \\Theta(n\\log n)$。","tags":"算法 oi 图论 虚树"},{"title":"长链剖分","url":"/2023/06/24/chang-lian-pou-fen/","text":"长链剖分 考虑将重儿子设为链最长的那一个，剖分是简单的，可以做到 $\\Theta(n).$ 这样剖分有一些性质： 链长和是 $n$，因为每个点都在且仅在一条链中。 任意点 $x$ 的 $k$ 级祖先 $y$ 到它所在的长链底端距离不小于 $k$ 。因为如果 $x$ 和 $y$ 在同一条长链上，那么 $y$ 所在的长链长度不小于 $k$ 。如果它们不在同一条的长链上，那么 $y$ 到另一条长链底端的距离一定大于 $k$，否则的话 $x$ 所在的链就可以接在 $y$ 上成为更长的链。 从任意一个点开始跳重链的次数最多是 $\\sqrt{n}$ 级别的。因为容易知道每次跳到的长链长度一定大于当前链，于是最坏情况是分别经过了长度为 $1, 2, 3, \\cdots, \\sqrt{n}$ 的长链，最多跳 $\\sqrt{n}$ 次。 $\\Theta(n \\log n) - \\Theta(1)$ 算 $k$ 级祖先 考虑预处理每个点的 $2$ 的幂次级祖先，对于一次询问 $(u, k)$，首先跳到 $u$ 的 $highbit(k)$ 级祖先 $v$ 上，由长链剖分的性质可知，$v$ 到其所在长链底端的距离不小于 $highbit(k).$ 由于长链长度之和为 $n$，所以我们可以预处理每条链顶端节点的 $l$ 级祖先，$l$ 取遍不大于链长的所有整数。并且我们还可以存下每条链的所有节点，挂在链顶。 这样，对于一次询问，假设 $v$ 的 $k - higtbit(k)$ 级祖先不超过链顶，那么可以直接查询，否则也可以从链顶跳若干步得到。由于 $k - highbit(k) &lt; hightbit(k)$，故其一定小于链长，要查询的祖先是预处理过的。 时间复杂度 $\\Theta(n \\log n)$ 预处理，单次查询 $\\Theta(1)$。","tags":"算法 oi 图论 链剖分 长链剖分"},{"title":"缩点 & 割点 & 割边","url":"/2023/06/24/suo-dian-ge-dian-ge-bian/","text":"Tarjan 算法 强连通分量 若图 $G$ 中存在一个子图 $G'$，$G'$ 中任意两点均可互相到达，则称 $G'$ 为 $G$ 的一个强连通分量。若 $G'$ 不存在一个严格子图为强连通分量，则 $G'$ 为 $G$ 的极大强连通分量。 图的强连通分量可以考虑使用 $\\rm Tarjan$ 算法求解。 $\\rm Tarjan$ 算法的思想是这样的，如果一个点的 $\\rm dfs$ 序等于他能访问到的最小的 $\\rm dfs$ 序，那么在 $\\rm dfs$ 树中，它的下方会出现一个强连通分量，且所有最小能访问到的 $\\rm dfs$ 序等于它的点，属于这个强连通分量。 时间复杂度 $\\Theta(n+m)$。 参考代码： void Tarjan (int u) &#123; dfn[u] = low[u] = ++tix, Sta[++top] = u; for (int i = last[u]; i; i = Next[i]) if (!dfn[to[i]]) Tarjan(to[i]), low[u] = min(low[u], low[to[i]]); else if (!SCC[to[i]]) low[u] = min(low[u], dfn[to[i]]); if (dfn[u] == low[u]) &#123; SCC[u] = ++id; while (Sta[top] != u) SCC[Sta[top--]] = id; top--; &#125; &#125; 点/边双连通分量 如果在 $\\rm dfs$ 树上，某个结点 $u$ 存在一个子节点 $v$ ，满足 $low_v\\geqslant dfn_u$ ，则说明 $v$ 想到达 $u$ 的祖先结点必须经过 $u$，所以 $u$ 是一个割点。 当然，根节点不能通过这种方式来判断，应该看它的子节点数是否大于等于 $2$，如果是，则它为割点。 遍历的时候要记得判掉父子边。 和判断割点的方法几乎一模一样，唯一的区别是判断 $dfn_u&lt;low_v$ 而不是 $dfn_u\\leqslant low_v$。（如果从 $v$ 出发连 $u$ 都无法到达，那么 $(u, v)$ 就是一条割边。 判断割边的时候根节点不需要特殊考虑。 时间复杂度 $\\Theta(n+m)$。 参考代码： void Tarjan (int u, int rt) &#123; dfn[u] = low[u] = ++tix; int son = 0; for (int i = last[u]; i; i = Next[i]) &#123; if (!dfn[to[i]]) &#123; son++, Tarjan(to[i], rt); low[u] = min(low[u], low[to[i]]); if (low[to[i]] &gt;= dfn[u] &amp;&amp; u != rt) cut[u] = true; &#125; low[u] = min(low[u], dfn[to[i]]); &#125; if (u == rt &amp;&amp; son &gt; 1) cut[u] = true; &#125; 经典例题 [国家集训队] 稳定婚姻 首先在夫妻之间连有向边 $B_i\\to G_i$，然后在情人之间连有向边 $G_i\\to B_i$。 可以发现，若 $G_i$ 和 $B_i$ 的婚姻情况发生了改变，那么一定存在一个从 $G_i$ 开始 $B_i$ 结束的环。 于是我们使用 $\\rm Tarjan$ 算法求强连通分量，若 $B_i$ 与 $G_i$ 属于同一个强连通分量，那他们一定属于一个环，则他们是不安全的，否则就是安全的。 时间复杂度 $\\Theta(n+m)$。 [ZJOI2007] 最大半连通子图 首先缩点，发现强连通分量内的点一定属于同一个极大半连通子图。 然后将 $\\rm DAG$ 画出来发现最大半连通子图一定是某条从无入度结点到无出度结点的链，长度和方案数直接 $\\rm DAG$ 上 $\\rm DP$ 即可。 需要注意的是，在这题中，由于求的是导出子图，所以不能有重边。 时间复杂度 $\\Theta(n+m)$。 [HNOI2012] 矿场搭建 先把个点和点双连通分量处理出来，对每个点双分开处理： 若该点双无割点，则需要建两个出口。 若该点双有一个割点，则需要在这个点双内建一个出口，且不能建在割点上。 若该点有两个以上割点，则不需要建出口，因为一定可以从某个割点跑出去。 方案数直接乘法原理计算即可。 时间复杂度 $\\Theta(n+m)$。 [HAOI2010] 软件安装 可以发现这是一棵基环外向树，依题意环中结点必须选，剩下的构成一棵树，直接树上背包即可。 时间复杂度 $\\Theta(nm)$。","tags":"算法 oi c++ 图论 连通性 tarjan 强连通分量 点双连通分量 边双连通分量"},{"title":"欧拉回路","url":"/2023/06/24/ou-la-hui-lu/","text":"定义 欧拉路径：如果图中的一个路径包括每个边恰好一次，则该路径称为欧拉路径。 欧拉回路：首尾相接的欧拉路径被称为欧拉回路。 判定 由于每一条边都要经过恰好一次，因此对于除了起点和终点之外的任意一个节点，只要进来，一定要出去，故有如下结论： 一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数，且该图只有一个存在边的连通块。 一个无向图存在欧拉路径，当且仅当该图中奇点的数量为 $0$ 或 $2$ 且该图只有一个存在边的连通块。 一个有向图存在欧拉回路，当且仅当所有点的入度等于出度。 一个混合图存在欧拉回路，当且仅当存在一个对所有无向边定向的方案，使得所有点的入度等于出度。求解需要用到网络流相关算法。 求解 一般使用 $\\rm dfs$ 算法求出一张图的欧拉回路。 给每一条边记一个 $\\rm vis$ 数组，表示其是否被访问过，然后从一个点出发，遍历所有的边。 直接 $\\rm dfs$ 的话可能会有一些点无法被遍历到，于是在记录答案的时候可以倒着记录，即当通过 $u\\to v$ 这条边的时候，可以先将点 $v~\\rm dfs$ 完，再加入 $u\\to v$ 这条边。这样做相当于如果碰到两个相邻的环，但只遍历了其中一个就走到头了，于是我们需要走完另一个环后将两个环拼起来。 由于只需要将图遍历一遍，所以时间复杂度是 $\\Theta(n + m)$ 的。 参考代码 void dfs (int u) &#123; for (int i = last[u]; i; i = Next[i]) &#123; if (vis[i]) continue; vis[i] = true; int record = i; dfs(to[i]); Sta[++top] = record; &#125; &#125;","tags":"算法 oi c++ 图论 欧拉回路"},{"title":"最短路","url":"/2023/06/24/zui-duan-lu/","text":"最短路算法拓展技巧 Floyd 传递闭包 有时候我们需要维护一些具有传递性的关系，如相等，连通等。 初始条件往往是给定几组关系，要把所有的关系求出来。 可以把 Floyd 算法做一些调整： $$dis_{i,j}=dis_{i,j}~|~(dis_{i,k}~\\&amp;~dis_{k,j}) $$时间复杂度还是 $\\Theta(n ^ 3)$，但由于位运算的特殊性，有些时候可以使用 bitset 优化到 $\\Theta\\left(\\frac{n ^ 3}{\\omega}\\right)$。 Johnson 重赋权 对于多源最短路，如果我们枚举一个点然后跑堆优化的 Dijkstra，那么复杂度是 $\\Theta(nm \\log n)$ 的，在图比较稀疏的情况下，这个复杂度要优于 Floyd 算法的 $\\Theta(n ^ 3)$。 但是 Dijkstra 算法要求所有边权均非负，于是就有了重赋权的技巧。 具体来说，我们新建一个 $0$ 号点，并且从这个点出发向所有点连一条边权为 $0$ 的边，然后跑单源最短路(SPFA 或者 Bellman-Ford)。设距离数组为 $h$， 接下来对于每条边 $(u, v)$， 令 $$w^{\\prime}(u, v)=w(u, v)+h(u)-h(v) $$这样所有的边权都变成非负的，我们就可以跑 Dijkstra 算法了。 接下来证明这样做为什么是对的： 首先由于 $h(v) \\leqslant h(u)+w(u, v),$ 所以新图的边权一定非负。 设新图上的最短路径为 $d^{\\prime}$，原图上的最短路径为 $d$。 $$\\begin{aligned}d^{\\prime}(u, v) &amp;= \\min _{a_{1}, a_{2}, \\ldots, a_{k}} w^{\\prime}\\left(u, a_{1}\\right)+w^{\\prime}\\left(a_{1}, a_{2}\\right)+\\cdots+w^{\\prime}\\left(a_{k}, v\\right) \\\\\\\\ &amp;= \\min _{a_{1}, a_{2}, \\ldots, a_{k}} w\\left(u, a_{1}\\right)+\\left(h(u)-h\\left(a_{1}\\right)\\right)+w\\left(a_{1}, a_{2}\\right)+\\left(h\\left(a_{2}\\right)-h\\left(a_{1}\\right)\\right)+\\cdots+w\\left(a_{k}, v\\right)+\\left(h(v)-h\\left(a_{k}\\right)\\right) \\\\\\\\ &amp;= h(u)-h(v)+\\min _{a_{1}, a_{2}, \\ldots, a_{k}} w\\left(u, a_{1}\\right)+\\cdots+w\\left(a_{k}, v\\right) \\\\\\\\ &amp;= h(u)-h(v)+d(u, v)\\end{aligned} $$这个证明用到了势能分析的思想，如果想进一步了解话可以参考本站《「杂项」复杂度分析》一文。 最短路图 所谓最短路图，就是在求完从 $S$ 出发的单源最短路之后，只保留最短路上的边形成的有向图。 只需要在求的过程中维护一个 $pre_u$ 数组表示点 $u$ 的前驱即可。 很多最短路的变种都需要用这个算法，有时候考虑最短路图也有利于发现一些隐藏的性质。 经典例题 [LG1266] 速度限制 记 $dis_{i,j}$ 表示当前已经到 $i$，上一个点是 $j$ 的时间最短路。 本质上是个分层图最短路，直接跑 Dijkstra 就好了。 时间复杂度 $\\Theta(nm\\log n)$。 [ICPC-BJ2006] 狼抓兔子 首先有定义 ： 平面图是指的存在某种方式使得图上所有边平铺在平面上无交。 对偶图是指的将平面图上的每个区域看作一个点，两点连边当且仅当两区域相邻，边权为将两区域分隔开的边的权值。 有定理 ： 平面图两点间最小割等于对偶图两点间最短路。 于是在这道题中我们就可以将每个三角形区域看作一个点，相邻区域连边后跑从左下角到右上角的最短路。 时间复杂度 $\\Theta(n^2\\log n)$。 [GXOI/GZOI2019] 旅行者 我们发现可以对 $k$ 个点二进制分组，每次将 $k$ 个点分成两个集合 $S_1$ 和 $S_2$，建一个源点 $s$ 向所有 $S_1$ 中的结点连长度为 $0$ 的边，建一个汇点 $t$ 从所有 $S_2$ 中的结点开始向它连长度为 $0$，的边，求从 $s$ 到 $t$ 的最短路。 可以发现，若答案为两点 $x$ 和 $y$ 之间的最短路，那么一定有 $x\\not= y$，这意味着它们至少在某一次二进制分组中被分到了不同的集合，所以这样一定可以找到两点间的最短路。 时间复杂度 $\\Theta(Tn\\log n\\log k)$。","tags":"算法 oi 图论 最短路 传递闭包 johnson-重赋权 最短路图 平面图最小割转对偶图最短路"},{"title":"最小生成树","url":"/2023/06/24/zui-xiao-sheng-cheng-shu/","text":"Kruskal 最常用且大部分情况下效率最高的最小生成树算法。 将边按长度从小到大排序，每次贪心选择最短的一条边，若这条边连接的两个点还为连通，则将两个点所在的连通块用这条边连接，连通块用并查集维护。 证明: 使用归纳法，证明任何时候 Kruskal 算法选择的边集都被某棵 MST 所包含。 基础: 对于算法刚开始时，显然成立（最小生成树存在）。 归纳: 假设某时刻成立，当前边集为 $F$，令 $T$ 为这棵 MST，考虑下一条加入的边 $e$。 如果 $e$ 属于 $T$，那么成立。 否则，$T+e$ 一定存在一个环，考虑这个环上不属于 $F$ 的另一条边 $f$ ( 一定只有一条）。 首先，$f$ 的权值一定不会比 $e$ 小，不然 $f$ 会在 $e$ 之前被选取。 然后， $f$ 的权值一定不会比 $e$ 大，不然 $T+e-f$ 就是一棵比 $T$ 还优的生成树了。 所以， $T+e-f$ 包含了 $F$，并且也是一棵最小生成树，归纳成立。 时间复杂度 $\\Theta(m\\log m)$。 Kruskal 重构树 这是 Kruskal 算法除了求最小生成树以外的一个重要应用。 在使用 $\\rm kruskal$ 最小生成树算法的时候会从小到大加入 $n-1$ 条边。现在仍按照这个顺序，每次加入一条边时将其变成一个点权等于边权的点，然后把它作为所连接两个连通块的父亲节点。 不难发现两个结点在 MST 上的最短路径上的边权最大值为它们在 $\\rm kruskal$ 重构树上 $\\rm LCA$ 的点权，并且从一个点 $u$ 出发只经过边权小于某值的边能够到达的点集为 $\\rm Kruskal$ 重构树上某点的子树内所有的叶子结点。 Prim 在稠密图上复杂度最优的最小生成树算法。 与 Dijkstra 算法类似，选择一个点作为起点，每次选择到当前已选的点集中任意一个点距离最短的未选择的点并向其连边，再递归操作。 证明: 还是说明在每一步，都存在一棵最小生成树包含已选边集。 基础: 只有一个结点的时候，显然成立。 归纳: 如果某一步成立，当前边集为 $F$, 属于 $T$ 这棵 MST，接下来要加入边 $e$。 如果 $e$ 属于 $T$，那么成立。 否则考虑 $T+e$ 中环上另一条可以加入当前边集的边 $f$。 首先，$f$ 的权值一定不小于 $e$ 的权值，否则就会选择 $f$ 而不是 $e$ 了。 然后，$f$ 的权值一定不大于 $e$ 的权值，否则 $T+e-f$ 就是一棵更小的生成树了。 因此，$e$ 和 $f$ 的权值相等, $T+e-f$ 也是一棵最小生成树，且包含了 $F$。 时间复杂度 $\\Theta[(n+m)\\log n]$。 Boruvka 在大多数完全图上求最小生成树所使用的算法。 每次遍历所有的点，求出它当前属于哪个连通块。 遍历所有的边 $u-v$，如果 $u$ 和 $v$ 不在同一个连通块，就分别用 $u$ 和 $v$ 去更新它们所在连通块的最小出边。 将每个连通块的最小出边加入 MST 的边集。 由于每次连通块数量减半，所以时间复杂度 $\\Theta(m\\log n)$。","tags":"算法 oi 图论 最小生成树 kruskal kruskal-重构树 prim boruvka"},{"title":"差分约束","url":"/2023/06/24/chai-fen-yue-shu/","text":"差分约束是用来解形如 $x_1-x_2\\leqslant k$ 的若干个方程的算法。 我们发现可以将方程移项成 $x_1\\leqslant x_2+k$，解方程的时候考虑建图，从 $x_2$ 向 $x_1$ 连一条长度为 $k$ 的边，然后对这张图建一个超级源点，向所有点连一条长度为 $0$ 的边，最后跑最短/最长路得出的 $dis$ 就是每个变量的一个取值。 为什么这样做是对的呢？因为如果有一条 $u$ 到 $v$ 的长度为 $w$ 的边，那么跑完最短路以后 $dis_v$ 一定不大于 $dis_u + w$，恰好满足一个方程。那么将所有边连上以后再跑最短路就可以满足所有方程，最长路同理。 另外，如果有负环则无解。 时间复杂度 $\\Theta(\\rm SPFA)$。 需要注意的是，最短路求的是以起始点为基准的最大解，而最长路求的是以起始点为基准的最小解。","tags":"算法 oi 图论 差分约束 最短路"},{"title":"Prufer 序列","url":"/2023/06/24/prufer-xu-lie/","text":"Prufer 序列的定义 $\\rm Prufer$ 序列可以将一颗结点数为 $n$ 的有标号无根树用一个长度为 $n-2$，值域为 $[1,n]$ 的数列唯一表示，即有标号无根树和 $\\rm Prufer$ 序列呈双射关系。 具体来说，有标号无根树的构建方式如下： 选择一个编号最小的叶子节点，并将其删除。 将这个叶子节点所连接的点的编号加入 $\\rm Prufer$ 序列中。 重复以上步骤 $n-2$ 次，直到树上只剩下 $2$ 个点。 这是某一颗点数为 $n$ 的有标号无根树的 $\\rm Prufer$ 序列的构造过程： 快速求解 Prufer 序列 由其过程，显然有一个使用堆优化的 $\\Theta(n\\log n)$ 做法，但 $\\rm Prufer$ 序列其实可以线性构造。 记录所有点的度数和一个指针 $p$ 指向编号最小的叶子节点，进行以下操作： 将 $p$ 指向的结点删除，检查是否出现了新的叶结点。 如果产生了新的叶结点，记其编号为 $x$。 若 $x&gt;p$，则不做任何操作，否则将其删除，并检查删除 $x$ 以后是否出现了新的叶结点，重复这一步操作直到没有产生新的叶结点或新产生的结点编号大于 $p$。 让 $p$ 自增直到遇见下一个叶结点为止。 重复以上操作直到结点数为 $2$ 可以得到这棵树的 $\\rm Prufer$ 序列。 可以发现，在算法流程中，每条边只在其连接的外层结点被删除时被遍历过一次，并且 $p$ 单调递增，树中的节点数单调递减，所以每个点也只被遍历过一次。 总时间复杂度 $\\Theta(n)$。 快速还原 Prufer 序列 显然还是有一个堆优化的 $\\Theta(n\\log n)$ 做法。 从前到后枚举 $\\rm Prufer$ 序列中的每一个数，维护不在序列中的结点编号的最小值。显然不在序列中的是叶子节点，并且其最小值为最后一个加入的，于是将其与当前枚举的序列中的数连边。连边后若序列中已没有枚举的这个数，那么将其踢出序列作为新的叶子结点。 考虑以与之前构造 $\\rm Prufer$ 序列相同的方法构造线性做法。 记一个指针 $p$ 指向不在序列中的最小结点，如果将其连向序列中枚举的位置，并将枚举的位置删除。序列中没有这个结点了，那么如果被删除的结点比 $p$ 小，直接将其与现在序列中枚举的数连边后将其删除，重复操作。如果这个结点的值大于 $p$，那么不用管它，在后面它一定会被枚举到。 显然，这种算法的时间复杂度为 $\\Theta(n)$。 Prufer 序列的应用 Cayley 公式 完全图 $K_n$ 有 $n^{n-2}$ 颗生成树。 证明方法很多，其中最简单的应该是利用 $\\rm Prufer$ 序列。 考虑到任何一个长度为 $n-2$ 的 $\\rm Prufer$ 序列唯一对应一颗大小为 $n$ 的有标号无根树，于是考虑计算长度为 $n-2$ 的 $\\rm Prufer$ 序列的数量，又因为其值域为 $[1,n]$，故总方案数为 $n^{n-2}$。 限定度数的有标号无根树计数 求有 $n$ 个结点，且第 $i$ 个结点的度数为 $d_i$ 的有标号无根树的数量。 考虑到一个点的度数为其在 $\\rm Prufer$ 序列中出现次数 $+1$，于是对于一个度数为 $d_i$ 的点，其在 $\\rm Prufer$ 序列中的出现次数应为 $d_i-1$，故存在这样的有标号无根树当且仅当 $\\sum_{i=1}^n d_i-1=n-2$，并且这样的树的数量为： $$\\dbinom{n-2}{d_1-1,d_2-1,\\cdots ,d_n-1}=\\frac{(n-2)!}{(d_1-1)!(d_2-1)!\\cdots (d_n-1)!} $$","tags":"算法 oi 图论 组合数学 prufer-序列"},{"title":"2-SAT 问题","url":"/2023/06/24/2-sat-wen-ti/","text":"求解 2-SAT 问题 $2-\\rm Sat$ 问题是求解某个 $\\rm bool$ 方程组，方程组中的每个方程被描述为：$x_i$ 为真$/$假 或 $x_j$ 为真$/$假。 我们可以对每个 $x_i$ 和 $\\lnot x_i$ 分别建点，$x_i$ 为假看作 $\\lnot x_i$ 为真，这样方程就仅有一种类型了，即若 $p$ 为真则 $q$ 为真。具体来说，建一些边 $u\\to v$ 表示当 $u$ 为真的时候 $v$ 一定为真，比如有方程 $p$ 为真或 $q$ 为真时，建两条边 $p\\to \\lnot q$ 和 $q\\to \\lnot {p}$。 建完图后，显然同一个强连通分量中的点取值必然相同，那么如果 $a$ 和 $\\lnot a$ 在同一个强连通分量里则该 $\\rm bool$ 方程组无解。易知，存在 $a$ 和 $\\lnot a$ 在同一个强连通分量中为该 $\\rm bool$ 方程组无解的充要条件。 对于其它的点，每对 $a$ 和 $\\lnot a$ 中有且仅有一个为真，我们令拓扑序大的那个为真。可以分情况证明其最优性 ： 若 $a$ 和 $\\lnot a$ 在 $\\rm DAG$ 的同一条链上，那么拓扑序大的必然为真，否则两个都为真与题意相悖。 若 $a$ 和 $\\lnot a$ 在不同链上，那么两个点的取值其实无所谓，但一定要跟拓扑序相关。因为每条链上拓扑序的大小关系时严格的，用拓扑序规定某个点取值是否为真可以使为真的点在同一条链上，尽可能降低对其他点的影响。另外，为了保证跟上一种情况的统一性，仍选择令拓扑序大的点为真。 另一方面，我们发现 $\\rm Tarjan$ 缩点所求出的 $\\rm SCC$ 强连通分量数组的值负相关，可以理解为拓扑序更小的点更后入栈，也更先出栈编号。故最后对比 $a$ 和 $\\lnot a$ 的 $\\rm SCC$ 值即可判断它们谁为真谁为假。 经典例题 [LG6378] Riddle 对树上每个点建立一个 $\\rm bool$ 变量，取值为 $1$ 表示这个点选。 使用 $\\rm 2-Sat$ 的通用做法，建立为每个点的状态建立两个点 $u$ 和 $\\lnot u$，分别对每个限制考虑 ： 每条边至少有一个关键点，则对于一条边 $u-v$ 若 $\\lnot u$ 则 $v$，若 $\\lnot v$ 则 $u$，故连接 $\\lnot u\\to v$ 和 $\\lnot v\\to u$。 每个部分最多有一个关键点，则如果 $u$ 被选了，那么同一个块中所有点都不能选，连接 $u\\to \\lnot v$。 但是我们发现这样连边是 $\\Theta(n^2)$ 的，所以前缀和优化连边即可。 建好图以后直接跑 $\\rm 2-Sat$，时间复杂度 $\\Theta(n)$。 [POI2011] KON-Conspiracy 首先转化题意，这道题要求的是将一张无向图划分成一个团和一个独立集的方案数。 首先找出一种合法的方案是很容易的，是一个裸的 $\\rm 2-Sat$ 问题。 考虑找出一种方案后统计方案数。首先有如下性质 ： 一个团中不可能取出一个以上的点加入独立集，因为两点之间必有连边。 一个独立集中不可能取出一个以上的点加入团，因为两点之间必无连边。 所以可以直接分别枚举团和独立集中的每个点，交换它们即可。 时间复杂度 $\\rm \\Theta(n^2)$。 [北京省选集训 2019] 完美塔防 首先预处理哪些炮台会互相打到，若存在，则输出 IMPOSSIBLE. 然后发现有如下结论： 每个空地最多可以被两个炮台打到。 因为每个空地最多在纵横两个方向上被打到，若还存在一个，则必定会打到其中一个炮台。 于是对每个炮台，它的纵横情况设为 $0/1$，每个空地会加入一个形如 $a~or~b$ 的条件，这就变成了经典的 $\\rm 2-Sat$ 问题。 时间复杂度 $\\Theta(Tn^3)$。 [HNOI2010] 平面图判定 首先有平面图中的欧拉定理，设一张无向连通图点数为 $v$，边数为 $e$，面数为 $f$，则有 ： $$v-e+f=2 $$考虑通过对 $e$ 进行归纳证明该式。 当 $e=0$ 时显然成立。 若当 $e'=e-1$ 时该式成立，我们要证 $v-e+f=1$ 成立只需证添加一条边会使得面数恰好增加 $1$。 而对于这个问题，我们可以分类讨论，若这条边加在某个面的中间，那么其必将这个面分成两半，若这条边加在图形外面，那么会围出一块新的区域，也会使面数恰好增加 $1$。 故该式成立。 我们进一步探究平面图的性质。定义面的度数为与其相邻的面的数量，显然对于每条边都会有恰好两个面与其相邻，故所有面的度数之和为 $2e$。 又因为每个面至少三条边，所以度数不小于 $3$，进而有 $3f$ 不大于所有面的度数之和，故有 $3f\\leqslant 2e$，将其带入平面图中的欧拉定理可得 ： $$e\\leqslant 3v-6 $$于是不满足该式的无向连通图均不为平面图，进而可以将 $m$ 限制到与 $n$ 同数量级。 我们发现题目给定了哈密顿回路，于是考虑以这个环作为中心考虑问题。 我么发现对于任意一条边，它要么从环内连接，要么从环外连接，并且如果有两条边 $u-v$ 和 $u'-v'$，且满足 $u&lt;u'&lt;v&lt;v'$，那么它们不能连在同一面。于是可以通过这种关系构建 $\\rm 2-Sat$ 模型。 时间复杂度 $\\Theta(Tn)$。","tags":"算法 oi 图论 2-sat 连通性 tarjan 缩点"},{"title":"决策单调性","url":"/2023/06/24/jue-ce-dan-diao-xing/","text":"四边形不等式优化 定义 假设有 $p_1\\leqslant p_2\\leqslant p_3\\leqslant p_4.$ 则 $c_{p_1,p_3}+c_{p_2,p_4}\\leqslant c_{p_1,p_4}+c_{p_2,p_3}$ 被称为四边形不等式。 假设一个问题满足四边形不等式，那么它的决策点有单调性。 Proof: 假设有如下问题 ：现在有一个序列，我们要将其分割开来，分割一段 $[l,r]$ 的代价是 $c_{l,r}$，求最小代价。 设 $F_i$ 表示将前 $i$ 个位置分割完毕的最小代价，显然有暴力转移 ： $$F_i=\\min\\limits_{j&lt;i}\\{F_j+c_{j,i}\\} $$设 $F_i$ 的决策点为 $p_i.$ 假设存在 $x&gt;y,p_x&lt;p_y.$ 根据最优决策的定义写出这个位置的转移式 : $$F_x=F_{p_x}+c_{p_x,x}\\leqslant F_{p_y}+c_{p_y, x} $$有 $p_x&lt;p_y&lt;y&lt;x$，根据四边形不等式得到 : $$c_{p_x,y}+c_{p_y,x}\\leqslant c_{p_y,y}+c_{p_x,x} $$两不等式相加，得到 : $$F_{p_x}+c_{p_x,y}\\leqslant F_{p_y}+c_{p_y,y} $$与前文矛盾，故不存在 $x&gt;y,p_x&lt;p_y$，即满足决策单调性。 需要注意的是，只有最小化问题才能通过四边形不等式判定决策单调性。 区间形式 在实际做题中，我们经常遇到这样的 $\\rm DP$ 方程 ： $$f_{i,j}=\\min\\limits_{i\\leqslant k&lt;j}\\{f_{i,k}+f_{k+1,j}+w_{i,j}\\} $$我们考虑将四边形不等式推广到二维形式。 定理 $1$ ：若 $w$ 满足四边形不等式，并且对于任意 $a \\leqslant b\\leqslant c\\leqslant d$，有 $w_{a,d}\\geqslant w_{b,c}$，则 $f$ 也满足四边形不等式。 定理 $2$ ：设 $p_{i,j}$ 表示 $f_{i,j}$ 的决策点，若 $f$ 满足四边形不等式，则对于任意 $i&lt;j$，有 $p_{i,j-1}\\leqslant p_{i,j}\\leqslant p_{i+1,j}.$ 例题 ：$\\rm [NOI1995] 石子合并$ 转移技巧 有单峰性 这个性质结合决策单调性有均摊转移复杂度 $\\Theta(1)$ 的做法 ： 记录一个指针表示当前的决策点，由于决策单调性所以它不会往回跳。进入每一层之后如果后面的决策点更优就跳到后面的决策点，根据单峰性这样一定不会漏掉解。 跳的次数是状态级别的，故转移均摊 $\\Theta(1).$ 仅有相邻层之间转移 这是一类特殊的二维 $\\rm DP$，仅有相邻层之间的转移，没有同层之间的转移，同时满足决策单调性。 一般这种 $\\rm DP$ 的时间复杂度是 $\\Theta(n^3)$ 的，每次转移需要枚举前一层的所有点。 我们发现一个性质，在同一层中，先枚举哪一个是无关紧要的，因为同一层之间不会发生转移。 于是可以考虑分治，先转移 $mid$，得到其最优决策为 $p$，然后就可以将区间划分开，$[l,mid)$ 和 $(mid,r]$ 分别对应 $[tl,p]$ 和 $[p,tr].$ 这样分治时间复杂度 $\\Theta(n\\log n).$ 例题 ：$\\rm [SDOI2016]征途$ 贡献难算 首先有例题 ：存在一个长度为 $n$ 的序列，要将它划分成 $k$ 段，每段的价值被定义为不同的元素个数，要求最大化贡价值和。 数据范围：$n\\leqslant 3.5\\times 10^4,k\\leqslant 50.$ 首先有一个 $\\Theta(n^3k)$ 的暴力 $\\rm DP$，设 $dp_{i,j}$ 表示当分到 $i$ 时已经分了 $j$ 段的最大价值，有转移式 ： $$dp_{i,j}=\\max\\limits_{k&lt;i}\\{dp_{k,j-1}+cnt_{k+1,i}\\} $$其中 $cnt_{l,r}$ 表示从 $[l,r]$ 中不同颜色的个数，单次计算需要 $\\Theta(n).$ 我们发现只在相邻层之间发生转移，并且满足决策单调性（直观理解就是分得越多越容易亏），于是可以使用之前提到的分治法。 这样看起来是优化到 $\\Theta(n^2k\\log n)$，但我们考虑计算贡献的具体过程。我们每次只会计算 $dp_{mid}$ 的值，每次询问一个区间 $[i,mid]$ 的不同元素个数，可以考虑固定右端点移动左端点，容易发现移动次数是当前的分治区间长度，于是总移动次数不会超过 $n\\log n$，故时间复杂度实际上为 $\\Theta(nk\\log n).$ 例题：$\\rm [P5574]任务分配问题$ 常用算法 斜率优化 假设 $\\rm DP$ 方程长成这种形式 ： $$dp_i=\\max\\limits_{j&lt;i}\\{dp_j+(i)'+(i)(j)+(j)'+C\\} $$即贡献为一个仅与 $i$ 有关的式子加上一个仅与 $j$ 有关的式子加上一个与两者都有关的乘积形式再加上一个常数，那么可以使用斜率优化。 我们发现 $dp_i,(i)',C$ 都与决策点的选择无关，于是可以把它们看作常数，将仅与 $j$ 有关的式子放在一边，可以得到方程 ： $$dp_j+(j)'=-(i)(j)+dp_i-(i)'-C $$我们发现这是一次函数的形式，考虑构造平面，平面上有一些点，形如 $((j),dp_j+(j)').$ 我们发现，如果用一条斜率为 $-(i)$ 的直线经过某个点，那么截距为 $dp_i-(i)'-C.$ 由于我们要最大化 $dp_i$，等价于最大化这个截距，所以用这根斜率为 $-(i)$ 的直线从上到下平移，第一个碰到的点就是决策点。 于是现在问题就变成了维护一个凸包，我们发现有三种情况 ： 当加入点按照横坐标单调递增的顺序，并且询问点单调递增时，可以直接维护单调队列，加入点对比队尾斜率，取答案从队首即可。 当加入点按照横坐标单调的顺序时可以维护一个单调队列，每次加入时对比斜率，取答案二分。 当加入点无序时直接用平衡树 (std :: set) 维护，用 lower_bound 查找插入点，然后向左右两边依次弹出，取答案也使用 lower_bound。 例题 ：$\\rm [SDOI2016]征途$ 二分队列 若 $\\rm DP$ 方程形如 ： $$dp_i=\\min\\limits_{j&lt;i}\\{dp_j+w_{j+1,i}\\} $$根据决策单调性的推论，任何两个点 $i,j(i&lt;j)$ 之间都存在一个点 $k$，在 $k$ 之前一段转移点为 $i$，在 $k$ 之后某一段转移点为 $j.$ 我们发现如果能快速计算 $w_{i,j}$，那么就能 $\\Theta(\\log n)$ 计算两个点 $i,j$ 之间的决策分界点。 我们发现所有相邻决策点的分界点可以用单调队列维护，具体来说 ： 求当前的最优决策时判断一下队首和队次首谁更优，若队首最优则决策点为队首，否则决策点为队次首，并且将当前队首弹出。 加入一个点时判断它是否能比队尾更快地替换掉队次尾，若能，则弹出队尾，重复操作。 这样就可以快速地维护相邻点的决策分界点了。 时间复杂度 $\\Theta(n\\log n).$ 例题 ：$\\rm [NOI2009]诗人小G$ 二分栈 有些题可能会有这样的奇怪性质 ：每个决策点只会被自己前面的点反超。 我们发现某个决策点会经历这样的过程 ：一开始就比前面的优（否则就相当于一开始就被别人反超了），然后在最优决策的地方呆一会儿，最后被某个点反超。 严格来说这根本不算决策单调性，但是仍然可以用二分栈来维护，因为两点的优劣仍旧可以 $\\Theta(\\log n)$ 对比。具体来说 ： 加入一个点时，若其比堆顶劣，则直接扔掉，若其比堆顶优，则留下。 每一轮判断一下堆次顶是否比堆顶优，优则将堆顶弹出。 这样堆顶就一直是当前转移的决策点。 例题 ：$\\rm [POI2011]Lightning~Conductor$ 习题 [NOI1995] 石子合并 首先有暴力转移 ： $$dp_{l,r}=\\min\\limits_{i\\leqslant k&lt;j}\\{dp_{i,k}+dp_{k+1,j}+w_{i,j}\\} $$记录前缀和 $sum$，这里 $w_{i,j}=sum_j-sum_{i-1}.$ $w$ 显然满足四边形不等式和包含单调，于是考虑四边形不等式优化。 然后就直接设 $p_{i,j}$ 表示 $dp_{i,j}$ 的转移点，成功转移的时候更新，枚举 $dp_{i,j}$ 断点的时候只需要枚举 $[p_{i,j-1},p_{i+1,j}]$ 即可。 时间复杂度 $\\Theta(n^2).$ [SDOI2016]征途 首先易知，设每一天走的长度为 $d$，则答案为 ： $$m\\sum_{i=1}^m(d_i-ave)^2=m\\sum_{i=1}^md_i^2-\\left(\\sum_{i=1}^md_i\\right)^2 $$容易观察到此题本质上是在求 $\\left(\\sum_{i=1}^md_i\\right)^2_{\\min}$，于是设 $f_{i,j}$ 表示当前已经考虑到第 $i$ 段，当前已经分成了 $j$ 段的最小 $\\sum_{p=1}^jd_p.$ 枚举转移点，容易得到转移方程 ： $$f_{i,j}=\\min\\limits_{k&lt;i}\\{f_{k,j-1}+(s_i-s_k)^2\\} $$易证 $w_{i,j}=(s_j-s_i)^2$ 满足四边形不等式，所以该转移方程满足决策单调性。我们还发现转移方程只在相邻层之间转移，所以可以使用分治转移。 时间复杂度 $\\Theta(n^2\\log n).$ 还有斜率优化的做法，注意到转移方程是可以变形的 ： $$f_{i,j}=f_{k,j-1}+(s_i-s_k)^2 $$$$\\iff f_{i,j}=f_{k,j-1}+s_i^2-2s_is_k+s_k^2 $$$$\\iff f_{k,j-1}+s_k^2=2s_i\\cdot s_k+f_{i,j}-s_i^2 $$易知插入点横坐标有序，询问斜率也有序，所以可以直接使用单调队列维护，每一层分开转移。 时间复杂度 $\\Theta(n^2).$ [P5574]任务分配问题 非常套路的分治 $+$ 决策单调性优化 $\\rm DP.$ 首先定义 $w_{i,j}$ 表示 $i\\sim j$ 的顺序对个数，设 $f_{i,j}$ 表示当前已经考虑到第 $i$ 个任务，将他们分成 $j$ 段的最小顺序对数量之和，易得转移方程 ： $$f_{i,j}=\\min\\limits_{k&lt;i}\\{f_{k,j-1}+w_{k+1,i}\\} $$对于任意 $a\\leqslant b\\leqslant c\\leqslant d$，使用容斥易证 $w_{a,c}+w_{b,d}-w_{b,c}\\leqslant w_{a,d}$，故 $w$ 满足四边形不不等式。进一步的，$f$ 的转移满足决策单调性。 有了决策单调性，我们就可以分治转移，同时令人惊喜的是，转移时需要遍历一段连续的区间并计算每一个位置的贡献，于是用莫队和 $\\rm BIT$ 维护一下就好了。 时间复杂度 $\\Theta(nk\\log^2n).$","tags":"算法 oi 动态规划 决策单调性 四边形不等式 斜率优化 二分队列"},{"title":"常见函数图像","url":"/2023/06/24/chang-jian-han-shu-tu-xiang/","text":"注意需要从定义域，奇偶性，单调性，特殊点，趋势等方面分析。 $y = xe ^ x$ 首先容易知道 $y = xe ^ x$ 的定义域为 $\\mathbb{R}$。 然后考虑对其求导，得到 $y' = e ^ x(x + 1)$。 可以发现 $e ^ x$ 恒大于 $0$，$x + 1$ 在 $x$ 小于 $-1$ 时小于 $0$，在 $x$ 不小于 $-1$ 时不小于 $0$。 于是我们可以初步以 $(1, -\\frac{1}{e})$ 作为分界点，继续分析。 当 $x &lt; -1$ 时，可以发现 $e ^ x$ 变小得越来越慢，并且导数为负，所以函数从 $(1, -\\frac{1}{e})$ 开始向左以 $x$ 轴为渐近线递增。 当 $x &gt; -1$ 时，可以发现 $e ^ x$ 增长得很快，与 $x + 1$ 完全不是一个量级的，于是函数图像主要由 $e ^ x$ 产生影响，画出的图像与指数函数类似，要稍微陡一点点。 另外一个需要注意的是，函数过点 $(0, 0)$。 $y = \\frac{e ^ x}{x}$ 首先容易知道 $y = \\frac{e ^ x}{x}$ 的定义域为 $\\mathbb{R}\\backslash\\{0\\}$。 然后考虑对其求导，得到 $y' = \\frac{e ^ x(x - 1)}{x ^ 2}$，容易发现需要以 $x = 0, 1$ 作为分界点进行分析： 当 $x &lt; 0$ 时，在靠左边的地方 $e ^ x$ 的影响非常大，于是往左的函数图像与 $y = xe ^ x$ 类似。但是在接近 $x = 0$ 的地方 $e ^ x$ 的影响较小，剩下部分的结构与 $\\frac{1}{x}$ 类似，于是函数图像也是类似的。 当 $0 &lt; x &lt; 1$ 时，在接近 $x = 0$ 的地方 $e ^ x$ 的影响较小，剩下部分的结构与 $\\frac{1}{x}$ 类似，于是函数图像也是类似的。 当 $x &gt; 1$ 时， $e ^ x$ 的影响逐渐变大，于是函数图像类似于指数函数，要稍微缓一点点。 $y = \\frac{x}{e ^ x}$ 首先容易知道 $y = \\frac{x}{e ^ x}$ 的定义域为 $\\mathbb{R}$。 然后考虑对其求导，得到 $y' = \\frac{1 - x}{e ^ x}$，容易发现需要以 $x = 1$ 作为分界点进行分析。分析过程与 $y = xe ^ x$ 类似（所以图像也是类似的），此处不做赘述。 $y = x \\ln x$ 首先容易知道 $y = x \\ln x$ 的定义域为 $\\mathbb{R}^+$。 然后对其求导，得到 $y' = \\ln x + 1$。 可以发现从 $x = 0$ 开始，$y'$ 从 $- \\infty$ 开始快速增大，在 $\\frac{1}{e}$ 处取到 $0$，然后继续缓慢增大。 于是 $y$ 一开始快速下降，在 $(\\frac{1}{e}, -\\frac{1}{e})$ 处取到最小值，然后加速上升，加速度略大于 $y = x$，远小于 $y = x ^ 2$。 $y = \\frac{\\ln x}{x}$ 容易知道 $y = \\frac{\\ln x}{x}$ 的定义域为 $\\mathbb{R}^+$。 然后对其求导，得到 $y' =\\frac{1 - \\ln x}{x ^ 2}$，容易发现需要以 $x = 1, e$ 作为分界点进行分析。 当 $0 &lt; x &lt; 1$ 时，往左 $1 - \\ln x$ 快速增大，$x ^ 2$ 快速缩小，于是 $y'$ 总体快速增大，所以 $y$ 从 $(1, 0)$ 开始向左以 $y$ 轴为渐近线快速下降。 当 $1 &lt; x &lt; e$ 时，$1 - \\ln x &gt; 0, x ^ 2 &gt; 0$，并且 $y'$ 的值不大，所以 $y$ 从 $(1, 0)$ 开始缓慢上升，以 $(e, \\frac{1}{e})$ 作为最高点。 当 $x &gt; e$ 时，$1 - \\ln x &lt; 0, x ^ 2 &gt; 0$，并且 $1 - \\ln x$ 的下降速度远不如 $x ^ 2$ 的上升速度，于是 $y' &lt; 0$ 且以 $0$ 为渐近线不断变大，体现在图像上即为 $y$ 从 $(e, \\frac{1}{e})$ 开始减速下降。 $y = \\frac{x}{\\ln x}$ 容易知道 $y = \\frac{x}{\\ln x}$ 的定义域为 $\\mathbb{R}^+ \\backslash\\{1\\}$。 然后对其求导，得到 $y' = \\frac{\\ln x - 1}{\\ln ^ 2 x}$，容易发现需要以 $x = 1, e$ 作为分界点进行分析。 当 $0 &lt; x &lt; 1$ 时，$\\ln x - 1$ 始终小于 $0$，$\\ln ^ 2 x$ 始终大于 $0$。在靠近 $x = 0$ 时，$\\ln x \\to - \\infty$，故 $\\frac{\\ln x - 1}{\\ln ^ 2 x} \\to \\frac{1}{-\\infty}$，于是 $y$ 下降幅度很小；在靠近 $x = 1$ 时，$\\ln x \\to 0$，所以 $\\frac{\\ln x - 1}{\\ln ^ 2 x} \\to -\\infty$，于是 $y$ 下降幅度很大。 当 $1 &lt; x &lt; e$ 时，$\\ln x - 1$ 始终小于 $0$，$\\ln ^ 2 x$ 始终大于 $0$。由于在 $x$ 仅比 $1$ 大一点点的时候 $\\ln x$ 非常接近 $0$，所以 $y$ 从 $(1, +\\infty)$（一个虚拟的点）开始以非常快的速度下降，然后逐渐变得平缓，在 $(e, e)$ 取到最小值。 当 $x &gt; e$ 时，$\\ln x - 1$ 以缓慢的速度从 $0$ 开始变大，$\\ln ^ 2 x$ 以比 $\\ln x$ 快一些，但仍然十分缓慢的速度从 $1$ 开始变大。由于其结构上与 $\\frac{1}{\\ln x}$ 十分类似，所以它以非常缓慢的速度减小。体现在图像上即为 $y$ 不断上升，但上升速度越来越慢。","tags":"数学 分析 函数 初等数学"},{"title":"「Codechef」Children Trips","url":"/2023/06/24/codechef-children-trips/","text":"Description 你在一颗树上旅行。 树由 $n$ 个点，$n - 1$ 条边构成，每条边的长度 $w$ 是 $1$ 或 $2$。 你要从点 $u$ 沿着唯一的简单路径走到点 $v$。但是，你的体力有限，所以一天之内最多只能走 $l$ 的距离。一天结束时待在树的节点外是很危险的，所以你必须在一天结束前到达某个节点并停下（可以刚好到达），即使你没有走到 $l$ 的距离。 给定这棵树和 $q$ 个询问，每个询问给出 $u,v,l$，请求出至少需要多少天。 数据范围 : $1 \\leqslant n,q \\leqslant 10^5, 1 \\leqslant x,y,u,v \\leqslant n,w \\in \\{1, 2\\}, 2 \\leqslant l \\leqslant 2n.$ Tutorial Lemma1: 一条路径，正着走和倒着走答案是一样的。 Proof1: 考虑将正着和倒着每天累计走的距离写下来，容易发现正着走相当于一开始落后了至多 $1$ 的距离，后面在不断追赶。可以发现在走的过程中是存在单调性的，所以正着走一定不可能超过倒着走，但也不可能落后超过 $1$。由于最后会走到相同的位置，所以答案是一样的。 有了上述引理，我们就可以考虑分别计算 $u$ 和 $v$ 分别跳到 $\\textrm{LCA}(u, v)$ 下面最高能跳到的点的答案。设 $l_1, l_2$ 分别表示 $u$ 和 $v$ 剩下的距离，最终答案即为 $u$ 和 $v$ 的答案之和加上 $\\left\\lceil\\frac{l_1 + l_2}{l}\\right\\rceil$。 考虑对询问根号分治，分别处理 $l \\leqslant \\sqrt{n}$ 的询问和 $l &gt; \\sqrt{n}$ 的询问。 对于 $l &gt; \\sqrt{n}$ 的询问，可以发现其跳的次数不超过 $\\sqrt{n}$，于是可以直接暴力跳，用倍增维护一下即可。 对于 $l \\leqslant \\sqrt{n}$ 的询问，可以预处理出从每个点 $u$ 开始，此时的 $l = k$，往上跳 $2 ^ i$ 天到的点 $f_{u, k, i}$，倍增往上跳即可。 时间复杂度 $\\Theta(n \\sqrt{n} \\log n)$，卡一卡常可以通过。 考虑换一种思路，我们给树上 $\\sqrt{n}$ 个点打上标记，称它们为特殊点。那么如果标记打得足够均匀，就可以使 $u, v \\to \\textrm{LCA}(u, v)$ 的路径上每隔 $\\sqrt{n}$ 的距离经过一个特殊点，且总共经过 $\\sqrt{n}$ 个特殊点。至于如何打标记，可以记 $dis_u$ 表示 $u$ 到树上最远点的距离，取 $B = \\sqrt{n}$，$u$ 为标记点当且仅当 $B | dis_u$。 考虑预处理 $f_{u, k}$ 表示当 $l = k$ 时，从 $u$ 开始走一天到的点（如果这个点超过了 $u$ 祖先中最深的特殊点，那么就将 $f_{u, k}$ 设为该特殊点，并且计算剩下了多少距离），$g_{u, k}$ 表示当 $l = k$ 时，从 $u$ 开始走到 $u$ 祖先中最深的特殊点需要花费的天数。 容易发现，由于走到 $u$ 祖先中最深的特殊点最多 $2\\sqrt{n}$ 的距离，所以 $k$ 的取值范围为 $[0, 2\\sqrt{n}]$。预处理直接从上往下递推即可，由于状态总数是 $n \\sqrt{n}$ 的，所以预处理时间复杂度也是 $\\Theta(n \\sqrt{n})$。至于如何使用这两个数组优化往上跳的过程则是简单的，不作赘述。 总时间复杂度 $\\Theta(n \\sqrt{n})$，可以轻松通过此题。","tags":"题解 codechef"},{"title":"「CF690A」Collective Mindsets","url":"/2023/06/24/cf690a-collective-mindsets/","text":"Description 你是一只僵尸。 你现在和 $n - 1$ 个僵尸站在一起分配大脑。你的编号是 $1$，其他僵尸编号 $2 \\sim n$。 僵尸们按照编号从小到大的顺序提出分配方案（一个方案是指每个僵尸分配几个大脑，大脑不能有剩余），然后所有僵尸进行投票，如果得票数大于等于一半方案就通过，否则当前的僵尸会被其它僵尸吃掉，由下一个僵尸进行分配。 僵尸们都很贪婪和残忍，但它们更不想被吃掉，所以僵尸们会在保证自己不被吃掉的情况下提出自己获得的大脑最多的方案，并且当且仅当吃掉分配的僵尸严格劣于同意分配方案时才会投赞同票。 给定 $n$，现在你想活下去，并且获得至少 $m$ 个大脑，请问至少需要多少大脑才能满足？ 数据范围 : $n \\leqslant 10 ^ 9, m \\in \\{0, 1\\}.$ Tutorial 首先考虑 $m = 1$ 的情况。 容易知道，当 $n = 1$ 或 $n = 2$ 时，不需要其它任何人同意，所以只需要给自己分配一个脑子即可，答案为 $1$。 当 $n = 3$ 时，$1$ 号不可能获得 $2$ 号的投票，因为 $1$ 号死后 $2$ 号可以独占所有脑子，于是 $1$ 号只能去争取 $3$ 号的同意。又因为如果让 $2$ 号来分配，$3$ 号一个脑子都得不到，所以分给它 $1$ 个脑子即可获得它的同意，答案为 $2$。 考虑不断将 $n$ 增加来考虑，可以发现，在上一步中可以获得脑子的僵尸是无法收买的，于是给上一步中无法获得脑子的僵尸分别分配 $1$ 个脑子就可以获得它们的同意。 综上，当 $m = 1$ 时，答案为 $\\left\\lfloor\\frac{n + 1}{2}\\right\\rfloor$。 然后考虑 $m = 0$ 的情况。 首先可以确定一个答案的上界，即考虑到 $m = 1$ 情况下的分法，答案至多为 $\\left\\lfloor\\frac{n - 1}{2}\\right\\rfloor$。 考虑当答案为 $0$ 时有哪些僵尸可以存活: 首先给僵尸重新标号，记最后提方案的僵尸为 $1$ 号，倒数第二个为 $2$ 号，依此类推。 容易知道，当 $n = 1$ 或 $n = 2$ 时，所有僵尸均可存活。 $3$ 号僵尸无法牵扯任何僵尸的利益，所以它无法存活。 $4$ 号僵尸死后，$3$ 号僵尸也会死，于是它获得 $3$ 号僵尸的支持，可以存活。 $5, 6, 7$ 号僵尸全部死后 $1, 2, 3, 4$ 号僵尸也不会有任何损失，于是它们都不会同意 $5, 6, 7$ 号僵尸的方案，所以 $5, 6, 7$ 号无法存活。 $8$ 号僵尸死后 $5, 6, 7$ 号会死，于是它可以获得除自己外 $3$ 只僵尸的支持，可以存活。 到这里，我们可以找到规律，在用到 $0$ 个脑子的情况下，$1, 2, 4, 8, 16, \\cdots$ 号僵尸可以存活。 用与之前类似的方式分析脑子总数为 $1, 2, 3, \\cdots$ 的情况，我们可以发现，当脑子总数为 $B$ 时，存活僵尸的集合为 $\\{1, 2, \\cdots, 2B\\} \\cup \\{2B + 2 ^ i|i \\in N ^ *\\}$。 当 $n \\equiv 1 \\pmod 2$ 时，$n$ 仅有可能在集合 $\\{1, 2, \\cdots, 2(B + 1)\\}$ 中出现，于是答案为 $\\frac{n - 1}{2}$。 当 $n \\equiv 0 \\pmod 2$ 时，可以找到最大的 $2$ 的幂 $p$ 满足 $p \\leqslant n$，此时 $n$ 会在 $B = \\frac{n - p}{2}$ 时第一次出现在集合中，于是答案即为 $\\frac{n - p}{2}$。 综上，时间复杂度 $\\Theta(\\log n)$。 Reference Code #include &lt;bits/stdc++.h&gt; using namespace std; int n, m; int main () &#123; cin &gt;&gt; n, m = 1/*0*/; if (m == 1) printf(&quot;%d\\n&quot;, (n + 1) / 2); else if (n &amp; 1) printf(&quot;%d\\n&quot;, (n - 1) / 2); else &#123; int p = 1; while (p * 2 &lt;= n) p *= 2; printf(&quot;%d\\n&quot;, (n - p) / 2); &#125; return 0; &#125;","tags":"题解 codeforces"},{"title":"AtCoder Beginner Contest 247","url":"/2023/06/24/atcoder-beginner-contest-247/","text":"E 考虑枚举右端点 $R$，计算对于每个 $R$ 有多少个左端点 $L$ 满足条件。 左端点需要满足的条件如下： $[L, R]$ 中需要有 $x$ 和 $y$ 至少各一个。 $[L, R]$ 中不能出现比 $x$ 大或比 $y$ 小的元素。 转化条件： 设 $px$ 表示 $[1, R]$ 中最右边 $x$ 的位置，$py$ 表示 $[1, R]$ 中最右边 $y$ 的位置，$L \\leqslant \\min(px, py)$。 设 $gex$ 表示 $[1, R]$ 中最右边大于 $x$ 的位置，$ley$ 表示 $[1, R]$ 中最右边小于 $y$ 的位置，$L &gt; \\max(gex, ley)$。 于是只需要在枚举 $R$ 的同时维护 $px, py, gex, ley$ 并将 $\\min(px, py) - \\max(gex, ley)$ 计入答案即可。 时间复杂度 $\\Theta(n)$。 F 考虑到每个数都需要存在，并且它在恰好两个位置中出现过（这两个位置可能相同），于是将这两个位置在一张图中连无向边。 观察到每个点度数都恰好为 $2$，于是连边后构成若干个环。 易知，整体方案数为每个环方案数的乘积，每个环的方案数为点覆盖方案数。 考虑求解大小为 $m$ 的环的点覆盖方案数。考虑强行将环从 $n \\sim 1$ 处拆成链，设 $f_{i, 0/1}$ 表示仅考虑 $1 \\sim i$ 的链，中间每条边都至少有一个端点被选，第 $i$ 个点被选或不选的方案数。转移是简单的。但是我们发现最后计算答案时需要知道第一个点到底选没选，于是需要钦点第一个点选或不选分别转移。 将转移方程写出来后，我们观察到它其实是两个斐波那契状物之和，于是用数列 $f_1 = 1, f_2 = 3, f_i = f_{i - 1} + f_{i - 2}$ 来拟合是可行的（当然也可以直接算，复杂度不变，代码也没长多少）。 综上即可算出原问题答案，时间复杂度 $\\Theta(n)$。 Code Link","tags":"c++ 题解 atcoder abc"},{"title":"AtCoder Beginner Contest 213","url":"/2023/06/24/atcoder-beginner-contest-213/","text":"E 考虑使用 $\\rm bfs$。 观察到每一步的代价都是 $0$ 或 $1$，于是建立双端队列。每次迭代取队头，如果走了代价为 $0$ 的边就将出点加入队首，否则加入队尾。 考虑其正确性，因为走代价为 $0$ 的边不会增加当前点的答案，所以可以维护住当前取出的点一定是答案最小点的性质。 时间复杂度 $\\Theta(nm)$。 另外，这种模型还可拓展到代价为 $0 \\sim k$，只需要对每种贡献维护一个队列即可，容易发现仍然满足单调性。时间复杂度 $\\Theta(nk)$。 G 考虑使用状压 $\\rm DP$。 设 $f_S$ 表示仅考虑 $S$ 的导出子图，令它与 $1$ 连通的方案数。设 $cnt_S$ 表示 $S$ 导出子图中的边数，显然有： $$ans_k = \\sum _ {1, k \\in S} f_S \\times 2 ^ {cnt_{U-S}} $$考虑容斥求解 $f_S$，有： $$f_S = 2 ^ {cnt_S} - \\sum _ {1 \\in T, T \\subsetneq S} f_T \\times 2 ^ {cnt_{S - T}} $$求解两部分的时间复杂度分别为 $\\Theta(n ^ 2 2 ^ n)$ 和 $\\Theta(3 ^ n)$。 另外，后半部分可以使用 $\\rm FWT$ 优化或卷积做到 $\\Theta(n ^ 2 2 ^ n)$。 H 考虑 $\\rm DP$。设 $f_{i, j}$ 表示到 $i$ 为止经过长度为 $j$ 的路径的方案数，记 $E_{u, v, w}$ 表示从 $u$ 到 $v$ 长度为 $w$ 的路径数量。显然有转移方程： $$f_{i, j} = \\sum _ {k = 1} ^ n \\sum _ {l = 1} ^ T f_{k, j - l} \\times E_{k, i, l} $$考虑用 $\\rm GF$ 拟合这个过程，设 $F_i(x) = \\sum \\limits_{j} f_{i, j} x ^ j$，$G_{i, j}(x) = \\sum \\limits_ {k \\geqslant 1} E_{i, j, k} x ^ k.$ 有方程： $$F_i(x) = \\sum _ {j = 1} ^ n F_j(x) \\times G_{j, i}(x) $$使用分治多项式乘法即可，时间复杂度 $\\Theta(n ^ 2 T \\log ^ 2 T)$。 Code Link","tags":"c++ 题解 atcoder abc"},{"title":"AtCoder Beginner Contest 214","url":"/2023/06/24/atcoder-beginner-contest-214/","text":"D 考虑枚举最大边，分别计算从两个端点出发能走到多少个点。 可以发现并查集能够很好地拟合这个过程，于是将边从小到大加入，每次合并的两个点集即为所求。 E 考虑贪心。从小到大枚举每一个盒子 $i$，所有满足 $L \\leqslant i$ 的球都可以放进这个盒子（如果 $R &lt; i$ 则无解），容易发现要选择 $R$ 最小的球放进当前盒子。 但是由于盒子数量很大，所以不能枚举盒子。考虑将所有区间按 $L$ 从小到大排序，记 $p$ 表示当前填到哪个盒子了，将所有满足 $L \\leqslant p$ 的盒子以 $R$ 为关键字加入小根堆，此时维护 $p$ 是简单的。 时间复杂度 $\\Theta(n \\log n)$。 F 首先考虑求解本质不同子序列数量。设 $f_i$ 表示考虑到 $s_i$ 且 $s_i$ 必选的方案数。 可以发现不同子序列个数是好求的，转移方程为 $f_i = \\sum \\limits _ {j = 0} ^ {i - 1} f_j$，但如何去除重复的子序列呢？ 令 $k$ 为满足 $s_k = s_i, k &lt; i$ 的最大整数，注意到在这种转移方式下会得出相同的子序列当且仅当在 $f_j (j &lt; k)$ 的后面直接接上了 $s_i$，于是本质不同子序列计数的转移方程为 $f_i = \\sum \\limits _ {j = 0} ^ {i - 1} f_j - \\sum \\limits _ {j = 0} ^ {k - 1} f_j = \\sum \\limits _ {j = k} ^ {i - 1} f_j.$ 而子序列中相邻两字符在原串中不相同的限制是好保证的，只需要考虑其不同子序列个数的转移方程为 $f_i = \\sum \\limits_ {j = 0} ^ {i - 2} f_j$ 对后面的推导稍作修改即可得到本质不同子序列计数的转移方程为 $f_i = \\sum \\limits _ {j = k - 1} ^ {i - 2} f_j$. 记录一下每个字符 $c$ 当前最后出现的位置，同时做前缀和优化即可做到 $\\Theta(1)$ 转移。 G 首先可以将 $q_i$ 对 $p_i$ 做置换，将限制转换成 $r_i \\not= i, a_i$ 的形式。 考虑将 $i$ 向 $a_i$ 连边，得到若干置换环。这时候问题可以重新描述为“每个点的取值不能为自身权值或后一个点的权值。” 考虑容斥，需要对每个 $k$ 分别计算“恰有 $k$ 个点不满足限制的方案数”。容易发现可以对每个环分别计算，于是考虑在一个长度为 $m$ 的置换环上如何计算。 考虑设 $f_{i, j, 0/1/2}$ 表示当前考虑到第 $i$ 个点，前 $i$ 个点中共有 $j$ 个点的取值不满足限制，且第 $i$ 个点的取值为（自身/后一个点/两者皆不）的方案数。转移之前枚举第一个点的取值状态，转移时两个状态之间不能转移当且仅当前一个点的取值为后一个点且后一个点的取值为它自身权值。最后统计方案时判断一下最后一个点的状态能否与枚举的第一个点的状态拼合即可。 将每个环的方案数算出来后只需要每次取两个最小的环使用暴力多项式乘法即可，容易证明时间复杂度是 $\\Theta(n ^ 2)$ 的。 最后考虑如何计算答案。若设恰好有 $k$ 个点的取值不满足限制的方案数为 $g_k$，则根据二项式反演公式，最终答案为： $$\\sum _ {i = 0} ^ {n} (-1) ^ i \\dbinom{n}{i} g_i \\times (n - i)! $$其中 $(n - i)!$ 是不满足限制的点的取值确定后，其它点的取值随意排列的方案数。 总时间复杂度 $\\Theta(n ^ 2)$。 Code Link","tags":"c++ 题解 atcoder abc"},{"title":"AtCoder Beginner Contest 212","url":"/2023/06/24/atcoder-beginner-contest-212/","text":"E 考虑记 $f_{i, u}$ 表示走 $i$ 步到 $u$ 的方案数。显然有转移式： $$f_{i, u} = \\sum _ {(u, v) \\in Edge} f_{i - 1, v} $$状态数为 $nk$，转移的时间复杂度为 $\\Theta(n)$，于是总时间复杂度为 $\\Theta(n ^ 2 k).$ 考虑到删除的边数很少，于是将转移方程改写为： $$f_{i, u} = \\sum _ {v = 1} ^ n f_{i - 1, v} - \\sum _ {(u, v) \\not\\in Edge} f_{i - 1, v} $$前一项可以算完每个 $i$ 以后记录一下，后一项合法转移数量之和为 $m$，于是总时间复杂度被优化至 $\\Theta(nk + mk).$ F 看到这个题，我们首先想到的肯定是倍增。 但是细想一下可以发现，从一个点 $i$ 开始跳 $2 ^ j$ 步到的地方还与时间有关，是难以处理的。 我们考虑记 $f_{i, j}$ 表示从 $i$ 号路径开始，跳 $2 ^ j$ 步到的地方，容易发现此时 $f_{i, j}$ 的值是唯一的。 于是用 $\\rm set$ 维护出 $y$ 号点在 $x$ 时刻开始要走上的路径，然后不断往后跳，直到停在最后一个时间不大于 $z$ 的位置，判断一下是停在路上还是停在点上即可。 时间复杂度 $\\Theta(n \\log n + q \\log n).$ G 首先考虑到当 $x = 0$ 时有且仅有 $y = 0$ 满足条件，于是我们不妨设 $1 \\leqslant x, y &lt; P$，最后再给答案加上 $1$。 考虑 $P$ 的一个原根 $r$，设 $x = r ^ a, y = r ^ b$，容易发现 $(x, y)$ 与 $(a, b)$ 一一对应，于是有： $$x ^ n \\equiv y \\iff r ^ {an} \\equiv r ^ b \\pmod P $$考虑拓展欧拉定理，可以发现： $$r ^ {an} \\equiv r ^ b \\pmod P \\iff an \\equiv b \\pmod {P - 1} $$于是问题被转化为求满足 $an \\equiv b \\pmod {P - 1}$ 的 $(a, b)$ 数量。 根据裴蜀定理，可以推导出： $$\\sum _ {a = 1} ^ {P - 1} \\sum _ {b = 1} ^ {P - 1} [an \\equiv b \\pmod {P - 1}] = \\sum _ {a = 1} ^ {P - 1} \\frac{P - 1}{(P - 1, a)} $$考虑对 $(P - 1, a)$ 相等的 $a$ 一起计算。设 $f(g)$ 表示满足 $g = (P - 1, a)$ 的 $a$ 的数量。可以发现 $g~|~P - 1$ 且 $f(g) = \\varphi\\left(\\frac{P - 1}{g}\\right)$。 考虑求解 $\\varphi(n)$，观察到 $\\varphi \\times I = id$，于是有： $$\\varphi(n) = n - \\sum _ {d | n \\&amp; d \\not= n} \\varphi(d) $$进一步有： $$f(g) = \\frac{P - 1}{g} - \\sum _ {g|k \\&amp; g \\not=k} f(g) $$从大到小枚举 $g$，枚举其倍数转移一下即可，时间复杂度 $\\Theta(\\sqrt{P} + d ^ 2(P - 1))$。 H 考虑记 $w + 1$ 为第一个大于所有 $a_i$ 的 $2$ 的幂，$S$ 为 $a$ 序列中数构成的集合。 造一个集合幂级数 $F(x) = \\sum _ {i = 0} ^ w [i \\in S]x ^ i$，容易发现答案即为： $$\\sum _ {i = 1} ^ n \\left(k ^ i - [x ^ 0] F^i(x) \\right) $$利用 $\\rm FWT$ 的线性性推一推式子： $$\\begin{aligned} &amp;~~~~~\\sum _ {i = 1} ^ n \\left(k ^ i - [x ^ 0] F^i(x) \\right) \\\\ &amp;=\\sum _ {i = 1} ^ n \\left( k ^ i - [x ^ 0] \\textrm{IFWT}(\\textrm{FWT}\\cdot F^i (x)) \\right) \\\\ &amp;=\\sum _ {i = 1} ^ n k ^ i - [x ^ 0] \\textrm{IFWT}\\left( \\sum _ {i = 1} ^ n \\textrm{FWT} \\cdot F^i(x)\\right) \\end{aligned} $$$\\rm FWT$ 后 $F$ 的幂表示对每一项系数做点乘。 设 $G(x) = \\textrm{FWT} \\cdot F(x)$，用一下等比数列求和公式，则有答案为： $$\\sum _ {i = 1} ^ n k ^ i - [x ^ 0] \\textrm{IFWT}\\left[ \\sum _ {i = 0} ^ w \\left( \\frac{g_i ^ {n + 1} - g_i}{g_i - 1} \\right)x ^ i \\right] $$计算上式所需时间复杂度为 $\\Theta((n + w) \\log (n + w)).$ Code Link","tags":"c++ 题解 atcoder abc"},{"title":"2022 年新一卷数学第 7 题另解","url":"/2023/06/24/2022-nian-gao-kao-quan-guo-i-juan-shu-xue-ke-mu-di-qi-ti-de-yi-chong-fei-chang-gui-jie-fa/","text":"设 $a = 0.1 e ^ {0.1}, b = \\frac{1}{9}, c = -\\ln 0.9$，试比较 $a, b, c$ 的大小。 考虑到以下公式： $$e ^ {qx} = \\sum _ {n} q ^ n \\frac{x ^ n}{n!} \\tag{7.1} $$$$\\ln(1 + x) = \\sum _ n (-1) ^ n \\frac{x ^ {n + 1}}{n + 1} \\tag{7. 2} $$将 $a$ 带入式 $(7. 1)$ 可得： $$\\begin{aligned} a &amp;= 0.1(1 + 0.1 + \\frac{0.01}{2} + \\frac{0.001}{6} + \\cdots) \\\\ &amp;= 0.1 + 0.01 + \\frac{0.001}{2} + \\frac{0.0001}{6} + \\cdots \\end{aligned} $$将 $c$ 带入式 $(7.2)$ 可得： $$\\begin{aligned} c &amp;= \\ln (1 + \\frac{1}{9}) \\\\ &amp;= \\frac{1}{9} - \\frac{\\frac{1}{9 ^ 2}}{2} + \\frac{\\frac{1}{9 ^ 3}}{3} - \\cdots \\end{aligned} $$分解 $b$ 是简单的： $$b = 0.111\\cdots = 0.1 + 0.01 + 0.001 + \\cdots $$此时 $b &gt; a, c$ 应当是一目了然的，于是考虑对比 $a, c$ 的大小。 取 $c' = \\frac{1}{9} - \\frac{1}{2 \\times 81} + \\frac{1}{3 \\times 729} &gt; c$，不够好算，再取 $c'' = \\frac{1}{9} - \\frac{1}{400} + \\frac{1}{2000} = \\frac{1}{9} - 0.002 &gt; c'$。 取 $a' = 0.1 + 0.01 &lt; a$，易知 $c'' &lt; a'$，于是 $c &lt; c' &lt; c'' &lt; a' &lt; a$。 综上，有 $c &lt; a &lt; b$。","tags":"题解 数学 高考"},{"title":"2021 年计数题康复训练","url":"/2023/06/24/2021-nian-ji-shu-ti-kang-fu-xun-lian/","text":"技巧收集 将要计数的总体分成很多个部分，每个部分分别计算贡献。 有些时候一个集合 $S$ 联合产生贡献，为了避免算重，可以将这个集合的贡献放在其中的某个元素上计算，比如标号最小的那一个。 可以考虑划分阶段，每次加入一个元素时计算答案增量。 如果需要计算在一个大的部分中选择一些状态的方案数，可以将这个大的部分分为几个，枚举在这几个部分中选择的状态数量，再分别计算并相乘。 可以先计算每一部分的答案，用某种数据结构维护，合并的时候考虑两个部分联合产生的答案。 如果子问题的答案容易计算，并且原问题与子问题之间存在容斥关系，可以用 $\\rm DP$ 计算，转移的时候容斥。 好题选做 [USACO20FEB] Help Yourself G 方法一： 首先有一个直观的想法，计算每条线段对答案的贡献。 考虑将每个连通块的贡献放到这个连通块最左边的线段上去计算，于是我们发现在一种选择方案中，一条线段 $[l_i,r_i]$ 有 $1$ 的贡献当且仅当不存在另一条同时被选择的线段 $[l_j,r_j]$ 满足 $l_j&lt;l_i&lt;r_j$，即其左端点不能被覆盖。 因为题目保证了所有端点互不相同，所以我们不需要经过比较复杂的分类讨论，直接将线段按左端点排序，右端点用线段树维护即可。 用线段树求出与当前线段不能同时选择的线段数，记为 $x$，则这条线段的贡献为 $2^{n-x-1}$。 总时间复杂度 $\\Theta(n\\log n)$。 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 1e5 + 10, mod = 1e9 + 7; int n, Pow[N], ans; pair &lt;int, int&gt; seg[N]; namespace ST &#123; #define LS (p &lt;&lt; 1) #define RS (p &lt;&lt; 1 | 1) int sum[N &lt;&lt; 3], l[N &lt;&lt; 3], r[N &lt;&lt; 3]; void Build (int p, int L, int R) &#123; l[p] = L, r[p] = R, sum[p] = 0; if (L == R) return; int mid = (L + R) &gt;&gt; 1; Build(LS, L, mid), Build(RS, mid + 1, R); &#125; void add (int p, int pos) &#123; if (l[p] == pos &amp;&amp; r[p] == pos) &#123; sum[p]++; return; &#125; pos &lt;= r[LS] ? add(LS, pos) : add(RS, pos); sum[p] = sum[LS] + sum[RS]; &#125; int Query (int p, int L, int R) &#123; if (l[p] &gt;= L &amp;&amp; r[p] &lt;= R) return sum[p]; int res = 0; if (L &lt;= r[LS]) res += Query(LS, L, R); if (R &gt;= l[RS]) res += Query(RS, L, R); return res; &#125; &#125; int main () &#123; scanf(&quot;%d&quot;, &amp;n); rep(i, 1, n) scanf(&quot;%d%d&quot;, &amp;seg[i].first, &amp;seg[i].second); Pow[0] = 1; rep(i, 1, n) Pow[i] = (Pow[i - 1] &lt;&lt; 1) % mod; sort(seg + 1, seg + n + 1); ST::Build(1, 1, 2 * n); rep(i, 1, n) &#123; ans = (ans + Pow[n - ST::Query(1, seg[i].first + 1, 2 * n) - 1]) % mod; ST::add(1, seg[i].second); &#125; printf(&quot;%d\\n&quot;, ans); return 0; &#125; 方法二： 还是考虑将线段按左端点排序后一个个加入并计算贡献，但是我们这次只考虑已经枚举了的 $i$ 条线段的答案，记为 $f_i$。 可以发现，如果当前枚举的线段不选，那么答案为 $f_{i-1}$，否则在选择某一个集合的时候答案会 $+1$，而这个集合中的线段即为右端点小于当前线段左端点的线段，记其数量为 $x$。 由于这个线段集合的每一个子集的答案都相比原来 $+1$，所以这种情况下的答案为 $f_{i-1}+2^x$。 故总的转移式为 $f_i=2f_{i-1}+2^x$。 至于 $x$ 的值可以很方便地在最开始用前缀和求出。 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 2e5 + 10, mod = 1e9 + 7; int n, sum[N], Pow[N], ans; pair &lt;int, int&gt; seg[N]; int main () &#123; scanf(&quot;%d&quot;, &amp;n); rep(i, 1, n) scanf(&quot;%d%d&quot;, &amp;seg[i].first, &amp;seg[i].second); Pow[0] = 1; rep(i, 1, n) Pow[i] = (Pow[i - 1] &lt;&lt; 1) % mod; rep(i, 1, n) sum[seg[i].second]++; rep(i, 1, (n &lt;&lt; 1)) sum[i] += sum[i - 1]; sort(seg + 1, seg + n + 1); rep(i, 1, n) ans = (2 * ans % mod + Pow[sum[seg[i].first - 1]]) % mod; printf(&quot;%d\\n&quot;, ans); return 0; &#125; [JSOI2015] 子集选取 看上去很简单，代码也很简洁，但如果要证明而非直接打表的话是一个有一定难度的题。 首先观察到题目限制等价于 $\\forall i'\\leqslant i,j'\\leqslant j,A_{i,j}\\subseteq A_{i',j'}$。 又观察到如果对每个元素分开考虑，那么一定存在一条从左下到右上的分界线，使分界线左边的集合都有这个元素，而右边都没有，形如下图 ： 容易发现，对于每个元素，这样的路径与每种方案一一对应，并且路径数为 $2^n$。 进一步的，容易发现每个元素的方案相互独立，于是将每个元素的方案数相乘即为最终答案 $2^{nk}$。 总时间复杂度 $\\Theta(\\log n)$。 #include&lt;bits/stdc++.h&gt; using namespace std; const int mod = 1e9 + 7; int n, k; int Pow (int a, int k) &#123; if (k == 1) return a; int S = Pow(a, k &gt;&gt; 1); if (k &amp; 1) return 1ll * S * S % mod * a % mod; else return 1ll * S * S % mod; &#125; int main () &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); printf(&quot;%d\\n&quot;, Pow(Pow(2, n), k)); return 0; &#125; [LG1350] 车的放置 首先考虑在一个 $k\\times k$ 的矩形上放置 $k$ 个车的方案数，显然为 $k!$。 然后考虑在一个 $n\\times m$ 的矩形上放置 $k$ 个车的方案数，可以先从 $n$ 行 $m$ 列中分别选出 $k$ 行 $k$ 列，再按照 $k\\times k$ 矩形的方式计算，方案数为 $\\binom{n}{k}\\binom{m}{k}k!$。 考虑将原图形划分成右边一个 $c\\times d$ 的矩形和左边一个 $a\\times (b+d)$ 的矩形，然后枚举在右边放置多少个车，可以发现右边每放置一个车都可以使左边能放置车的行减少一个，于是容易独立计算两边的方案数，故答案为 : $$\\sum_{i=0}^d \\dbinom{c}{i}\\dbinom{d}{i}i!\\dbinom{a}{k-i}\\dbinom{b+d-i}{k-i}(k-i)! $$总时间复杂度 $\\Theta(n)$。 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 2e3 + 10, mod = 1e5 + 3; int a, b, c, d, k, fac[N], inv[N], ans; int Pow (int a, int k) &#123; if (k == 0) return 1; if (k == 1) return a; int S = Pow(a, k &gt;&gt; 1); if (k &amp; 1) return 1ll * S * S % mod * a % mod; else return 1ll * S * S % mod; &#125; int C (int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod; &#125; int main () &#123; fac[0] = 1; rep(i, 1, N - 1) fac[i] = 1ll * fac[i - 1] * i % mod; inv[N - 1] = Pow(fac[N - 1], mod - 2); dep(i, N - 2, 0) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; k; rep(i, 0, k) ans = (ans + 1ll * C(c, i) * C(d, i) % mod * fac[i] % mod * C(a, k - i) % mod * C(b + d - i, k - i) % mod * fac[k - i]) % mod; printf(&quot;%d\\n&quot;, ans); return 0; &#125; [USACO20JAN] Cave Paintings P 想这题时思路容易往如何建图上跑偏，但其实完全不用建图，直接对着原模型考虑即可。 考虑从底层往上加水的过程，容易发现一些联通块会逐渐被连接在一起，可以考虑用并查集维护，两个连通块合并的答案显然为原本答案的乘积加上 $1$，因为所有的点都加上水也是一种方案。 最终的答案即为所有连通块的方案数之积。 总时间复杂度 $\\Theta(nm\\log (nm))$。 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) #define idx(x, y) ((x - 1) * m + y) const int N = 1e3 + 10, mod = 1e9 + 7; int n, m, fa[N * N], f[N * N], ans = 1; char s[N][N]; int Find (int x) &#123; if (x != fa[x]) fa[x] = Find(fa[x]); return fa[x]; &#125; signed main () &#123; cin &gt;&gt; n &gt;&gt; m; rep(i, 1, n) cin &gt;&gt; s[i] + 1; rep(i, 1, n * m) fa[i] = i, f[i] = 1; dep(i, n - 1, 2) &#123; rep(j, 3, m - 1) if (s[i][j] == &#x27;.&#x27; &amp;&amp; s[i][j - 1] == &#x27;.&#x27;) fa[Find(idx(i, j))] = Find(idx(i, j - 1)); rep(j, 2, m - 1) if (s[i][j] == &#x27;.&#x27; &amp;&amp; s[i + 1][j] == &#x27;.&#x27; &amp;&amp; Find(idx(i, j)) != Find(idx(i + 1, j))) f[Find(idx(i, j))] = f[Find(idx(i, j))] * f[Find(idx(i + 1, j))] % mod, fa[Find(idx(i + 1, j))] = Find(idx(i, j)); rep(j, 2, m - 1) if (s[i][j] == &#x27;.&#x27; &amp;&amp; Find(idx(i, j)) == idx(i, j)) f[idx(i, j)]++; &#125; rep(i, 2, n - 1) rep(j, 2, m - 1) if (Find(idx(i, j)) == idx(i, j)) ans = ans * f[idx(i, j)] % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; [HNOI2012] 排队 运用插板法和捆绑法易得答案即为 ： $$(n + 2)! A_{n + 3}^{m} - 2 (n + 1)! A_{n + 2}^{m} $$高精差评。 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 2e3 + 10; namespace BigInt_Class &#123; const int MaxL = 5e3 + 10; struct BigInt &#123; int len, bit[MaxL]; void Clear () &#123; for (int i = 1; i &lt;= len; i++) bit[i] = 0; len = 1; &#125; &#125;; void read (BigInt &amp;x) &#123; char s[MaxL]; scanf(&quot;%s&quot;, s + 1), x.len = strlen(s + 1); for (int i = 1; i &lt;= x.len; i++) x.bit[i] = s[x.len - i + 1] - &#x27;0&#x27;; &#125; void Write (BigInt x, char End) &#123; for (int i = x.len; i &gt;= 1; i--) printf(&quot;%d&quot;, x.bit[i]); putchar(End); &#125; bool operator &lt; (BigInt a, BigInt b) &#123; if (a.len != b.len) return a.len &lt; b.len; for (int i = a.len; i &gt;= 1; i--) if (a.bit[i] != b.bit[i]) return a.bit[i] &lt; b.bit[i]; return false; &#125; BigInt Change (int x) &#123; BigInt res; res.Clear(); if (x == 0) return res; else res.len = 0; while (x) res.bit[++res.len] = x % 10, x /= 10; return res; &#125; BigInt operator + (BigInt a, BigInt b) &#123; BigInt res; res.Clear(); res.len = max(a.len, b.len); for (int i = 1; i &lt;= res.len; i++) res.bit[i] = a.bit[i] + b.bit[i]; for (int i = 1; i &lt;= res.len; i++) if (res.bit[i] &gt;= 10) res.bit[i] -= 10, res.bit[i + 1]++; if (res.bit[res.len + 1] &gt; 0) res.len++; return res; &#125; BigInt operator - (BigInt a, BigInt b) &#123; BigInt res; res.Clear(); res.len = max(a.len, b.len); for (int i = 1; i &lt;= res.len; i++) res.bit[i] = a.bit[i] - b.bit[i]; for (int i = 1; i &lt;= res.len; i++) if (res.bit[i] &lt; 0) res.bit[i] += 10, res.bit[i + 1]--; while (res.bit[res.len] == 0 &amp;&amp; res.len &gt; 1) res.len--; return res; &#125; BigInt operator * (BigInt a, BigInt b) &#123; BigInt res; res.Clear(); res.len = a.len + b.len; for (int i = 1; i &lt;= a.len; i++) for (int j = 1; j &lt;= b.len; j++) res.bit[i + j - 1] += a.bit[i] * b.bit[j]; for (int i = 1; i &lt;= res.len; i++) if (res.bit[i] &gt;= 10) res.bit[i + 1] += res.bit[i] / 10, res.bit[i] %= 10; while (res.bit[res.len] == 0 &amp;&amp; res.len &gt; 1) res.len--; return res; &#125; BigInt operator / (BigInt a, BigInt b) &#123; BigInt res, tmp; res.Clear(); if (a &lt; b) return res; res.len = a.len - b.len + 1; for (int i = a.len; i &gt;= b.len; i--) &#123; tmp.Clear(), tmp.len = i; for (int j = 1; j &lt;= b.len; j++) tmp.bit[j + i - b.len] = b.bit[j]; while (!(a &lt; tmp)) a = a - tmp, res.bit[i - b.len + 1]++; &#125; while (res.bit[res.len] == 0 &amp;&amp; res.len &gt; 1) res.len--; return res; &#125; BigInt operator % (BigInt a, BigInt b) &#123; BigInt tmp; if (a &lt; b) return a; for (int i = a.len; i &gt;= b.len; i--) &#123; tmp.Clear(), tmp.len = i; for (int j = 1; j &lt;= b.len; j++) tmp.bit[j + i - b.len] = b.bit[j]; while (!(a &lt; tmp)) a = a - tmp; &#125; return a; &#125; &#125; using namespace BigInt_Class; int n, m; BigInt fac[N]; BigInt A (int n, int m) &#123; return n &lt; m ? Change(0) : fac[n] / fac[n - m]; &#125; int main () &#123; cin &gt;&gt; n &gt;&gt; m; fac[0] = Change(1); rep(i, 1, n + 3) fac[i] = fac[i - 1] * Change(i); Write(fac[n + 2] * A(n + 3, m) - Change(2) * fac[n + 1] * A(n + 2, m), &#x27;\\n&#x27;); return 0; &#125; [SDOI2016] 排列计数 看到题目一眼二项式反演，但事实上是不行的。 考虑钦点 $m$ 个位置 $a_i=i$，剩下的显然是 $n - m$ 个数的错排问题。 记 $D_{n}$ 表示 $n$ 个数的错排问题方案数，推导其递推式 ： 考虑在 $n$ 个数的基础上再加入第 $n + 1$ 个数，不妨设 $a_{n+1}=k$。 接下来对 $a_k$ 做分类讨论 ： 如果 $a_k=n+1$，那么 $k$ 和 $n+1$ 互相占用，剩下的方案数为 $D_{n-1}$。 如果 $a_k\\not = n + 1$，那么除了 $a_{n + 1}$ 已经被确定之外，其它所有位置都有且仅有一个数不能填 （位置 $k$ 不能填的数为 $n + 1$），于是方案即为 $D_{n}$。 再考虑到选取 $k$ 的方式有 $n$ 种，故 $\\{D_n\\}$ 的递推式为 ： $$D_{n + 1} = n(D_n + D_{n - 1}) $$根据错排数列的定义易知 $D_0 = 1, D_1 = 0,D_2 = 1$。 综上，答案即为 $\\binom{n}{m}D_{n-m}$。 总时间复杂度 $\\Theta(T+n)$。 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 1e6 + 10, mod = 1e9 + 7; int T, n, m, fac[N], inv[N], D[N]; int Pow (int a, int k) &#123; if (k == 0) return 1; if (k == 1) return a; int S = Pow(a, k &gt;&gt; 1); if (k &amp; 1) return 1ll * S * S % mod * a % mod; else return 1ll * S * S % mod; &#125; int C (int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod; &#125; int main () &#123; fac[0] = 1; rep(i, 1, N - 1) fac[i] = 1ll * fac[i - 1] * i % mod; inv[N - 1] = Pow(fac[N - 1], mod - 2); dep(i, N - 2, 0) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; D[0] = 1, D[1] = 0, D[2] = 1; rep(i, 3, N - 1) D[i] = 1ll * (i - 1) * (D[i - 1] + D[i - 2]) % mod; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); printf(&quot;%lld\\n&quot;, 1ll * C(n, m) * D[n - m] % mod); &#125; return 0; &#125; [HNOI2010] 合唱队 考虑到一段区间内的方案数是独立的，于是使用区间 $\\rm DP$ 求解。 可以发现我们关心的状态除了区间端点 $l,r$ 外，还有上一个填入值的大小，因为这关系到现在这个数填在左边还是右边。同时，我们观察到，上一个数只有可能填在区间的左端点或右端点，于是记 $f_{l,r,0/1}$ 表示在 $[l,r]$ 这段区间内，上一次填的数在左端点$/$右端点的方案数。 转移是简单的，分 $4$ 种情况 ： $a_i&lt;a_{i + 1},f_{i,j,0}\\leftarrow f_{i+1,j,0}$ $a_i&lt;a_{j},f_{i,j,0}\\leftarrow f_{i+1,j,1}$ $a_j&gt;a_{i},f_{i,j,1}\\leftarrow f_{i,j-1,0}$ $a_j&gt;a_{j-1},f_{i,j,1}\\leftarrow f_{i,j-1,1}$ 需要注意的是，赋初值时，可以钦点 $[i,j]$ 的数是从左端点填进去的，即 $f_{i,i,0} = 1$，如果不这样做的话会算重。 总时间复杂度 $\\Theta(n^2)$。 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 1e3 + 10, mod = 19650827; int n, a[N], f[N][N][2]; int main () &#123; cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; a[i]; rep(i, 1, n) f[i][i][0] = 1; rep(len, 2, n) for (int i = 1; i + len - 1 &lt;= n; i++) &#123; int j = i + len - 1; if (a[i] &lt; a[i + 1]) f[i][j][0] = (f[i][j][0] + f[i + 1][j][0]) % mod; if (a[i] &lt; a[j]) f[i][j][0] = (f[i][j][0] + f[i + 1][j][1]) % mod; if (a[j] &gt; a[i]) f[i][j][1] = (f[i][j][1] + f[i][j - 1][0]) % mod; if (a[j] &gt; a[j - 1]) f[i][j][1] = (f[i][j][1] + f[i][j - 1][1]) % mod; &#125; cout &lt;&lt; (f[1][n][0] + f[1][n][1]) % mod &lt;&lt; endl; return 0; &#125; [HNOI2011] 卡农 形式化题意： 定义全集 $U=\\{1,2,3,\\cdots ,n\\}$，要从中选出 $m$ 个子集，满足 ： 任意子集非空。 子集互不相同。 在选出的 $m$ 个子集中，$1\\sim n$ 中每个数的出现次数均为偶数。 求方案数对 $10^8 + 7$ 取模后的值。 保证 $n,m\\leqslant 10^6$。 考虑计算选出子集有序的方案数，容易发现最后将方案数除以 $m!$ 就与原问题等价。 记 $f_i$ 表示从 $U$ 中选出 $i$ 个合法子集的方案数，转移考虑容斥 ： 如果前面的 $i - 1$ 个集合已经确定，那么这个集合中每个元素是否存在就已经被确定了，并且一定存在一种选择这个集合的方案，故在不考虑子集非空和子集互不相同的情况下，方案数为 $A_{2^n - 1}^{i - 1}$。 考虑将第 $i$ 个集合为空的方案去除。可以发现在第 $i$ 个集合为空的情况下，不合法方案与 $f_{i - 1}$ 中的每种合法方案一一对应，故第 $i$ 个集合为空的方案数为 $f_{i - 1}$。 考虑将第 $i$ 个集合与前面某个集合 $S_j$ 相同的方案去除。可以发现，将 $S_i$ 和 $S_j$ 同时去除后的方案还是合法的，且数量为 $f_{i - 2}$。 $j$ 有 $i - 1$ 种取值，$S_{i}$ 和 $S_{j}$ 由于不能与另外 $i - 2$ 个集合相同，所以有 $(2^n - 1) - (i - 2)$ 种取法。故第 $i$ 个集合与之前某个集合相同的方案数为 $f_{i - 2}\\times (i - 1)\\times (2^n - i + 1)$。 故转移方程为 ： $$f_{i} = A_{2^n - 1}^{i - 1} - f_{i - 1} - f_{i - 2}\\times (i - 1)\\times (2^n - i + 1) $$经过一些预处理后可以做到 $\\Theta(n)$。 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 1e6 + 10, mod = 1e8 + 7; int n, m, A[N], f[N], M; int Pow (int a, int k) &#123; if (k == 0) return 1; if (k == 1) return a; int S = Pow(a, k &gt;&gt; 1); if (k &amp; 1) return 1ll * S * S % mod * a % mod; else return 1ll * S * S % mod; &#125; int main () &#123; cin &gt;&gt; n &gt;&gt; m; A[0] = Pow(2, n), A[1] = A[0] - 1; rep(i, 2, m) A[i] = 1ll * A[i - 1] * (A[0] - i) % mod; f[0] = 1; rep(i, 2, m) f[i] = (A[i - 1] - f[i - 1] - 1ll * f[i - 2] * (i - 1) % mod * (A[0] - i + 1)) % mod; M = 1; rep(i, 1, m) M = 1ll * M * i % mod; cout &lt;&lt; (1ll * f[m] * Pow(M, mod - 2) % mod + mod) % mod &lt;&lt; endl; return 0; &#125; [ZJOI2010] 排列计数 可以发现 [CSP-S2019 江西] 多叉堆 是这个题的弱化版，但区别不算很大。 考虑依据偏序关系连边，可以发现构成一颗满足小根堆性质的树。 记 $f_{i}$ 表示以点 $i$ 为根的子树的方案数，显然子树内答案独立，故只需要考虑乘上分配给子树的方案数即可得 ： $$siz_i = siz_{2i} + siz_{2i + 1} + 1 $$$$f_i = f_{2i}\\times f_{2i + 1}\\times \\dbinom{siz_i - 1}{siz_{2i}} $$因为模数有可能小于 $n$，所以求组合数需要用到 $\\rm Lucas$ 定理。 需要注意的是，在预处理阶乘逆元的时候最多预处理到 $\\rm mod - 1$，否则会出现为 $0$ 的情况。 总时间复杂度 $\\Theta(n\\log n)$。 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i, l, r) for (int i = l; i &lt;= r; i++) #define dep(i, r, l) for (int i = r; i &gt;= l; i--) const int N = 2e6 + 10; int n, mod, Min, fac[N], inv[N], siz[N], f[N]; int Pow (int a, int k) &#123; if (k == 0) return 1; if (k == 1) return a; int S = Pow(a, k &gt;&gt; 1); if (k &amp; 1) return 1ll * S * S % mod * a % mod; else return 1ll * S * S % mod; &#125; int Lucas (int n, int m) &#123; if (n &lt; mod &amp;&amp; m &lt; mod) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod; &#125; return 1ll * Lucas(n / mod, m / mod) * Lucas(n % mod, m % mod) % mod; &#125; int main () &#123; cin &gt;&gt; n &gt;&gt; mod, Min = min(n, mod - 1); fac[0] = 1; rep(i, 1, Min) fac[i] = 1ll * fac[i - 1] * i % mod; inv[Min] = Pow(fac[Min], mod - 2); dep(i, Min - 1, 0) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; rep(i, 1, n) siz[i] = 1; dep(i, n, 1) siz[i] += siz[i &lt;&lt; 1] + siz[i &lt;&lt; 1 | 1]; rep(i, ((n + 1) &gt;&gt; 1), n) f[i] = 1; dep(i, ((n + 1) &gt;&gt; 1) - 1, 1) &#123; f[i] = 1ll * f[i &lt;&lt; 1] * f[i &lt;&lt; 1 | 1] % mod * Lucas(siz[i] - 1, siz[i &lt;&lt; 1]) % mod; &#125; printf(&quot;%d\\n&quot;, f[1]); return 0; &#125;","tags":"oi c++ 题解 趣题 计数 组合数学"},{"title":"关于我","url":"/about/index.html","text":"我是该博客的开发者, 你可以称呼我为 CCA. 不论你是我的朋友, 同学或是在茫茫信息流中偶然走入这里的陌生人, 欢迎你的到访. 若是此刻短暂的缘分能为你求索的道路铺上半块砖石, 我将不胜荣幸. 若对本站有任何疑问和想法, 都可以在评论区留言, 或直接联系我: QQ: 1517604744 WeChat: CCA101001011 Email: 1120230069@smbu.edu.cn","tags":""},{"title":"tags","url":"/tags/index.html","text":"","tags":""},{"title":"categories","url":"/categories/index.html","text":"","tags":""}]}